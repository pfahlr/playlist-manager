OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a56d9-6b8e-7c60-83f6-d9ef9394b71f
--------
user
Implement the functionality described in codex/TASKS/03c_token_encryption_at_rest.yaml, then verify with any available tests.

thinking
**Preparing to implement token encryption task**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 784ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Handling missing file warning and opening YAML**
exec
bash -lc 'cat codex/TASKS/03c_token_encryption_at_rest.yaml' in /var/home/rick/Development/playlist-manager succeeded in 112ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 03c_token_encryption_at_rest
title: Encrypt provider refresh tokens at rest (libsodium) + rotation
branch: codex/03c_token_encryption_at_rest
overview: >
  Encrypt provider refresh/access tokens before persisting. Use libsodium sealed boxes with a
  MASTER_KEY (env). Provide a rotation script that re-encrypts rows when the key changes.
acceptance:
  - tokens are stored encrypted (no plaintext in DB/logs)
  - rotation script re-encrypts existing rows and is idempotent
  - unit tests cover encrypt/decrypt + failure modes
artifacts_to_touch:
  - apps/api/src/lib/crypto/keystore.ts
  - packages/db/prisma/schema.prisma (provider_accounts.encrypted_token fields if needed)
  - scripts/rotate-token-key.ts
  - apps/api/src/config/env.ts (.env.example: MASTER_KEY)
steps:
  - Add crypto helpers (seal/open) using libsodium
  - Wire into provider account persistence & retrieval

thinking
**Preparing to implement encryption at rest**
exec
bash -lc 'cat apps/api/src/lib/crypto/keystore.ts' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
cat: apps/api/src/lib/crypto/keystore.ts: No such file or directory

thinking
**Checking directory contents**
exec
bash -lc 'ls apps/api/src/lib' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
idempotency.ts
jobs
oauth
problem.ts

thinking
**Checking for keystore and crypto setup**
exec
bash -lc 'rg "provider_accounts" -n packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager exited 1 in 2.40s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking table naming in file**
exec
bash -lc 'head -n 200 packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 94ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// Prisma Client + Postgres
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ===================== Users & Accounts =====================

model User {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  name       String?
  created_at DateTime @default(now()) @db.Timestamptz


thinking
**Analyzing token encryption requirements**
exec
bash -lc 'rg "refresh_token" -n apps/api' in /var/home/rick/Development/playlist-manager exited 1 in 355ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Searching entire repo for implementation**
exec
bash -lc 'rg "Account" -g"*.ts" -n' in /var/home/rick/Development/playlist-manager exited 1 in 199ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking apps/api directory**
exec
bash -lc 'ls apps/api' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
public
src

thinking
**Inspecting the tree structure**
exec
bash -lc 'ls apps/api/src' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
config
dev
lib
plugins
routes
testServer.ts

thinking
**Checking configuration environment**
exec
bash -lc 'cat apps/api/src/config/env.ts' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
cat: apps/api/src/config/env.ts: No such file or directory

thinking
**Checking for TypeScript files**
exec
bash -lc 'ls apps/api/src/config' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
flags.ts

thinking
**Exploring project structure for crypto code**
exec
bash -lc "find . -maxdepth 4 -type f -path '*keystore.ts'" in /var/home/rick/Development/playlist-manager succeeded in 7.22s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Searching for account-related code**
exec
bash -lc 'rg "refreshToken" -n' in /var/home/rick/Development/playlist-manager succeeded in 4.69s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:178:bash -lc 'rg "refreshToken" -n' in /var/home/rick/Development/playlist-manager

thinking
**Inspecting packages directory**
exec
bash -lc 'ls packages' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
config
contracts
db
interop
providers
utils

thinking
**Inspecting provider code for encryption**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
core
deezer
spotify
tidal
youtube

thinking
**Inspecting core for token handling**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
http
index.ts
match
types.ts

thinking
**Checking for token and task log**
exec
bash -lc 'tail -n 40 codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log' in /var/home/rick/Development/playlist-manager succeeded in 94ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
thinking
**Inspecting packages directory**
exec
bash -lc 'ls packages' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
config
contracts
db
interop
providers
utils

thinking
**Inspecting provider code for encryption**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Assessing testing setup**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",

thinking
**Evaluating libsodium dependency and test setup**
exec
bash -lc 'rg "vitest" -n' in /var/home/rick/Development/playlist-manager succeeded in 66ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
pnpm-lock.yaml:57:      vitest:
pnpm-lock.yaml:802:  '@vitest/expect@4.0.7':
pnpm-lock.yaml:805:  '@vitest/mocker@4.0.7':
pnpm-lock.yaml:816:  '@vitest/pretty-format@4.0.7':
pnpm-lock.yaml:819:  '@vitest/runner@4.0.7':
pnpm-lock.yaml:822:  '@vitest/snapshot@4.0.7':
pnpm-lock.yaml:825:  '@vitest/spy@4.0.7':
pnpm-lock.yaml:828:  '@vitest/utils@4.0.7':
pnpm-lock.yaml:2933:  vitest@4.0.7:
pnpm-lock.yaml:2941:      '@vitest/browser-playwright': 4.0.7
pnpm-lock.yaml:2942:      '@vitest/browser-preview': 4.0.7
pnpm-lock.yaml:2943:      '@vitest/browser-webdriverio': 4.0.7
pnpm-lock.yaml:2944:      '@vitest/ui': 4.0.7
pnpm-lock.yaml:2954:      '@vitest/browser-playwright':
pnpm-lock.yaml:2956:      '@vitest/browser-preview':
pnpm-lock.yaml:2958:      '@vitest/browser-webdriverio':
pnpm-lock.yaml:2960:      '@vitest/ui':
pnpm-lock.yaml:3801:  '@vitest/expect@4.0.7':

thinking
**Searching for test files**
exec
bash -lc 'rg --files -g"*.test.ts"' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/code/codex/03a_dbpkg_singleton/tests/db.health.test.ts
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts
packages/db/test/healthcheck.cli.test.ts
packages/db/test/explain_scripts.test.ts
packages/db/test/indexes.test.ts
packages/db/test/seed.test.ts
apps/api/src/routes/__tests__/register-handlers.test.ts
packages/providers/core/test/mbidResolver.test.ts
apps/api/src/dev/__tests__/ensure-api-dev.test.ts

thinking
**Searching for Account-related code**
exec
bash -lc 'rg "Account" --iglob "*.ts" -n apps packages' in /var/home/rick/Development/playlist-manager exited 1 in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Examining database package usage**
exec
bash -lc 'ls packages/db/src' in /var/home/rick/Development/playlist-manager succeeded in 89ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
client.ts
encryption
healthcheck.ts
index.ts

thinking
**Listing encryption folder contents**
exec
bash -lc 'ls packages/db/src/encryption' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
crypto.ts
index.ts

thinking
**Inspecting existing encryption module**
exec
bash -lc 'cat packages/db/src/encryption/crypto.ts' in /var/home/rick/Development/playlist-manager succeeded in 69ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// Stub for packages/db/src/encryption/crypto.ts

thinking
**Checking existing database modules**
exec
bash -lc 'cat packages/db/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 73ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export { prisma } from './client';
export { dbHealthcheck } from './healthcheck';


thinking
**Opening client.ts file**
exec
bash -lc 'cat packages/db/src/client.ts' in /var/home/rick/Development/playlist-manager succeeded in 85ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;

thinking
**Checking encryption implementation status**
exec
bash -lc 'cat packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 70ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { describe, expect, test, vi } from 'vitest';
import type { DbHealthcheckResult } from '../src/healthcheck';

async function loadRunHealthcheck() {
  process.env.DATABASE_URL ??=
    'postgresql://placeholder:placeholder@localhost:5432/placeholder';
  const module = await import('../src/healthcheck');
  return module.runHealthcheck;
}

describe('runHealthcheck CLI helper', () => {
  test('exits with 0 and logs success when healthy', async () => {
    const runHealthcheck = await loadRunHealthcheck();
    const exit = vi.fn();
    const info = vi.fn();
    const error = vi.fn();

    await runHealthcheck({

thinking
**Planning encryption module testing and implementation**

I'm mapping out how to implement and test the new token encryption at rest feature, focusing on adding helper functions, updating the schema, and handling key rotation. I'll review existing repo tasks and code samples in `codex` and encryption logic in `packages/db` to align with the repo's style and structure before starting.
exec
bash -lc 'cat packages/db/src/encryption/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// Stub for packages/db/src/encryption/index.ts

thinking
**Preparing to explore encryption module**
exec
bash -lc 'cat packages/db/test/explain_scripts.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { readFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { describe, expect, test } from 'vitest';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const scriptsRoot = resolve(__dirname, '../../scripts/explain');
const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];

describe('EXPLAIN plans', () => {
  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
  });
});

thinking
**Preparing to add encryption tests**

I'm looking for existing encryption tests in the codex directory to guide me and planning to create new tests following TDD, likely in apps/api/src/lib/crypto/__tests__/keystore.test.ts. I also need to confirm usage and availability of libsodium-wrappers for encryption and figure out how to add it as a dependency given our constraints.
exec
bash -lc 'rg "libsodium"' in /var/home/rick/Development/playlist-manager succeeded in 311ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:title: Encrypt provider refresh tokens at rest (libsodium) + rotation
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:  Encrypt provider refresh/access tokens before persisting. Use libsodium sealed boxes with a
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:  - Add crypto helpers (seal/open) using libsodium
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:**Evaluating libsodium dependency and test setup**
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:I'm looking for existing encryption tests in the codex directory to guide me and planning to create new tests following TDD, likely in apps/api/src/lib/crypto/__tests__/keystore.test.ts. I also need to confirm usage and availability of libsodium-wrappers for encryption and figure out how to add it as a dependency given our constraints.
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:bash -lc 'rg "libsodium"' in /var/home/rick/Development/playlist-manager
codex/TASKS/03c_token_encryption_at_rest.yaml:title: Encrypt provider refresh tokens at rest (libsodium) + rotation
codex/TASKS/03c_token_encryption_at_rest.yaml:  Encrypt provider refresh/access tokens before persisting. Use libsodium sealed boxes with a
codex/TASKS/03c_token_encryption_at_rest.yaml:  - Add crypto helpers (seal/open) using libsodium

thinking
**Searching for libsodium in node_modules**
exec
bash -lc "find node_modules -maxdepth 1 -name '*sodium*'" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking deeper for libsodium library**
exec
bash -lc "find node_modules -maxdepth 2 -name '*sodium*'" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Evaluating libsodium availability**
exec
bash -lc 'rg "libsodium" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Investigating libsodium dependency options**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Reviewing sample test for style**
exec
bash -lc 'cat codex/code/codex/03a_dbpkg_singleton/tests/db.health.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { prisma, dbHealthcheck } from '../../../../../packages/db/src';
import { expect, test, vi } from 'vitest';

test('healthcheck ok', async () => {
  const querySpy = vi.spyOn(prisma, '$queryRaw').mockResolvedValueOnce(undefined as never);
  const h = await dbHealthcheck();
  expect(h).toEqual({ ok: true });
  expect(prisma).toBeTruthy();
  querySpy.mockRestore();
});

thinking
**Planning encryption module with libsodium**
exec
bash -lc 'rg "provider" apps/api/src -n' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
apps/api/src/config/flags.ts:7:  providers: {
apps/api/src/config/flags.ts:16:  return !!flags.providers[name];
apps/api/src/plugins/feature-guard.ts:9:      err.code = 'provider_disabled';
apps/api/src/routes/auth.providers.ts:5:  app.get('/auth/providers', async () => {
apps/api/src/routes/auth.providers.ts:6:    const data = Object.entries(flags.providers).map(([name, enabled]) => ({ name, enabled }));
apps/api/src/routes/_mockData.ts:6:  provider: string | null;
apps/api/src/routes/_mockData.ts:7:  provider_playlist_id: string | null;
apps/api/src/routes/_mockData.ts:22:  provider_track_id: string | null;
apps/api/src/routes/_mockData.ts:61:    provider: 'spotify',
apps/api/src/routes/_mockData.ts:62:    provider_playlist_id: '37i9dQZF1DX2Nc3B70tvx0',
apps/api/src/routes/_mockData.ts:68:    provider: 'deezer',
apps/api/src/routes/_mockData.ts:69:    provider_playlist_id: '987654321',
apps/api/src/routes/_mockData.ts:86:    provider_track_id: '3urbQpVxWn',
apps/api/src/routes/_mockData.ts:99:    provider_track_id: '9zYpqAbC12',
apps/api/src/routes/_mockData.ts:164:    provider_track_id: randomUUID().slice(0, 10),
apps/api/src/routes/jobs/migrate.post.ts:6:  source_provider: 'spotify' | 'deezer' | 'tidal' | 'youtube';
apps/api/src/routes/jobs/migrate.post.ts:8:  dest_provider: 'spotify' | 'deezer' | 'tidal' | 'youtube';
apps/api/src/routes/jobs/migrate.post.ts:14:  const providers = new Set(['spotify', 'deezer', 'tidal', 'youtube']);

thinking
**Evaluating crypto modules and tests**
exec
bash -lc 'ls scripts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
check-breaking.mjs
db
dev
explain
schemathesis.mjs
wait

thinking
**Preparing token rotation script**
exec
bash -lc 'ls scripts/db' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
down.ts
up.ts

thinking
**Inspecting configuration packages**
exec
bash -lc 'ls packages/config' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
env.client.ts
env.server.ts
index.ts

thinking
**Opening environment configuration file**
exec
bash -lc 'cat packages/config/env.server.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// Stub for packages/config/env.server.ts

thinking
**Analyzing repository stubs and planning encryption tests**

I’m noticing the repo is mostly stubs needing implementation, especially around encryption and token storage. I’ll plan by focusing on tests first, verifying `sealSecret` and `openSecret` using the `MASTER_KEY` env, then wiring encryption into DB operations for provider accounts, while searching for existing provider account code to extend or stub appropriately.
exec
bash -lc 'rg "provider_account" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:58:  - packages/db/prisma/schema.prisma (provider_accounts.encrypted_token fields if needed)
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:87:bash -lc 'rg "provider_accounts" -n packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager exited 1 in 2.40s:
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:574:bash -lc 'rg "provider_account" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/03c_token_encryption_at_rest.yaml:13:  - packages/db/prisma/schema.prisma (provider_accounts.encrypted_token fields if needed)

thinking
**Considering design and crypto implementation options**
exec
bash -lc 'rg "tweetnacl" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
  tweetnacl@0.14.5:
      tweetnacl: 0.14.5
      tweetnacl: 0.14.5
  tweetnacl@0.14.5: {}

thinking
**Verifying tweetnacl installation**
exec
bash -lc "test -d node_modules/.pnpm && find node_modules -maxdepth 3 -path '*tweetnacl*' | head" in /var/home/rick/Development/playlist-manager succeeded in 69ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
node_modules/.pnpm/tweetnacl@0.14.5
node_modules/.pnpm/tweetnacl@0.14.5/node_modules
node_modules/.pnpm/node_modules/tweetnacl

thinking
**Designing sealed box encryption with tweetnacl**

I’m planning how to implement sealed box encryption using `tweetnacl`, which lacks built-in sealed box support but offers primitives needed to mimic it. I’m outlining generating ephemeral keys, nonce handling, base64 encoding for storage, and how to derive key pairs from a master secret. I’m also considering where to place encryption code, how to update database schema to store encrypted tokens, and how to build robust, offline-compatible rotation scripts with thorough tests following TDD principles. This includes creating a new keystore module, handling missing or invalid keys gracefully, and managing ciphertext tampering scenarios. It feels like a comprehensive design balancing compatibility and security!
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 1.99s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: [
      'packages/**/test/**/*.test.ts',
      'packages/**/tests/**/*.test.ts',
      'apps/**/src/**/__tests__/**/*.test.ts',
      'codex/code/**/tests/**/*.test.ts',
    ],
    testTimeout: 30000,
  },
});

thinking
**Planning test placement and dependencies**

I’m figuring out where to put tests for the rotation script since `scripts` isn’t included in the test paths. Placing tests under `packages/db/test` and refactoring rotation logic into importable modules seems like a good approach. I also need to handle adding `tweetnacl` to dependencies properly for reliability, and look into updating `.env.example` with `MASTER_KEY`. This setup keeps testing clear and maintainable.
exec
bash -lc 'ls -a' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
.
..
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
.env
.env.example
env.json
.git
.github
.gitignore
node_modules
.npmrc

thinking
**Checking .env.example file**
exec
bash -lc 'cat .env.example' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
# Postgres (Prisma reads from DATABASE_URL)
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_dev?schema=public"

# Shadow DB for Prisma Migrate (recommended)
SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"

thinking
**Planning environment config implementation**
exec
bash -lc 'cat apps/api/src/config/flags.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export type ProviderFlagName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

const bool = (v: string | undefined, d = false) =>
  v ? ['1','true','yes','on'].includes(v.toLowerCase()) : d;

export const flags = {
  providers: {
    spotify: bool(process.env.PROVIDERS_SPOTIFY_ENABLED, true),
    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
    tidal:   bool(process.env.PROVIDERS_TIDAL_ENABLED, false),
    youtube: bool(process.env.PROVIDERS_YOUTUBE_ENABLED, false)
  }
};

export function isProviderEnabled(name: ProviderFlagName): boolean {
  return !!flags.providers[name];
}

thinking
**Planning encrypted token storage module**

I'm outlining how to add encrypted token storage functions for accounts, designing tests with mocked Prisma calls to confirm tokens are saved and retrieved securely without a real database. I'll create a new module in `packages/db/src/encryption` to handle this encryption layer and ensure consistent coding style.
exec
bash -lc 'ls node_modules/.pnpm | head' in /var/home/rick/Development/playlist-manager succeeded in 99ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
abort-controller@3.0.0
abstract-logging@2.0.1
accepts@1.3.8
agent-base@6.0.2
agent-base@7.1.4
agentkeepalive@4.6.0
ajv@6.12.3
ajv@6.12.6
ajv@8.17.1
ajv-draft-04@1.0.0_ajv@8.17.1

thinking
**Checking for Prisma client presence**
exec
bash -lc "find node_modules -maxdepth 3 -path '*prisma*' | head" in /var/home/rick/Development/playlist-manager succeeded in 106ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
node_modules/.pnpm/node_modules/@prisma
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
node_modules/.pnpm/prisma@5.22.0
node_modules/.pnpm/prisma@5.22.0/node_modules
node_modules/.pnpm/@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
node_modules/.pnpm/@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2/node_modules
node_modules/.pnpm/@prisma+debug@5.22.0
node_modules/.pnpm/@prisma+debug@5.22.0/node_modules
node_modules/.pnpm/@prisma+engines@5.22.0

thinking
**Designing token encryption integration**
Plan update
  → Add failing unit tests covering token encryption helpers and rotation behavior

thinking
**Updating plan with multiple steps**
Plan update
  → Add failing unit tests covering token encryption helpers and rotation behavior
  • Implement keystore, encryption utilities, schema updates, and rotation script
  • Document MASTER_KEY usage and rotation runbook; ensure tests pass

thinking
**Designing keystore tests and API**
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/lib/crypto/__tests__/keystore.test.ts
import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import { randomBytes } from 'node:crypto';
import {
  createKeystore,
  getSealedSecretKeyId,
  KeystoreError,
} from '../keystore';

const ORIGINAL_ENV = { ...process.env };

afterEach(() => {
  process.env = { ...ORIGINAL_ENV };
});

const makeMasterKey = () => randomBytes(32).toString('base64');

describe('createKeystore', () => {
  let masterKey: string;

  beforeEach(() => {
    masterKey = makeMasterKey();
    process.env.MASTER_KEY = masterKey;
  });

  it('seals and opens secrets with the same master key', () => {
    const keystore = createKeystore();
    const secret = 'refresh-token-123';

    const sealed = keystore.seal(secret);
    expect(sealed).not.toContain(secret);
    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);

    const opened = keystore.open(sealed);
    expect(opened).toBe(secret);
  });

  it('throws when MASTER_KEY is missing', () => {
    delete process.env.MASTER_KEY;
    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
  });

  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
    process.env.MASTER_KEY = 'invalid';
    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
  });

  it('fails to open with a different master key', () => {
    const keystore = createKeystore();
    const sealed = keystore.seal('sensitive');

    process.env.MASTER_KEY = makeMasterKey();
    const other = createKeystore();

    expect(() => other.open(sealed)).toThrow(KeystoreError);
  });

  it('detects tampering and throws', () => {
    const keystore = createKeystore();
    const sealed = keystore.seal('keep-me-safe');
    const tampered = sealed.replace(/.$/, (c) =>
      c === 'A' ? 'B' : 'A',
    );

    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
  });
});
apply_patch(auto_approved=true) exited 0 in 56ms:
Success. Updated the following files:
A apps/api/src/lib/crypto/__tests__/keystore.test.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});


thinking
**Planning token rotation implementation and tests**

I'm mapping out how to implement token rotation in the encryption module with keystore support, ensuring idempotency and proper token resealing from old to new keys. I'll design rotation functions and tests under `packages/db`, navigate import paths carefully to avoid duplication, and draft a comprehensive test file to verify rotation behavior and encryption correctness.
file update
A /var/home/rick/Development/playlist-manager/packages/db/test/token-rotation.test.ts
import { describe, expect, it } from 'vitest';
import {
  createKeystore,
  decryptProviderTokens,
  encryptProviderTokens,
  rotateProviderAccountTokens,
} from '../src/encryption';

const makeKey = () => Buffer.from(crypto.getRandomValues(new Uint8Array(32))).toString('base64');

describe('provider token rotation', () => {
  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
    const oldKey = createKeystore({ masterKey: makeKey() });
    const newKey = createKeystore({ masterKey: makeKey() });

    const accountA = encryptProviderTokens(
      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
      oldKey,
    );

    const accountB = encryptProviderTokens(
      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
      newKey,
    );

    const accountC = {
      accountId: 3,
      access_token: null,
      refresh_token: null,
    };

    const rotated = rotateProviderAccountTokens(
      [accountA, accountB, accountC],
      oldKey,
      newKey,
    );

    expect(rotated.updatedIds).toEqual([1]);

    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
    expect(decryptedA).toEqual({
      accountId: 1,
      accessToken: 'acc-A',
      refreshToken: 'ref-A',
    });

    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
    expect(decryptedB).toEqual({
      accountId: 2,
      accessToken: 'acc-B',
      refreshToken: 'ref-B',
    });
  });

  it('is idempotent when run multiple times', () => {
    const oldKey = createKeystore({ masterKey: makeKey() });
    const newKey = createKeystore({ masterKey: makeKey() });

    const initial = [
      encryptProviderTokens(
        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
        oldKey,
      ),
    ];

    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);

    expect(firstPass.updatedIds).toEqual([42]);
    expect(secondPass.updatedIds).toEqual([]);

    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
    expect(decrypted).toEqual({
      accountId: 42,
      accessToken: 'foo',
      refreshToken: 'bar',
    });
  });
});
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A packages/db/test/token-rotation.test.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a385e0e462e1d95caa963fb2db3d3fcbb332a722
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,79 @@
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => Buffer.from(crypto.getRandomValues(new Uint8Array(32))).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: null,
+      refresh_token: null,
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a385e0e462e1d95caa963fb2db3d3fcbb332a722
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,79 @@
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => Buffer.from(crypto.getRandomValues(new Uint8Array(32))).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: null,
+      refresh_token: null,
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Switching to Node randomBytes**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/token-rotation.test.ts
@@ -1 +1,2 @@
+import { randomBytes } from 'node:crypto';
 import { describe, expect, it } from 'vitest';
@@ -8,3 +9,3 @@
 
-const makeKey = () => Buffer.from(crypto.getRandomValues(new Uint8Array(32))).toString('base64');
+const makeKey = () => randomBytes(32).toString('base64');
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M packages/db/test/token-rotation.test.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ea0f63cc5df6e20dbfc0e0c8724d8fe5c1b68ef
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,80 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: null,
+      refresh_token: null,
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ea0f63cc5df6e20dbfc0e0c8724d8fe5c1b68ef
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,80 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: null,
+      refresh_token: null,
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Finalizing test setup and exports**
Plan update
  ✓ Add failing unit tests covering token encryption helpers and rotation behavior
  → Implement keystore, encryption utilities, schema updates, and rotation script
  • Document MASTER_KEY usage and rotation runbook; ensure tests pass
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ea0f63cc5df6e20dbfc0e0c8724d8fe5c1b68ef
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,80 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: null,
+      refresh_token: null,
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Implementing keystore and encryption modules**

I'm mapping out how to build the keystore logic mainly inside the database encryption package for shared use, with the API module re-exporting key parts to keep tests green. I’m focusing on creating secure sealing and opening methods using `tweetnacl`, careful payload formatting, and error handling. Alongside, I plan to implement token encryption helpers, including encryption, decryption, and rotation functions that correctly handle sealed, plaintext, or null tokens, making sure rotation upgrades legacy plaintext tokens too. I’m considering test updates to cover these cases and ensure smooth integration.
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/token-rotation.test.ts
@@ -28,4 +28,4 @@
       accountId: 3,
-      access_token: null,
-      refresh_token: null,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
     };
@@ -38,3 +38,3 @@
 
-    expect(rotated.updatedIds).toEqual([1]);
+    expect(rotated.updatedIds).toEqual([1, 3]);
 
@@ -53,2 +53,9 @@
     });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
   });
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M packages/db/test/token-rotation.test.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Implementing keystore and token rotation modules**

I'm preparing to build the keystore cryptography module with careful handling of sealed token formats and key derivation, then implement token encryption, decryption, and rotation functions that maintain token ordering and handle edge cases like unknown keys or plaintexts. Next, I'll update the crypto.ts file with full TypeScript implementations and support the token rotation script.
file update
M /var/home/rick/Development/playlist-manager/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/db/src/encryption/crypto.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Implementing token encryption and rotation functions**

I’m focusing on completing the encryption module by implementing `encryptProviderTokens`, `decryptProviderTokens`, and `rotateProviderAccountTokens` with careful handling of sealed versus plaintext tokens for compatibility. I’m planning to define types, handle `null` vs `undefined`, and ensure proper rotation logic with error checks for key mismatches while relying on the existing keystore and crypto utilities.
file update
M /var/home/rick/Development/playlist-manager/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/db/src/encryption/index.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Reviewing token normalization and import paths**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 98ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Deciding on import and re-export strategy**
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/lib/crypto/keystore.ts
export {
  createKeystore,
  getSealedSecretKeyId,
  isSealedSecret,
  KeystoreError,
  type CreateKeystoreOptions,
  type Keystore,
} from '../../../../packages/db/src/encryption/crypto';
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A apps/api/src/lib/crypto/keystore.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Planning schema and rotation updates**

I’m figuring out how to update the Prisma schema to rename token fields for encrypted storage, balancing clarity and compatibility. I’m also setting up to create a rotation script, ensuring helper functions are in place before implementation.
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/schema.prisma
@@ -28,10 +28,10 @@
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  access_token_ciphertext  String?
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/prisma/schema.prisma
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..79543a32080df3439555ccb61493257d7943e938
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,14 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  access_token_ciphertext  String?
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..79543a32080df3439555ccb61493257d7943e938
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,14 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  access_token_ciphertext  String?
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Adding documentation comments**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/schema.prisma
@@ -32,3 +32,5 @@
   provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
   access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
   refresh_token_ciphertext String?
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/prisma/schema.prisma
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..12483196cdaa7c76782dd2a8f5141686ad118cfd
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token: string | null;
+  refresh_token: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token),
+    refreshToken: decode(record.refresh_token),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token: rotateValue(record.access_token),
+      refresh_token: rotateValue(record.refresh_token),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Updating field names in encryption code**
file update
M /var/home/rick/Development/playlist-manager/packages/db/src/encryption/index.ts
@@ -27,4 +27,4 @@
   accountId: number;
-  access_token: string | null;
-  refresh_token: string | null;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
 }
@@ -48,4 +48,4 @@
     accountId: data.accountId,
-    access_token: accessToken ? keystore.seal(accessToken) : null,
-    refresh_token: refreshToken ? keystore.seal(refreshToken) : null,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
   };
@@ -71,4 +71,4 @@
     accountId: record.accountId,
-    accessToken: decode(record.access_token),
-    refreshToken: decode(record.refresh_token),
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
   };
@@ -118,4 +118,4 @@
       accountId: record.accountId,
-      access_token: rotateValue(record.access_token),
-      refresh_token: rotateValue(record.refresh_token),
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
     };
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/src/encryption/index.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b0db9053266928565a3dff67e8e9753e3b5a86fa
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token: 'legacy-access',
+      refresh_token: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Updating test file for renamed properties**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/token-rotation.test.ts
@@ -28,4 +28,4 @@
       accountId: 3,
-      access_token: 'legacy-access',
-      refresh_token: 'legacy-refresh',
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
     };
@@ -40,3 +40,3 @@
 
-    const decryptedA = decryptProviderTokens(rotated.records[0], newKey);
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
     expect(decryptedA).toEqual({
@@ -47,3 +47,3 @@
 
-    const decryptedB = decryptProviderTokens(rotated.records[1], newKey);
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
     expect(decryptedB).toEqual({
@@ -54,3 +54,3 @@
 
-    const decryptedC = decryptProviderTokens(rotated.records[2], newKey);
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
     expect(decryptedC).toEqual({
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/test/token-rotation.test.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});


thinking
**Designing token rotation script and adjusting tests**

I’m making sure the rotation logic properly handles plaintext and encrypted tokens, updates tests for new property names and array handling, and planning a CLI script to rotate tokens between master keys using environment variables and Prisma for database updates. The script will support dry-run mode and carefully log its actions while ensuring safe key usage.
file update
A /var/home/rick/Development/playlist-manager/scripts/rotate-token-key.ts
#!/usr/bin/env tsx
import { exit } from 'node:process';

import { prisma } from '../packages/db/src/client';
import {
  createKeystore,
  rotateProviderAccountTokens,
  type ProviderTokenRecord,
} from '../packages/db/src/encryption';

interface CliOptions {
  dryRun: boolean;
}

const parseOptions = (): CliOptions => ({
  dryRun: process.argv.includes('--dry-run'),
});

async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
  const rows = await prisma.account.findMany({
    select: {
      id: true,
      access_token_ciphertext: true,
      refresh_token_ciphertext: true,
    },
  });

  return rows.map((row) => ({
    accountId: row.id,
    access_token_ciphertext: row.access_token_ciphertext,
    refresh_token_ciphertext: row.refresh_token_ciphertext,
  }));
}

async function persistUpdates(
  records: ProviderTokenRecord[],
  updatedIds: number[],
  dryRun: boolean,
): Promise<void> {
  if (updatedIds.length === 0) {
    return;
  }

  const updating = new Set(updatedIds);

  for (const record of records) {
    if (!updating.has(record.accountId)) {
      continue;
    }

    if (dryRun) {
      continue;
    }

    await prisma.account.update({
      where: { id: record.accountId },
      data: {
        access_token_ciphertext: record.access_token_ciphertext,
        refresh_token_ciphertext: record.refresh_token_ciphertext,
      },
    });
  }
}

async function main() {
  const options = parseOptions();
  const previousKey = process.env.MASTER_KEY_PREVIOUS;
  const nextKey = process.env.MASTER_KEY;

  if (!previousKey || !nextKey) {
    console.error(
      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
    );
    exit(1);
  }

  const source = createKeystore({ masterKey: previousKey });
  const target = createKeystore({ masterKey: nextKey });

  const records = await fetchAccountTokens();
  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
    records,
    source,
    target,
  );

  await persistUpdates(rotated, updatedIds, options.dryRun);

  const action = options.dryRun ? 'would update' : 'updated';
  console.log(
    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
  );
}

main()
  .catch((err) => {
    console.error('[rotate-token-key] failed', err);
    exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
A scripts/rotate-token-key.ts
file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Reviewing token rotation script and tests**

I’m verifying that the TypeScript script’s imports and relative paths are correct, making sure encryption functions handle new sealed token formats properly, and checking that tests reflect updated property names without breaking order assumptions. I’m also confirming key encoding with base64url and that the prisma client aligns with schema changes. Lastly, I note the need to update environment examples and documentation soon.
file update
M /var/home/rick/Development/playlist-manager/.env.example
@@ -5 +5,4 @@
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M .env.example
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Planning environment config update**
file update
A /var/home/rick/Development/playlist-manager/apps/api/src/config/env.ts
import { z } from 'zod';

const EnvSchema = z.object({
  MASTER_KEY: z
    .string({
      required_error: 'MASTER_KEY env var is required',
    })
    .min(1),
});

export const env = EnvSchema.parse({
  MASTER_KEY: process.env.MASTER_KEY,
});
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
A apps/api/src/config/env.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Checking zod usage and planning README update**
exec
bash -lc 'cat README.md' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
# playlist-manager

## Spec workflow

We treat `openapi.yaml` as the source of truth for the service contract. Run these commands
before proposing spec changes:

1. `pnpm lint:api` – validates the OpenAPI 3.1 document with Redocly.
2. `pnpm gen:types` – regenerates `packages/contracts/src/api.types.ts`; rerunning the command
   should yield no diff when the spec and generated file are in sync.
3. `pnpm check:breaking` – compares the working tree spec against `HEAD:openapi.yaml` with
   Optic. The command exits non-zero when it detects a breaking change so you can spot
   incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).

## Database seeding

With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Adding token encryption section**
file update
M /var/home/rick/Development/playlist-manager/README.md
@@ -21 +21,21 @@
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M README.md
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Updating dependencies with tweetnacl**
file update
M /var/home/rick/Development/playlist-manager/package.json
@@ -51,2 +51,3 @@
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M package.json
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Preparing manual lockfile update**
exec
bash -lc 'rg "importers": -n pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
7:importers:
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Reviewing root importer area**
exec
bash -lc "sed -n '7,80p' pnpm-lock.yaml" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
importers:

  .:
    dependencies:
      '@app/interop':
        specifier: workspace:*
        version: link:packages/interop
      '@fastify/static':
        specifier: ^8.3.0
        version: 8.3.0
      fastify:
        specifier: ^5.6.1
        version: 5.6.1
      fastify-plugin:
        specifier: ^5.1.0
        version: 5.1.0
      nanoid:
        specifier: ^5.1.6
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Adding tweetnacl dependency**
file update
M /var/home/rick/Development/playlist-manager/pnpm-lock.yaml
@@ -34,2 +34,5 @@
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M pnpm-lock.yaml
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Verifying package dependency presence**
exec
bash -lc 'rg "tweetnacl@0.14.5" -n pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
2781:  tweetnacl@0.14.5:
5919:  tweetnacl@0.14.5: {}
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Verifying implementation and test readiness**

I'm making sure all implementation steps are complete before marking Step 2 finished. I’m double-checking TypeScript imports and exports for correctness, ensuring dependencies like `tweetnacl` and `zod` are properly included, and planning to run targeted tests with `vitest` to confirm everything works as expected before updating the plan and moving on to Step 3.
exec
bash -lc 'pnpm vitest run apps/api/src/lib/crypto/__tests__/keystore.test.ts packages/db/test/token-rotation.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 19.68s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Errors [49m[22m[31m⎯⎯⎯⎯⎯⎯[39m
[31m[1m
Vitest caught 2 unhandled errors during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.[22m[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Error [49m[22m[31m⎯⎯⎯⎯⎯⎯⎯[39m
[31m[1mError[22m: [vitest-pool]: Worker forks emitted error.[39m
[90m [2m❯[22m EventEmitter.<anonymous> node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6870:22[22m[39m
[90m [2m❯[22m EventEmitter.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6520:22[22m[39m
[90m [2m❯[22m ChildProcess.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m Process.ChildProcess._handle.onexit node:internal/child_process:[2m293:12[22m[39m

[31m[1mCaused by: Error[22m: Worker exited unexpectedly[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6519:33[22m[39m
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Troubleshooting Vitest test discovery**
exec
bash -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager succeeded in 11.70s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Updating plan after successful tests**
Plan update
  ✓ Add failing unit tests covering token encryption helpers and rotation behavior
  ✓ Implement keystore, encryption utilities, schema updates, and rotation script
  ✓ Document MASTER_KEY usage and rotation runbook; ensure tests pass
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Preparing git diff and status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 7]
 M .env.example
 M README.md
 M package.json
 M packages/db/prisma/schema.prisma
 M packages/db/src/encryption/crypto.ts
 M packages/db/src/encryption/index.ts
 M pnpm-lock.yaml
?? apps/api/src/config/env.ts
?? apps/api/src/lib/crypto/
?? codex.toml
?? codex/LOGS/codex_run_2025-11-05_20-47-49.log
?? codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log
?? codex/TASKS/work_list
?? packages/db/test/token-rotation.test.ts
?? scripts/rotate-token-key.ts
?? test_codex_path.txt
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Investigating untracked crypto directory**
exec
bash -lc 'ls apps/api/src/lib' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
crypto
idempotency.ts
jobs
oauth
problem.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Reviewing new crypto directory and preparing diffs**
exec
bash -lc "nl -ba packages/db/src/encryption/crypto.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 92ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	// Stub for packages/db/src/encryption/crypto.ts
     2	import { createHash, randomBytes } from 'node:crypto';
     3	import nacl from 'tweetnacl';
     4	
     5	export class KeystoreError extends Error {
     6	  constructor(message: string) {
     7	    super(message);
     8	    this.name = 'KeystoreError';
     9	  }
    10	}
    11	
    12	export interface Keystore {
    13	  readonly keyId: string;
    14	  seal(plaintext: string): string;
    15	  open(sealed: string): string;
    16	}
    17	
    18	export interface CreateKeystoreOptions {
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..1da814ec314994852c7d6b022d6fc13dbcb2b715
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,183 @@
 // Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Removing leftover stub comment**
file update
M /var/home/rick/Development/playlist-manager/packages/db/src/encryption/crypto.ts
@@ -1,2 +1 @@
-// Stub for packages/db/src/encryption/crypto.ts
 import { createHash, randomBytes } from 'node:crypto';
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M packages/db/src/encryption/crypto.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Adjusting line numbers after removal**
exec
bash -lc "nl -ba packages/db/src/encryption/index.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	// Stub for packages/db/src/encryption/index.ts
     2	import {
     3	  CreateKeystoreOptions,
     4	  Keystore,
     5	  KeystoreError,
     6	  createKeystore,
     7	  getSealedSecretKeyId,
     8	  isSealedSecret,
     9	} from './crypto';
    10	
    11	export {
    12	  createKeystore,
    13	  getSealedSecretKeyId,
    14	  isSealedSecret,
    15	  KeystoreError,
    16	};
    17	
    18	export type { CreateKeystoreOptions, Keystore };
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..1b5981402731eb44ffb9279f7ea1ddbc7a23b3b9
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,131 @@
 // Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Cleaning up stub comment**
file update
M /var/home/rick/Development/playlist-manager/packages/db/src/encryption/index.ts
@@ -1,2 +1 @@
-// Stub for packages/db/src/encryption/index.ts
 import {
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M packages/db/src/encryption/index.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Tracking new test file additions**
exec
bash -lc 'nl -ba apps/api/src/lib/crypto/__tests__/keystore.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { afterEach, beforeEach, describe, expect, it } from 'vitest';
     2	import { randomBytes } from 'node:crypto';
     3	import {
     4	  createKeystore,
     5	  getSealedSecretKeyId,
     6	  KeystoreError,
     7	} from '../keystore';
     8	
     9	const ORIGINAL_ENV = { ...process.env };
    10	
    11	afterEach(() => {
    12	  process.env = { ...ORIGINAL_ENV };
    13	});
    14	
    15	const makeMasterKey = () => randomBytes(32).toString('base64');
    16	
    17	describe('createKeystore', () => {
    18	  let masterKey: string;
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Checking randomBytes import usage**
exec
bash -lc 'nl -ba apps/api/src/lib/crypto/keystore.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	export {
     2	  createKeystore,
     3	  getSealedSecretKeyId,
     4	  isSealedSecret,
     5	  KeystoreError,
     6	  type CreateKeystoreOptions,
     7	  type Keystore,
     8	} from '../../../../packages/db/src/encryption/crypto';
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Evaluating re-export paths**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/lib/crypto/keystore.ts
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M apps/api/src/lib/crypto/keystore.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f7ddc5d89cce396c963b8fdb562917c7f54e8881
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption/crypto';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Correcting patch application**
file update
M /var/home/rick/Development/playlist-manager/apps/api/src/lib/crypto/keystore.ts
@@ -7,2 +7,2 @@
   type Keystore,
-} from '../../../../packages/db/src/encryption/crypto';
+} from '../../../../packages/db/src/encryption';
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M apps/api/src/lib/crypto/keystore.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Verifying TypeScript re-exports**
exec
bash -lc 'nl -ba apps/api/src/config/env.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { z } from 'zod';
     2	
     3	const EnvSchema = z.object({
     4	  MASTER_KEY: z
     5	    .string({
     6	      required_error: 'MASTER_KEY env var is required',
     7	    })
     8	    .min(1),
     9	});
    10	
    11	export const env = EnvSchema.parse({
    12	  MASTER_KEY: process.env.MASTER_KEY,
    13	});
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Adding line numbers for rotation tests**
exec
bash -lc 'nl -ba packages/db/test/token-rotation.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { randomBytes } from 'node:crypto';
     2	import { describe, expect, it } from 'vitest';
     3	import {
     4	  createKeystore,
     5	  decryptProviderTokens,
     6	  encryptProviderTokens,
     7	  rotateProviderAccountTokens,
     8	} from '../src/encryption';
     9	
    10	const makeKey = () => randomBytes(32).toString('base64');
    11	
    12	describe('provider token rotation', () => {
    13	  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
    14	    const oldKey = createKeystore({ masterKey: makeKey() });
    15	    const newKey = createKeystore({ masterKey: makeKey() });
    16	
    17	    const accountA = encryptProviderTokens(
    18	      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9a4d6d13a06d74ce40138c139c5740de5277e
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,87 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Improving code readability by wrapping long lines**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/token-rotation.test.ts
@@ -40,3 +40,6 @@
 
-    const decryptedA = decryptProviderTokens(rotated.records.find((r) => r.accountId === 1)!, newKey);
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
     expect(decryptedA).toEqual({
@@ -47,3 +50,6 @@
 
-    const decryptedB = decryptProviderTokens(rotated.records.find((r) => r.accountId === 2)!, newKey);
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
     expect(decryptedB).toEqual({
@@ -54,3 +60,6 @@
 
-    const decryptedC = decryptProviderTokens(rotated.records.find((r) => r.accountId === 3)!, newKey);
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
     expect(decryptedC).toEqual({
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M packages/db/test/token-rotation.test.ts
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Cleaning up test comments and verifying line numbers**
exec
bash -lc "nl -ba packages/db/src/encryption/crypto.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { createHash, randomBytes } from 'node:crypto';
     2	import nacl from 'tweetnacl';
     3	
     4	export class KeystoreError extends Error {
     5	  constructor(message: string) {
     6	    super(message);
     7	    this.name = 'KeystoreError';
     8	  }
     9	}
    10	
    11	export interface Keystore {
    12	  readonly keyId: string;
    13	  seal(plaintext: string): string;
    14	  open(sealed: string): string;
    15	}
    16	
    17	export interface CreateKeystoreOptions {
    18	  /**
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Identifying key lines for summary**
exec
bash -lc 'nl -ba scripts/rotate-token-key.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	#!/usr/bin/env tsx
     2	import { exit } from 'node:process';
     3	
     4	import { prisma } from '../packages/db/src/client';
     5	import {
     6	  createKeystore,
     7	  rotateProviderAccountTokens,
     8	  type ProviderTokenRecord,
     9	} from '../packages/db/src/encryption';
    10	
    11	interface CliOptions {
    12	  dryRun: boolean;
    13	}
    14	
    15	const parseOptions = (): CliOptions => ({
    16	  dryRun: process.argv.includes('--dry-run'),
    17	});
    18	
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Noting schema.prisma changes**
exec
bash -lc "nl -ba packages/db/prisma/schema.prisma | sed -n '1,160p'" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	// Prisma Client + Postgres
     2	datasource db {
     3	  provider = "postgresql"
     4	  url      = env("DATABASE_URL")
     5	}
     6	
     7	generator client {
     8	  provider = "prisma-client-js"
     9	}
    10	
    11	// ===================== Users & Accounts =====================
    12	
    13	model User {
    14	  id         Int      @id @default(autoincrement())
    15	  email      String   @unique
    16	  name       String?
    17	  created_at DateTime @default(now()) @db.Timestamptz
    18	
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Noting lines for new columns and env references**
exec
bash -lc 'nl -ba .env.example' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	# Postgres (Prisma reads from DATABASE_URL)
     2	DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_dev?schema=public"
     3	
     4	# Shadow DB for Prisma Migrate (recommended)
     5	SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
     6	
     7	# libsodium sealed secret (base64 32 byte seed)
     8	MASTER_KEY="replace-with-base64-secret"
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Checking README section line numbers**
exec
bash -lc "nl -ba README.md | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	# playlist-manager
     2	
     3	## Spec workflow
     4	
     5	We treat `openapi.yaml` as the source of truth for the service contract. Run these commands
     6	before proposing spec changes:
     7	
     8	1. `pnpm lint:api` – validates the OpenAPI 3.1 document with Redocly.
     9	2. `pnpm gen:types` – regenerates `packages/contracts/src/api.types.ts`; rerunning the command
    10	   should yield no diff when the spec and generated file are in sync.
    11	3. `pnpm check:breaking` – compares the working tree spec against `HEAD:openapi.yaml` with
    12	   Optic. The command exits non-zero when it detects a breaking change so you can spot
    13	   incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
    14	
    15	## Database seeding
    16	
    17	With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
    18	fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Noting reference details**
exec
bash -lc "nl -ba package.json | sed -n '1,160p'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	{
     2	  "name": "playlist-manager",
     3	  "private": true,
     4	  "version": "0.1.0",
     5	  "type": "module",
     6	  "packageManager": "pnpm@9.12.3",
     7	  "engines": {
     8	    "node": ">=18.18"
     9	  },
    10	  "workspaces": [
    11	    "apps/*",
    12	    "packages/*"
    13	  ],
    14	  "scripts": {
    15	    "lint:api": "redocly lint openapi.yaml --extends recommended",
    16	    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    17	    "mock:api": "prism mock openapi.yaml",
    18	    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });


thinking
**Preparing detailed final summary**
codex
Encrypted provider tokens using sealed boxes and added rotation support.

**Highlights**
- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).
- Added helpers to encrypt/decrypt provider tokens and perform idempotent rotations based on key IDs (`packages/db/src/encryption/index.ts:40`, `packages/db/src/encryption/index.ts:77`).
- Updated Prisma Account model to persist ciphertext columns annotated for sealed secrets (`packages/db/prisma/schema.prisma:29`).
- Captured unit tests for keystore behavior and rotation scenarios, including plaintext upgrade coverage (`apps/api/src/lib/crypto/__tests__/keystore.test.ts:17`, `packages/db/test/token-rotation.test.ts:12`).
- Shipped a CLI rotation script with dry-run support and env contract (`scripts/rotate-token-key.ts:15`, `scripts/rotate-token-key.ts:65`), documented runbook and env sample updates (`README.md:23`, `.env.example:7`), and added the `tweetnacl` dependency (`package.json:44`).

**Tests**
- `pnpm vitest run`

**Next Steps**
1. Generate a fresh base64 `MASTER_KEY`, set `MASTER_KEY_PREVIOUS` during rotation, and execute `pnpm tsx scripts/rotate-token-key.ts` after seeding real data.
file update:
diff --git a/.env.example b/.env.example
index f33718003611154c4518b97d88ec2613656c447a..2666bc73a0ddbaf553d0b710b4cac94df53278aa
--- a/.env.example
+++ b/.env.example
@@ -3,3 +3,6 @@
 
 # Shadow DB for Prisma Migrate (recommended)
 SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
+
+# libsodium sealed secret (base64 32 byte seed)
+MASTER_KEY="replace-with-base64-secret"
diff --git a/README.md b/README.md
index 499cfad6f9ff4a124815222dcbf6120aaf6e7b35..26b15ccc403fd0d11e615e4a4066ec592e8bc035
--- a/README.md
+++ b/README.md
@@ -19,3 +19,23 @@
 transaction so you can safely run it multiple times; it always upserts the demo user, two
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
 contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
+
+## Token encryption
+
+Provider access and refresh tokens are sealed with libsodium (TweetNaCl) before hitting the
+database. Generate a master key once per environment and store it as a 32 byte base64 string:
+
+```
+openssl rand -base64 32
+```
+
+Set the value in `.env` as `MASTER_KEY`. Prisma persists ciphertext in the `*_token_ciphertext`
+columns, all prefixed with `pmse-v1.<keyId>.<payload>`. To rotate keys without downtime:
+
+1. Export the new key as `MASTER_KEY` and the previous key as `MASTER_KEY_PREVIOUS`.
+2. Run a dry-run to inspect how many rows will be touched:
+   ```
+   pnpm tsx scripts/rotate-token-key.ts --dry-run
+   ```
+3. Re-run without `--dry-run` to apply the rotation; the script is idempotent and skips rows
+   already sealed with the new key.
diff --git a/apps/api/src/config/env.ts b/apps/api/src/config/env.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d5d4badaa727f3b914daf0677ff6f81f90a32
--- /dev/null
+++ b/apps/api/src/config/env.ts
@@ -0,0 +1,13 @@
+import { z } from 'zod';
+
+const EnvSchema = z.object({
+  MASTER_KEY: z
+    .string({
+      required_error: 'MASTER_KEY env var is required',
+    })
+    .min(1),
+});
+
+export const env = EnvSchema.parse({
+  MASTER_KEY: process.env.MASTER_KEY,
+});
diff --git a/apps/api/src/lib/crypto/__tests__/keystore.test.ts b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..52025c98bc76770fb66298f4b5d64b89a1d9ee0a
--- /dev/null
+++ b/apps/api/src/lib/crypto/__tests__/keystore.test.ts
@@ -0,0 +1,66 @@
+import { afterEach, beforeEach, describe, expect, it } from 'vitest';
+import { randomBytes } from 'node:crypto';
+import {
+  createKeystore,
+  getSealedSecretKeyId,
+  KeystoreError,
+} from '../keystore';
+
+const ORIGINAL_ENV = { ...process.env };
+
+afterEach(() => {
+  process.env = { ...ORIGINAL_ENV };
+});
+
+const makeMasterKey = () => randomBytes(32).toString('base64');
+
+describe('createKeystore', () => {
+  let masterKey: string;
+
+  beforeEach(() => {
+    masterKey = makeMasterKey();
+    process.env.MASTER_KEY = masterKey;
+  });
+
+  it('seals and opens secrets with the same master key', () => {
+    const keystore = createKeystore();
+    const secret = 'refresh-token-123';
+
+    const sealed = keystore.seal(secret);
+    expect(sealed).not.toContain(secret);
+    expect(getSealedSecretKeyId(sealed)).toBe(keystore.keyId);
+
+    const opened = keystore.open(sealed);
+    expect(opened).toBe(secret);
+  });
+
+  it('throws when MASTER_KEY is missing', () => {
+    delete process.env.MASTER_KEY;
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('throws when MASTER_KEY is not 32 bytes of base64', () => {
+    process.env.MASTER_KEY = 'invalid';
+    expect(() => createKeystore()).toThrow(/MASTER_KEY/i);
+  });
+
+  it('fails to open with a different master key', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('sensitive');
+
+    process.env.MASTER_KEY = makeMasterKey();
+    const other = createKeystore();
+
+    expect(() => other.open(sealed)).toThrow(KeystoreError);
+  });
+
+  it('detects tampering and throws', () => {
+    const keystore = createKeystore();
+    const sealed = keystore.seal('keep-me-safe');
+    const tampered = sealed.replace(/.$/, (c) =>
+      c === 'A' ? 'B' : 'A',
+    );
+
+    expect(() => keystore.open(tampered)).toThrow(KeystoreError);
+  });
+});
diff --git a/apps/api/src/lib/crypto/keystore.ts b/apps/api/src/lib/crypto/keystore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5307c6073883f6e22a0b352d6700d60c044a1ef8
--- /dev/null
+++ b/apps/api/src/lib/crypto/keystore.ts
@@ -0,0 +1,8 @@
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+  type CreateKeystoreOptions,
+  type Keystore,
+} from '../../../../packages/db/src/encryption';
diff --git a/package.json b/package.json
index d007f5f0b89e7a489065361edef6c2e9ebc4a8a0..7dd4642208f837a221c9181e3c344e437a21f654
--- a/package.json
+++ b/package.json
@@ -49,6 +49,7 @@
     "pino": "^10.1.0",
     "prisma": "^5.22.0",
     "prom-client": "^15.1.3",
+    "tweetnacl": "^0.14.5",
     "zod": "^4.1.12"
   }
 }
diff --git a/packages/db/prisma/schema.prisma b/packages/db/prisma/schema.prisma
index ff44d7695c0bb2b3272eaedb37fc4114778f6d80..a063c2509f63e4d0e5c3c5238156572f1763bd9f
--- a/packages/db/prisma/schema.prisma
+++ b/packages/db/prisma/schema.prisma
@@ -26,14 +26,16 @@
 }
 
 model Account {
-  id               Int       @id @default(autoincrement())
-  user_id          Int
-  provider         String
-  provider_user_id String
-  access_token     String?
-  refresh_token    String?
-  expires_at       DateTime? @db.Timestamptz
-  created_at       DateTime  @default(now()) @db.Timestamptz
+  id                       Int       @id @default(autoincrement())
+  user_id                  Int
+  provider                 String
+  provider_user_id         String
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  access_token_ciphertext  String?
+  /// libsodium sealed secret (`pmse-v1.<keyId>.<payload>`)
+  refresh_token_ciphertext String?
+  expires_at               DateTime? @db.Timestamptz
+  created_at               DateTime  @default(now()) @db.Timestamptz
 
   user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
 
diff --git a/packages/db/src/encryption/crypto.ts b/packages/db/src/encryption/crypto.ts
index b95ad9e2ec24a3ca293c3ec286828018c4e76f8d..92f6a05f4e4d6efae321517feb99ccda80365c6e
--- a/packages/db/src/encryption/crypto.ts
+++ b/packages/db/src/encryption/crypto.ts
@@ -1 +1,182 @@
-// Stub for packages/db/src/encryption/crypto.ts
+import { createHash, randomBytes } from 'node:crypto';
+import nacl from 'tweetnacl';
+
+export class KeystoreError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'KeystoreError';
+  }
+}
+
+export interface Keystore {
+  readonly keyId: string;
+  seal(plaintext: string): string;
+  open(sealed: string): string;
+}
+
+export interface CreateKeystoreOptions {
+  /**
+   * Base64 encoded 32-byte secret key. Defaults to process.env.MASTER_KEY.
+   */
+  masterKey?: string;
+}
+
+const SEALED_VERSION = 'pmse-v1';
+const SEALED_PREFIX = `${SEALED_VERSION}.`;
+const SECRET_KEY_LENGTH = nacl.box.secretKeyLength; // 32 bytes
+const PUBLIC_KEY_LENGTH = nacl.box.publicKeyLength; // 32 bytes
+const NONCE_LENGTH = nacl.box.nonceLength; // 24 bytes
+
+function decodeMasterKey(encoded: string | undefined): Uint8Array {
+  if (!encoded) {
+    throw new KeystoreError('MASTER_KEY is required');
+  }
+
+  let decoded: Buffer;
+  try {
+    decoded = Buffer.from(encoded, 'base64');
+  } catch (err) {
+    throw new KeystoreError('MASTER_KEY must be base64 encoded');
+  }
+
+  if (decoded.length !== SECRET_KEY_LENGTH) {
+    throw new KeystoreError(
+      `MASTER_KEY must decode to ${SECRET_KEY_LENGTH} bytes`,
+    );
+  }
+
+  return new Uint8Array(decoded);
+}
+
+function deriveKeyId(publicKey: Uint8Array): string {
+  const digest = createHash('sha256')
+    .update(Buffer.from(publicKey))
+    .digest('base64url');
+  return digest.slice(0, 16);
+}
+
+interface ParsedSealedSecret {
+  version: string;
+  keyId: string;
+  payload: string;
+}
+
+function parseSealedSecret(sealed: string): ParsedSealedSecret {
+  if (typeof sealed !== 'string' || sealed.length === 0) {
+    throw new KeystoreError('sealed secret must be a non-empty string');
+  }
+
+  const parts = sealed.split('.', 3);
+  if (parts.length !== 3) {
+    throw new KeystoreError('sealed secret has an invalid format');
+  }
+
+  const [version, keyId, payload] = parts;
+  if (!version || !keyId || !payload) {
+    throw new KeystoreError('sealed secret is missing components');
+  }
+
+  return { version, keyId, payload };
+}
+
+function decodePayload(payload: string): Buffer {
+  try {
+    return Buffer.from(payload, 'base64url');
+  } catch (err) {
+    throw new KeystoreError('sealed secret payload is not valid base64url');
+  }
+}
+
+export function getSealedSecretKeyId(sealed: string): string {
+  const { version, keyId } = parseSealedSecret(sealed);
+  if (version !== SEALED_VERSION) {
+    throw new KeystoreError('unsupported sealed secret version');
+  }
+  return keyId;
+}
+
+export function isSealedSecret(value: string | null | undefined): boolean {
+  return typeof value === 'string' && value.startsWith(SEALED_PREFIX);
+}
+
+export function createKeystore(
+  options: CreateKeystoreOptions = {},
+): Keystore {
+  const secretKey = decodeMasterKey(options.masterKey ?? process.env.MASTER_KEY);
+  const keyPair = nacl.box.keyPair.fromSecretKey(secretKey);
+  const keyId = deriveKeyId(keyPair.publicKey);
+
+  return {
+    keyId,
+    seal(plaintext: string): string {
+      if (typeof plaintext !== 'string') {
+        throw new KeystoreError('plain secret must be a string');
+      }
+
+      const message = Buffer.from(plaintext, 'utf8');
+      const nonce = randomBytes(NONCE_LENGTH);
+      const ephemeral = nacl.box.keyPair();
+      const cipher = nacl.box(
+        new Uint8Array(message),
+        new Uint8Array(nonce),
+        keyPair.publicKey,
+        ephemeral.secretKey,
+      );
+
+      if (!cipher) {
+        throw new KeystoreError('failed to seal secret');
+      }
+
+      const payload = Buffer.concat([
+        Buffer.from(ephemeral.publicKey),
+        Buffer.from(nonce),
+        Buffer.from(cipher),
+      ]);
+
+      return `${SEALED_VERSION}.${keyId}.${payload.toString('base64url')}`;
+    },
+    open(sealed: string): string {
+      const parsed = parseSealedSecret(sealed);
+      if (parsed.version !== SEALED_VERSION) {
+        throw new KeystoreError('unsupported sealed secret version');
+      }
+
+      if (parsed.keyId !== keyId) {
+        throw new KeystoreError(
+          `sealed secret uses key ${parsed.keyId}, expected ${keyId}`,
+        );
+      }
+
+      const payload = decodePayload(parsed.payload);
+
+      if (
+        payload.length <
+        PUBLIC_KEY_LENGTH + NONCE_LENGTH + nacl.box.overheadLength
+      ) {
+        throw new KeystoreError('sealed secret payload is truncated');
+      }
+
+      const ephemeralPublic = payload.subarray(0, PUBLIC_KEY_LENGTH);
+      const nonce = payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+      const ciphertext = payload.subarray(PUBLIC_KEY_LENGTH + NONCE_LENGTH);
+
+      const plaintext = nacl.box.open(
+        new Uint8Array(ciphertext),
+        new Uint8Array(nonce),
+        new Uint8Array(ephemeralPublic),
+        secretKey,
+      );
+
+      if (!plaintext) {
+        throw new KeystoreError('failed to open sealed secret');
+      }
+
+      return Buffer.from(plaintext).toString('utf8');
+    },
+  };
+}
+
+export const __testing = {
+  SEALED_PREFIX,
+  SEALED_VERSION,
+};
diff --git a/packages/db/src/encryption/index.ts b/packages/db/src/encryption/index.ts
index aa5354b3467c54b75acb2a862113a4f05488baa3..c6cd79ad8da69e1926b379995a9fc34f0f62d385
--- a/packages/db/src/encryption/index.ts
+++ b/packages/db/src/encryption/index.ts
@@ -1 +1,130 @@
-// Stub for packages/db/src/encryption/index.ts
+import {
+  CreateKeystoreOptions,
+  Keystore,
+  KeystoreError,
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+} from './crypto';
+
+export {
+  createKeystore,
+  getSealedSecretKeyId,
+  isSealedSecret,
+  KeystoreError,
+};
+
+export type { CreateKeystoreOptions, Keystore };
+
+export interface ProviderTokenData {
+  accountId: number;
+  accessToken: string | null | undefined;
+  refreshToken: string | null | undefined;
+}
+
+export interface ProviderTokenRecord {
+  accountId: number;
+  access_token_ciphertext: string | null;
+  refresh_token_ciphertext: string | null;
+}
+
+export interface ProviderTokenRotationResult {
+  records: ProviderTokenRecord[];
+  updatedIds: number[];
+}
+
+const normalize = (value: string | null | undefined): string | null =>
+  value ?? null;
+
+export function encryptProviderTokens(
+  data: ProviderTokenData,
+  keystore: Keystore,
+): ProviderTokenRecord {
+  const accessToken = normalize(data.accessToken);
+  const refreshToken = normalize(data.refreshToken);
+
+  return {
+    accountId: data.accountId,
+    access_token_ciphertext: accessToken ? keystore.seal(accessToken) : null,
+    refresh_token_ciphertext: refreshToken ? keystore.seal(refreshToken) : null,
+  };
+}
+
+export function decryptProviderTokens(
+  record: ProviderTokenRecord,
+  keystore: Keystore,
+): ProviderTokenData {
+  const decode = (value: string | null): string | null => {
+    if (!value) {
+      return null;
+    }
+
+    if (!isSealedSecret(value)) {
+      return value;
+    }
+
+    return keystore.open(value);
+  };
+
+  return {
+    accountId: record.accountId,
+    accessToken: decode(record.access_token_ciphertext),
+    refreshToken: decode(record.refresh_token_ciphertext),
+  };
+}
+
+export function rotateProviderAccountTokens(
+  records: ProviderTokenRecord[],
+  source: Keystore,
+  target: Keystore,
+): ProviderTokenRotationResult {
+  const result: ProviderTokenRotationResult = {
+    records: [],
+    updatedIds: [],
+  };
+
+  for (const record of records) {
+    let touched = false;
+
+    const rotateValue = (value: string | null): string | null => {
+      if (!value) {
+        return value;
+      }
+
+      if (isSealedSecret(value)) {
+        const keyId = getSealedSecretKeyId(value);
+
+        if (keyId === target.keyId) {
+          return value;
+        }
+
+        if (keyId !== source.keyId) {
+          throw new KeystoreError(
+            `sealed secret for account ${record.accountId} belongs to unknown key ${keyId}`,
+          );
+        }
+
+        const plaintext = source.open(value);
+        touched = true;
+        return target.seal(plaintext);
+      }
+
+      touched = true;
+      return target.seal(value);
+    };
+
+    const rotated: ProviderTokenRecord = {
+      accountId: record.accountId,
+      access_token_ciphertext: rotateValue(record.access_token_ciphertext),
+      refresh_token_ciphertext: rotateValue(record.refresh_token_ciphertext),
+    };
+
+    if (touched) {
+      result.updatedIds.push(record.accountId);
+    }
+
+    result.records.push(rotated);
+  }
+
+  return result;
+}
diff --git a/packages/db/test/token-rotation.test.ts b/packages/db/test/token-rotation.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..acc6e1b2eccd308c3d8ffdf9f24e8f2cf6d69fc7
--- /dev/null
+++ b/packages/db/test/token-rotation.test.ts
@@ -0,0 +1,96 @@
+import { randomBytes } from 'node:crypto';
+import { describe, expect, it } from 'vitest';
+import {
+  createKeystore,
+  decryptProviderTokens,
+  encryptProviderTokens,
+  rotateProviderAccountTokens,
+} from '../src/encryption';
+
+const makeKey = () => randomBytes(32).toString('base64');
+
+describe('provider token rotation', () => {
+  it('re-encrypts tokens sealed with an old key and leaves fresh tokens untouched', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const accountA = encryptProviderTokens(
+      { accountId: 1, accessToken: 'acc-A', refreshToken: 'ref-A' },
+      oldKey,
+    );
+
+    const accountB = encryptProviderTokens(
+      { accountId: 2, accessToken: 'acc-B', refreshToken: 'ref-B' },
+      newKey,
+    );
+
+    const accountC = {
+      accountId: 3,
+      access_token_ciphertext: 'legacy-access',
+      refresh_token_ciphertext: 'legacy-refresh',
+    };
+
+    const rotated = rotateProviderAccountTokens(
+      [accountA, accountB, accountC],
+      oldKey,
+      newKey,
+    );
+
+    expect(rotated.updatedIds).toEqual([1, 3]);
+
+    const decryptedA = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 1)!,
+      newKey,
+    );
+    expect(decryptedA).toEqual({
+      accountId: 1,
+      accessToken: 'acc-A',
+      refreshToken: 'ref-A',
+    });
+
+    const decryptedB = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 2)!,
+      newKey,
+    );
+    expect(decryptedB).toEqual({
+      accountId: 2,
+      accessToken: 'acc-B',
+      refreshToken: 'ref-B',
+    });
+
+    const decryptedC = decryptProviderTokens(
+      rotated.records.find((r) => r.accountId === 3)!,
+      newKey,
+    );
+    expect(decryptedC).toEqual({
+      accountId: 3,
+      accessToken: 'legacy-access',
+      refreshToken: 'legacy-refresh',
+    });
+  });
+
+  it('is idempotent when run multiple times', () => {
+    const oldKey = createKeystore({ masterKey: makeKey() });
+    const newKey = createKeystore({ masterKey: makeKey() });
+
+    const initial = [
+      encryptProviderTokens(
+        { accountId: 42, accessToken: 'foo', refreshToken: 'bar' },
+        oldKey,
+      ),
+    ];
+
+    const firstPass = rotateProviderAccountTokens(initial, oldKey, newKey);
+    const secondPass = rotateProviderAccountTokens(firstPass.records, oldKey, newKey);
+
+    expect(firstPass.updatedIds).toEqual([42]);
+    expect(secondPass.updatedIds).toEqual([]);
+
+    const decrypted = decryptProviderTokens(secondPass.records[0], newKey);
+    expect(decrypted).toEqual({
+      accountId: 42,
+      accessToken: 'foo',
+      refreshToken: 'bar',
+    });
+  });
+});
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7ff67ae5403d25079502517135c727940de11543..a9f48576f6fbe561f33ee7fd79bab22adec1cda3
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -32,6 +32,9 @@
       prom-client:
         specifier: ^15.1.3
         version: 15.1.3
+      tweetnacl:
+        specifier: ^0.14.5
+        version: 0.14.5
       zod:
         specifier: ^4.1.12
         version: 4.1.12
diff --git a/scripts/rotate-token-key.ts b/scripts/rotate-token-key.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4bb2fe54b5de19ea0edf6032aa4446cb5bd6b20f
--- /dev/null
+++ b/scripts/rotate-token-key.ts
@@ -0,0 +1,102 @@
+#!/usr/bin/env tsx
+import { exit } from 'node:process';
+
+import { prisma } from '../packages/db/src/client';
+import {
+  createKeystore,
+  rotateProviderAccountTokens,
+  type ProviderTokenRecord,
+} from '../packages/db/src/encryption';
+
+interface CliOptions {
+  dryRun: boolean;
+}
+
+const parseOptions = (): CliOptions => ({
+  dryRun: process.argv.includes('--dry-run'),
+});
+
+async function fetchAccountTokens(): Promise<ProviderTokenRecord[]> {
+  const rows = await prisma.account.findMany({
+    select: {
+      id: true,
+      access_token_ciphertext: true,
+      refresh_token_ciphertext: true,
+    },
+  });
+
+  return rows.map((row) => ({
+    accountId: row.id,
+    access_token_ciphertext: row.access_token_ciphertext,
+    refresh_token_ciphertext: row.refresh_token_ciphertext,
+  }));
+}
+
+async function persistUpdates(
+  records: ProviderTokenRecord[],
+  updatedIds: number[],
+  dryRun: boolean,
+): Promise<void> {
+  if (updatedIds.length === 0) {
+    return;
+  }
+
+  const updating = new Set(updatedIds);
+
+  for (const record of records) {
+    if (!updating.has(record.accountId)) {
+      continue;
+    }
+
+    if (dryRun) {
+      continue;
+    }
+
+    await prisma.account.update({
+      where: { id: record.accountId },
+      data: {
+        access_token_ciphertext: record.access_token_ciphertext,
+        refresh_token_ciphertext: record.refresh_token_ciphertext,
+      },
+    });
+  }
+}
+
+async function main() {
+  const options = parseOptions();
+  const previousKey = process.env.MASTER_KEY_PREVIOUS;
+  const nextKey = process.env.MASTER_KEY;
+
+  if (!previousKey || !nextKey) {
+    console.error(
+      '[rotate-token-key] Both MASTER_KEY_PREVIOUS and MASTER_KEY env vars must be set',
+    );
+    exit(1);
+  }
+
+  const source = createKeystore({ masterKey: previousKey });
+  const target = createKeystore({ masterKey: nextKey });
+
+  const records = await fetchAccountTokens();
+  const { records: rotated, updatedIds } = rotateProviderAccountTokens(
+    records,
+    source,
+    target,
+  );
+
+  await persistUpdates(rotated, updatedIds, options.dryRun);
+
+  const action = options.dryRun ? 'would update' : 'updated';
+  console.log(
+    `[rotate-token-key] scanned ${records.length} accounts; ${action} ${updatedIds.length} tokens`,
+  );
+}
+
+main()
+  .catch((err) => {
+    console.error('[rotate-token-key] failed', err);
+    exit(1);
+  })
+  .finally(async () => {
+    await prisma.$disconnect();
+  });

tokens used
180,882
Encrypted provider tokens using sealed boxes and added rotation support.

**Highlights**
- Implemented libsodium-style sealed-box keystore with key fingerprinting and tamper detection (`packages/db/src/encryption/crypto.ts:24`, `packages/db/src/encryption/crypto.ts:102`), re-exported for API use (`apps/api/src/lib/crypto/keystore.ts:1`), and validated env loading (`apps/api/src/config/env.ts:1`).
- Added helpers to encrypt/decrypt provider tokens and perform idempotent rotations based on key IDs (`packages/db/src/encryption/index.ts:40`, `packages/db/src/encryption/index.ts:77`).
- Updated Prisma Account model to persist ciphertext columns annotated for sealed secrets (`packages/db/prisma/schema.prisma:29`).
- Captured unit tests for keystore behavior and rotation scenarios, including plaintext upgrade coverage (`apps/api/src/lib/crypto/__tests__/keystore.test.ts:17`, `packages/db/test/token-rotation.test.ts:12`).
- Shipped a CLI rotation script with dry-run support and env contract (`scripts/rotate-token-key.ts:15`, `scripts/rotate-token-key.ts:65`), documented runbook and env sample updates (`README.md:23`, `.env.example:7`), and added the `tweetnacl` dependency (`package.json:44`).

**Tests**
- `pnpm vitest run`

**Next Steps**
1. Generate a fresh base64 `MASTER_KEY`, set `MASTER_KEY_PREVIOUS` during rotation, and execute `pnpm tsx scripts/rotate-token-key.ts` after seeding real data.
