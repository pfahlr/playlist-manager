OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5781-cd00-7d81-ad94-c91fe475a3f2
--------
user
Implement the functionality described in codex/TASKS/05b_file_exporters.yaml, then verify with any available tests.

thinking
**Preparing to read task instructions**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 76ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Ignoring environment warnings and viewing file contents**
exec
bash -lc "sed -n '1,160p' codex/TASKS/05b_file_exporters.yaml" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 05b_file_exporters
title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
branch: codex/05b_file_exporters
overview: >
  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
acceptance:
  - Tests in codex/code/codex/05b_file_exporters/tests/exporters.test.ts pass by comparing exact strings to goldens.
artifacts_to_touch:
  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
  - codex/code/codex/05b_file_exporters/tests/goldens/*
steps:
  - Implement strict RFC4180 CSV quoting; respect column orders from JSON Schemas.
  - Generate outputs from a fixed PIF fixture; assert equals goldens.


thinking
**Preparing to follow TDD with specs**
exec
bash -lc "sed -n '1,200p' codex/code/codex/05b_file_exporters/tests/exporters.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
sed: can't read codex/code/codex/05b_file_exporters/tests/exporters.test.ts: No such file or directory

thinking
**Checking directory structure**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Listing test directory contents**
exec
bash -lc 'ls codex/code/codex/05b_file_exporters/tests' in /var/home/rick/Development/playlist-manager exited 2 in 58ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
ls: cannot access 'codex/code/codex/05b_file_exporters/tests': No such file or directory

thinking
**Checking codex folder structure**
exec
bash -lc "find codex -maxdepth 3 -type d -name '*05b*'" in /var/home/rick/Development/playlist-manager succeeded in 49ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking for extracted directories and test tasks**
exec
bash -lc "find codex -maxdepth 5 -type f -name 'exporters.test.ts'" in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking task setup and directories**
exec
bash -lc 'ls codex' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
code
LOGS
TASKS

thinking
**Listing codex/code directory**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Listing directory contents**
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator

thinking
**Assessing test creation needs**
exec
bash -lc 'ls packages/providers/file-exporters/src' in /var/home/rick/Development/playlist-manager exited 2 in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
ls: cannot access 'packages/providers/file-exporters/src': No such file or directory

thinking
**Checking packages/providers directory**
exec
bash -lc 'ls packages' in /var/home/rick/Development/playlist-manager succeeded in 52ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
config
contracts
db
interop
providers
utils

thinking
**Listing packages/providers directory contents**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
core
deezer
spotify
tidal
youtube

thinking
**Checking for file-exporters package**
exec
bash -lc 'rg "file-exporter" -n' in /var/home/rick/Development/playlist-manager succeeded in 2.62s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:54:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:132:bash -lc 'ls packages/providers/file-exporters/src' in /var/home/rick/Development/playlist-manager exited 2 in 40ms:
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:135:ls: cannot access 'packages/providers/file-exporters/src': No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:163:**Checking for file-exporters package**
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:165:bash -lc 'rg "file-exporter" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/05b_file_exporters.yaml:9:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}

thinking
**Checking for file exporter packages**
exec
bash -lc 'rg "file exporter" -n' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:176:**Checking for file exporter packages**
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:178:bash -lc 'rg "file exporter" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08b_worker_export_file.yaml:15:  - Use existing file exporters from 05b task.

thinking
**Investigating repository structure and planning tests**
exec
bash -lc 'rg "Playlist Interchange Format" -n' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:188:bash -lc 'rg "Playlist Interchange Format" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:58:  "title": "Playlist Interchange Format (PIF) v1",
schemas/pif-v1.schema.json:4:  "title": "Playlist Interchange Format (PIF) v1",

thinking
**Opening JSON schema file**
exec
bash -lc "sed -n '1,200p' schemas/pif-v1.schema.json" in /var/home/rick/Development/playlist-manager succeeded in 72ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schemas/pif-v1.schema.json",
  "title": "Playlist Interchange Format (PIF) v1",
  "type": "object",
  "additionalProperties": false,
  "required": ["name", "tracks"],
  "properties": {
    "name": { "type": "string" },
    "description": { "type": ["string", "null"] },
    "source_service": { "type": ["string", "null"], "enum": ["spotify", "deezer", "tidal", "youtube", "amazon", null] },
    "source_playlist_id": { "type": ["string", "null"] },
    "tracks": {
      "type": "array",
      "minItems": 1,
      "items": { "$ref": "#/$defs/track" }
    }
  },

thinking
**Searching for CSV schema specification**
exec
bash -lc "find schemas -maxdepth 2 -type f -name '*csv*.json'" in /var/home/rick/Development/playlist-manager succeeded in 60ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Searching for CSV schema and exporters**
exec
bash -lc 'rg "csv lean" -n' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:230:bash -lc 'rg "csv lean" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/10c_mobile_playlist_mvp.yaml:17:  - Add "Export" button calling POST /exports/file (csv lean variant).

thinking
**Searching for file-export references**
exec
bash -lc 'rg "file exporter" -n openapi.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 64ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking schema for exporter**
exec
bash -lc 'find schemas -type f' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
schemas/pif-v1.schema.json
schemas/csv/playlist.lean.json
schemas/csv/playlist.verbose.json

thinking
**Opening CSV schema**
exec
bash -lc "sed -n '1,200p' schemas/csv/playlist.lean.json" in /var/home/rick/Development/playlist-manager succeeded in 53ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schemas/csv/playlist.lean.json",
  "title": "CSV (Lean) Row",
  "type": "object",
  "additionalProperties": false,
  "required": ["position", "title", "artists", "album", "duration_ms", "isrc"],
  "x-csv": { "columnOrder": ["position","title","artists","album","duration_ms","isrc"], "quoting": "RFC4180" },
  "properties": {
    "position": { "type": "integer", "minimum": 1 },
    "title": { "type": "string" },
    "artists": { "type": "string", "description": "Semicolon-separated" },
    "album": { "type": "string" },
    "duration_ms": { "type": "integer", "minimum": 0 },
    "isrc": { "type": ["string", "null"] }
  }
}

thinking
**Requesting more details**
exec
bash -lc "sed -n '1,200p' schemas/csv/playlist.verbose.json" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schemas/csv/playlist.verbose.json",
  "title": "CSV (Verbose) Row",
  "type": "object",
  "additionalProperties": false,
  "required": ["position","title","artists","album","duration_ms"],
  "x-csv": {
    "columnOrder": [
      "position","title","artists","album","release_date","disc_number","track_number",
      "duration_ms","explicit","isrc","mb_recording_id","mb_release_id","mb_release_group_id",
      "mb_artist_ids","spotify_track_id","spotify_album_id","deezer_track_id","deezer_album_id",
      "tidal_track_id","tidal_album_id","youtube_video_id","amazon_track_id","upc","iswc",
      "genres","source_service","source_playlist_id"
    ],
    "quoting": "RFC4180"
  },
  "properties": {

thinking
**Planning CSV generation and tests**
exec
bash -lc "find codex -maxdepth 5 -type d -name 'goldens'" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Searching for PIF fixture**
exec
bash -lc 'rg "pif" codex -n' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:127:05a_pif_validator
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:192:codex/LOGS/tasklog_05a_pif_validator_1762403333.log:58:  "title": "Playlist Interchange Format (PIF) v1",
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:193:schemas/pif-v1.schema.json:4:  "title": "Playlist Interchange Format (PIF) v1",
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:198:bash -lc "sed -n '1,200p' schemas/pif-v1.schema.json" in /var/home/rick/Development/playlist-manager succeeded in 72ms:
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:203:  "$id": "https://example.com/schemas/pif-v1.schema.json",
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:249:schemas/pif-v1.schema.json
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:312:bash -lc 'rg "pif" codex -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/work_list:1:05a_pif_validator.yaml
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:34:05a_pif_validator.yaml
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:13:Implement the functionality described in codex/TASKS/05a_pif_validator.yaml, then verify with any available tests.
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:18:zsh -lc 'cat codex/TASKS/05a_pif_validator.yaml' in /var/home/rick/Development/playlist-manager succeeded in 872ms:
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:19:id: 05a_pif_validator
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:21:branch: codex/05a_pif_validator
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:23:  Implement a validator for /schemas/pif-v1.schema.json with Ajv and add sample good/bad fixtures.
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:25:  - Tests in codex/code/codex/05a_pif_validator/tests/pif.validate.test.ts pass with both valid and invalid fixtures.
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:27:  - packages/contracts/src/pif.ts (validator module)
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:31:  - Load /schemas/pif-v1.schema.json, compile, export validatePIF().
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:49:pif-v1.schema.json

thinking
**Checking type definitions in pif.ts**
exec
bash -lc "sed -n '1,200p' packages/contracts/src/pif.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import Ajv, { type ErrorObject, type ValidateFunction } from 'ajv';
import { createRequire } from 'node:module';

export type PIFProviderService = 'spotify' | 'deezer' | 'tidal' | 'youtube' | 'amazon';

export interface PIFProviderIds {
  spotify_track_id?: string | null;
  deezer_track_id?: string | null;
  tidal_track_id?: string | null;
  youtube_video_id?: string | null;
  amazon_track_id?: string | null;
}

export interface PIFTrack {
  position: number;
  title: string;
  artists: string[];
  album?: string | null;

thinking
**Preparing new file-exporter package**
exec
bash -lc 'ls packages/providers/core' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
src
test

thinking
**Inspecting source directory**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
http
index.ts
match
types.ts

thinking
**Checking module structure and paths**
exec
bash -lc 'ls packages/providers/core' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
src
test

thinking
**Checking package management setup**
exec
bash -lc 'cat pnpm-workspace.yaml' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages:
  - "apps/*"
  - "packages/*"
  - "packages/providers/*"

thinking
**Checking package.json in providers core**
exec
bash -lc "find packages/providers -maxdepth 2 -name 'package.json' -print" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/spotify/package.json
packages/providers/deezer/package.json
packages/providers/tidal/package.json
packages/providers/youtube/package.json

thinking
**Investigating package structure and testing patterns**
exec
bash -lc "sed -n '1,200p' codex/code/codex/05a_pif_validator/tests/pif.validate.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { readFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

import { describe, expect, it } from 'vitest';

import { validatePIF } from '../../../../../packages/contracts/src/pif.ts';

type FixtureName = 'valid.playlist.json' | 'invalid.playlist.json';

const loadFixture = (name: FixtureName) => {
  const fixturePath = join(dirname(fileURLToPath(import.meta.url)), '..', 'fixtures', name);
  return JSON.parse(readFileSync(fixturePath, 'utf-8'));
};

describe('validatePIF', () => {
  it('accepts the valid PIF fixture', () => {
    const result = validatePIF(loadFixture('valid.playlist.json'));

thinking
**Inspecting package structure for new implementation**
exec
bash -lc 'ls packages/providers/spotify' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
package.json
src
tsconfig.json

thinking
**Examining package.json**
exec
bash -lc 'cat packages/providers/spotify/package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "@app/providers-spotify",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    }
  },
  "dependencies": {
    "@app/contracts": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }

thinking
**Considering need for tsconfig**
exec
bash -lc 'cat packages/providers/spotify/tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "bundler",
    "module": "ESNext",
    "target": "ES2022",
    "types": ["node"]
  },
  "include": ["src/**/*"]
}

thinking
**Planning new package and tests**
exec
bash -lc 'cat codex/code/codex/05a_pif_validator/fixtures/valid.playlist.json' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "Chill Mix 2024",
  "description": "Lo-fi instrumentals to stay productive",
  "source_service": "spotify",
  "source_playlist_id": "37i9dQZF1DX4WYpdgoIcn6",
  "tracks": [
    {
      "position": 1,
      "title": "Sunrise Drive",
      "artists": ["Lofi Dreams"],
      "album": "Morning Glow",
      "duration_ms": 187000,
      "explicit": false,
      "release_date": "2023-05-12",
      "isrc": "USABC2300001",
      "mb_recording_id": "123e4567-e89b-12d3-a456-426614174000",
      "mb_release_id": "987e6543-e21b-12d3-a456-426614174999",
      "provider_ids": {

thinking
**Examining playlist format requirements**
exec
bash -lc 'rg "M3U" -n' in /var/home/rick/Development/playlist-manager succeeded in 56ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:47:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:50:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:516:bash -lc 'rg "M3U" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/TASKS/05b_file_exporters.yaml:2:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/TASKS/05b_file_exporters.yaml:5:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
codex/TASKS/05c_importers_file.yaml:2:title: File → PIF importers (CSV/M3U/XSPF/PLS/WPL)

thinking
**Evaluating M3U format requirements**
exec
bash -lc 'rg "XSPF" -n' in /var/home/rick/Development/playlist-manager succeeded in 62ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:47:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:50:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:519:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:47:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:520:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:50:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:522:codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:523:codex/TASKS/05b_file_exporters.yaml:2:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:524:codex/TASKS/05b_file_exporters.yaml:5:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:525:codex/TASKS/05c_importers_file.yaml:2:title: File → PIF importers (CSV/M3U/XSPF/PLS/WPL)
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:530:bash -lc 'rg "XSPF" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/05c_importers_file.yaml:2:title: File → PIF importers (CSV/M3U/XSPF/PLS/WPL)
codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/TASKS/05b_file_exporters.yaml:2:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/TASKS/05b_file_exporters.yaml:5:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.

thinking
**Gathering testing and utility details**
exec
bash -lc 'rg "RFC4180" -n' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:57:  - Implement strict RFC4180 CSV quoting; respect column orders from JSON Schemas.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:266:  "x-csv": { "columnOrder": ["position","title","artists","album","duration_ms","isrc"], "quoting": "RFC4180" },
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:298:    "quoting": "RFC4180"
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:550:bash -lc 'rg "RFC4180" -n' in /var/home/rick/Development/playlist-manager
schemas/csv/playlist.verbose.json:16:    "quoting": "RFC4180"
schemas/csv/playlist.lean.json:8:  "x-csv": { "columnOrder": ["position","title","artists","album","duration_ms","isrc"], "quoting": "RFC4180" },
codex/TASKS/05b_file_exporters.yaml:12:  - Implement strict RFC4180 CSV quoting; respect column orders from JSON Schemas.

thinking
**Planning package setup**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}

thinking
**Organizing multi-step implementation plan**
Plan update
  → Add codex tests and golden fixtures for M3U, XSPF, CSV exporters using the PIF sample (expect failure).
  • Implement file exporter module with RFC4180 CSV quoting and format renderers for M3U/XSPF/CSV lean&verbose.
  • Run relevant test suite(s), adjust as needed until green.
  • Stage, commit with descriptive message, and prepare final summary.

thinking
**Planning test creation and output formats**

I'm working on step 1, which involves adding tests with golden files for M3U, XSPF, and CSV outputs. I need to create test directories and sample fixtures, deciding whether to reuse or copy existing playlist JSON fixtures to keep tests self-contained. Also, I'm defining M3U output details like the header, artist name joining conventions, and selecting preferred provider URLs (Spotify, Deezer, Tidal, YouTube, Amazon) to construct track links, aiming to match the spec or clarify it further.
exec
bash -lc "sed -n '1,200p' codex/TASKS/08b_worker_export_file.yaml" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 08b_worker_export_file
title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
branch: codex/08b_worker_export_file
overview: >
  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.
acceptance:
  - Tests in codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts pass:
    * renders CSV lean equals golden; writes to mocked storage; updates job.artifact_url and status=succeeded.
artifacts_to_touch:
  - apps/worker/src/processors/exportFile.ts
  - apps/worker/src/storage/objectStore.ts
  - codex/code/codex/08b_worker_export_file/tests/goldens/playlist.csv
constraints:
  - No real S3; objectStore.write mocked in tests.
  - Use existing file exporters from 05b task.
tests:
  path: codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
  content: |

thinking
**Searching for M3U references**
exec
bash -lc 'rg "m3u" -n' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
pnpm-lock.yaml:1806:    resolution: {integrity: sha512-c4WYmDKyJXhs7WWvAWm3uIYnfyWFoIp+JEoX34rctVvEkMYCPGhXtvmFFXiffBbxfZsvQ0RNnV5H7GvDF5HCqQ==}
openapi.dredd.yaml:256:                enum: [m3u, xspf, csv]
openapi.yaml:329:                format: { type: string, enum: [m3u, xspf, csv] }
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:54:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:168:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:54:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:173:codex/TASKS/05b_file_exporters.yaml:9:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:619:bash -lc 'rg "m3u" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:786:  format: 'm3u' | 'xspf' | 'csv';
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:792:  const formats = new Set(['m3u', 'xspf', 'csv']);
codex/LOGS/tasklog_04b_openapi_warning_silencer_1762396211.log:204:                format: { type: string, enum: [m3u, xspf, csv] }
codex/TASKS/05c_importers_file.yaml:8:  - POST /imports/file accepts csv|m3u|xspf|pls|wpl and returns PIF preview
codex/TASKS/05c_importers_file.yaml:14:  - packages/interop/src/importers/{csv,m3u,xspf,pls,wpl}.ts
codex/TASKS/05b_file_exporters.yaml:9:  - packages/providers/file-exporters/src/{m3u.ts,xspf.ts,csv.ts}
apps/api/src/lib/openapi/openapi.json:605:                      "m3u",
packages/contracts/src/api.types.ts:627:                    format: "m3u" | "xspf" | "csv";
apps/api/src/routes/exports/file.post.ts:7:  format: 'm3u' | 'xspf' | 'csv';
apps/api/src/routes/exports/file.post.ts:13:  const formats = new Set(['m3u', 'xspf', 'csv']);

thinking
**Checking OpenAPI response format**
exec
bash -lc "sed -n '300,360p' openapi.yaml" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
            type: integer
            example: 5001
            default: 5001
          examples:
            default:
              value: 5001
          x-example: 5001
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Job' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '404': { $ref: '#/components/responses/NotFound' }

  /exports/file:
    post:

thinking
**Searching documentation folder**
exec
bash -lc 'rg "Export" -n docs' in /var/home/rick/Development/playlist-manager exited 1 in 49ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Designing file exporter outputs**
exec
bash -lc 'rg "amazon_track_id" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:295:      "tidal_track_id","tidal_album_id","youtube_video_id","amazon_track_id","upc","iswc",
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:350:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:675:bash -lc 'rg "amazon_track_id" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:346:        \"amazon_track_id\": null
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:365:        \"amazon_track_id\": null
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:522:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:2625:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:2844:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:2951:-  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:3071:-  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:3167:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:4876:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:5038:-  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:5158:-  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:5256:  amazon_track_id?: string | null;
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:6416:  amazon_track_id?: string | null;
codex/code/codex/05a_pif_validator/fixtures/valid.playlist.json:23:        "amazon_track_id": null
codex/code/codex/05a_pif_validator/fixtures/valid.playlist.json:42:        "amazon_track_id": null


thinking
**Designing playlist export formats**

I'm mapping Amazon Music track URLs and defining standard URL patterns for providers to ensure consistent links. Next, I'm detailing how to generate clean XSPF XML playlists with proper escaping and essential track fields. I'm also planning exact M3U and CSV outputs, carefully handling quoting, delimiters, null values, and line endings to match strict format specifications, using a new sample fixture with tricky characters to validate full coverage.
thinking
**Outlining file exporter tests and fixtures**

I’m planning to set up test files and fixtures for playlist exporters, including M3U, XSPF, and CSV variants, ensuring imports resolve correctly relative to test locations. I’ll also create golden files with exact expected outputs, prepare directory structures, and design test code using vitest to validate exported content against these goldens right from the start. This sets the stage for solid test-driven development.
exec
bash -lc 'mkdir -p codex/code/codex/05b_file_exporters/fixtures codex/code/codex/05b_file_exporters/tests/goldens' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Preparing fixture file content**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
{
  "name": "Focus Flow",
  "description": "Energy for creative sprints, remote-friendly.",
  "source_service": "spotify",
  "source_playlist_id": "abc123",
  "tracks": [
    {
      "position": 1,
      "title": "Analog \"Sunset\"",
      "artists": ["Neon Echoes", "Cityline"],
      "album": "Signals, Vol. 2",
      "duration_ms": 200500,
      "explicit": false,
      "release_date": "2023-03-01",
      "isrc": "US-ABC-23-00002",
      "mb_recording_id": null,
      "mb_release_id": null,
      "provider_ids": {
        "spotify_track_id": "spotify123",
        "youtube_video_id": "yt123456"
      }
    },
    {
      "position": 2,
      "title": "Orbital Drift",
      "artists": ["Lofi Dreams"],
      "album": null,
      "duration_ms": null,
      "explicit": null,
      "release_date": null,
      "isrc": null,
      "mb_recording_id": null,
      "mb_release_id": null,
      "provider_ids": {
        "tidal_track_id": "tidal987"
      }
    }
  ]
}
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
A codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}


thinking
**Creating golden files for playlist output**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
#EXTM3U
#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
https://open.spotify.com/track/spotify123
#EXTINF:-1,Lofi Dreams - Orbital Drift
https://tidal.com/browse/track/tidal987
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987


thinking
**Checking for trailing newline**
exec
bash -lc "sed -n '1,10p' codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
#EXTM3U
#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
https://open.spotify.com/track/spotify123
#EXTINF:-1,Lofi Dreams - Orbital Drift
https://tidal.com/browse/track/tidal987
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987


thinking
**Ensuring newline at file end**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987


thinking
**Creating playlist.xspf file**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
<?xml version="1.0" encoding="UTF-8"?>
<playlist version="1" xmlns="http://xspf.org/ns/0/">
  <title>Focus Flow</title>
  <annotation>Energy for creative sprints, remote-friendly.</annotation>
  <trackList>
    <track>
      <title>Analog &quot;Sunset&quot;</title>
      <creator>Neon Echoes; Cityline</creator>
      <album>Signals, Vol. 2</album>
      <duration>200500</duration>
      <location>https://open.spotify.com/track/spotify123</location>
    </track>
    <track>
      <title>Orbital Drift</title>
      <creator>Lofi Dreams</creator>
      <location>https://tidal.com/browse/track/tidal987</location>
    </track>
  </trackList>
</playlist>
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Adding newline at file end**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Creating CSV golden files with CRLF**

I'm figuring out how to produce golden CSV files that strictly follow RFC4180 with CRLF line endings despite working on Linux, where `\n` is standard. Since embedding `\r` in patches is tricky, I'll generate the files using a Python script that writes the CSV content with explicit `\r\n` endings to meet the spec accurately.
exec
bash -lc "python - <<'PY'
from pathlib import Path
content = (
    \"position,title,artists,album,duration_ms,isrc\\r\\n\"
    \"1,\\\"Analog \\\"\\\"Sunset\\\"\\\"\\\",\\\"Neon Echoes; Cityline\\\",\\\"Signals, Vol. 2\\\",200500,US-ABC-23-00002\\r\\n\"
    \"2,Orbital Drift,Lofi Dreams,,,\\r\\n\"
)
Path('codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv').write_text(content, encoding='utf-8')
PY" in /var/home/rick/Development/playlist-manager succeeded in 409ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Preparing verbose CSV data**
exec
bash -lc "python - <<'PY'
from pathlib import Path
header = [
    \"position\",\"title\",\"artists\",\"album\",\"release_date\",\"disc_number\",\"track_number\",
    \"duration_ms\",\"explicit\",\"isrc\",\"mb_recording_id\",\"mb_release_id\",\"mb_release_group_id\",
    \"mb_artist_ids\",\"spotify_track_id\",\"spotify_album_id\",\"deezer_track_id\",\"deezer_album_id\",
    \"tidal_track_id\",\"tidal_album_id\",\"youtube_video_id\",\"amazon_track_id\",\"upc\",\"iswc\",
    \"genres\",\"source_service\",\"source_playlist_id\"
]
rows = [
    [1, 'Analog \"Sunset\"', 'Neon Echoes; Cityline', 'Signals, Vol. 2', '2023-03-01', None, None,
     200500, False, 'US-ABC-23-00002', None, None, None, None, 'spotify123', None, None, None,
     None, None, 'yt123456', None, None, None, None, 'spotify', 'abc123'],
    [2, 'Orbital Drift', 'Lofi Dreams', None, None, None, None, None, None, None, None, None, None, None,
     None, None, None, None, 'tidal987', None, None, None, None, None, None, 'spotify', 'abc123']
]

def quote(value: str) -> str:
    if any(ch in value for ch in '\"\\r\\n,'):
        return '\"' + value.replace('\"', '\"\"') + '\"'
    return value

def render_row(row):
    rendered = []
    for value in row:
        if value is None:
            rendered.append('')
        elif isinstance(value, bool):
            rendered.append('true' if value else 'false')
        else:
            rendered.append(str(value))
    return ','.join(quote(field) for field in rendered)

lines = [','.join(header)] + [render_row(row) for row in rows]
content = '\\r\\n'.join(lines) + '\\r\\n'
Path('codex/code/codex/05b_file_exporters/tests/goldens/playlist.verbose.csv').write_text(content, encoding='utf-8')
PY" in /var/home/rick/Development/playlist-manager succeeded in 63ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Creating file exporter tests**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
import { readFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

import { describe, expect, it } from 'vitest';

import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
import {
  renderCsv,
  renderM3U,
  renderXSPF,
} from '../../../../../packages/providers/file-exporters/src/index.ts';

const here = dirname(fileURLToPath(import.meta.url));
const fixturesDir = join(here, '..', 'fixtures');
const goldensDir = join(here, 'goldens');

const loadFixture = (name: string): PIFDocument =>
  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));

const loadGolden = (name: string): string =>
  readFileSync(join(goldensDir, name), 'utf-8');

describe('file exporters', () => {
  const playlist = loadFixture('sample.playlist.json');

  it('renders M3U output that matches the golden file', () => {
    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
  });

  it('renders XSPF output that matches the golden file', () => {
    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
  });

  it('renders lean CSV output according to the golden file', () => {
    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
  });

  it('renders verbose CSV output according to the golden file', () => {
    expect(renderCsv(playlist, 'verbose')).toEqual(
      loadGolden('playlist.verbose.csv'),
    );
  });
});
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
A codex/code/codex/05b_file_exporters/tests/exporters.test.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Preparing to run tests**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Checking test command usage**
exec
bash -lc 'rg "pnpm vitest" -n codex/LOGS | head' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2247:bash -lc 'rg "pnpm vitest" -n codex/LOGS | head' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:325:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.60s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:400:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts --runInBand' in /var/home/rick/Development/playlist-manager exited 1 in 1.44s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:471:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts --reporter=verbose' in /var/home/rick/Development/playlist-manager exited 124 in 11.59s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1021:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts --reporter=verbose --threads=false' in /var/home/rick/Development/playlist-manager exited 1 in 1.47s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1151:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.86s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:1666:bash -lc 'DEBUG=vitest:pool pnpm vitest run packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.59s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2197:bash -lc 'pnpm vitest run packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.59s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2341:bash -lc 'pnpm vitest run packages/db/test/indexes.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.59s:
codex/LOGS/tasklog_03b_db_migration_ci_gate_1762388664.log:2485:bash -lc 'VITEST_POOL=vm pnpm vitest run packages/db/test/healthcheck.cli.test.ts' in /var/home/rick/Development/playlist-manager exited 124 in 11.59s:
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Preparing to run specific test file**
exec
bash -lc 'pnpm vitest run codex/code/codex/05b_file_exporters/tests/exporters.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 3.03s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/05b_file_exporters/tests/exporters.test.ts [ codex/code/codex/05b_file_exporters/tests/exporters.test.ts ]
Error: Failed to load url ../../../../../packages/providers/file-exporters/src/index.ts (resolved id: ../../../../../packages/providers/file-exporters/src/index.ts) in /var/home/rick/Development/playlist-manager/codex/code/codex/05b_file_exporters/tests/exporters.test.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  23:57:14
   Duration  323ms (transform 38ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 73ms)

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Updating plan after step completion**
Plan update
  ✓ Add codex tests and golden fixtures for M3U, XSPF, CSV exporters using the PIF sample (expect failure).
  → Implement file exporter module with RFC4180 CSV quoting and format renderers for M3U/XSPF/CSV lean&verbose.
  • Run relevant test suite(s), adjust as needed until green.
  • Stage, commit with descriptive message, and prepare final summary.
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Starting file exporter package setup**
exec
bash -lc 'cat packages/contracts/package.json' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "@app/contracts",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    }
  },
  "dependencies": {
    "ajv": "^8.17.1"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Checking exports in index.ts**
exec
bash -lc "sed -n '1,200p' packages/contracts/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 49ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export * from './pif';
export * from './providers';
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Setting up file-exporters package structure**
exec
bash -lc 'mkdir -p packages/providers/file-exporters/src' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>


thinking
**Creating package.json for new package**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/package.json
{
  "name": "@app/providers-file-exporters",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    }
  },
  "dependencies": {
    "@app/contracts": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }
}
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
A packages/providers/file-exporters/package.json
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}


thinking
**Adding tsconfig.json configuration**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/tsconfig.json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "bundler",
    "module": "ESNext",
    "target": "ES2022",
    "types": ["node"]
  },
  "include": ["src/**/*"]
}
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A packages/providers/file-exporters/tsconfig.json
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}



thinking
**Outlining multi-format playlist exporters**

I'm planning how to build CSV, M3U, and XSPF renderers with attention to schema-driven CSV column order, provider URL resolution, and shared helpers, including tricky path calculations to import JSON schemas and balancing shared utility code versus module boundaries. This will help produce accurate playlist exports aligning with spec and consistent provider links across formats.
thinking
**Detailing CSV row construction and shared helpers**

I'm working out how to construct each CSV row’s values carefully with fallback defaults and formatting, while also planning a shared helper module to centralize provider URL resolution and artist joining for reuse across M3U and XSPF. This will keep code cleaner and consistent across formats.
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/shared.ts
import { type PIFProviderIds, type PIFTrack } from '@app/contracts';

type ProviderResolver = {
  key: keyof PIFProviderIds;
  buildUrl: (id: string) => string;
};

const PROVIDER_PRIORITY: ProviderResolver[] = [
  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
];

export const resolveTrackLocation = (track: PIFTrack): string | null => {
  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
  if (!providerIds) {
    return null;
  }

  for (const provider of PROVIDER_PRIORITY) {
    const value = providerIds[provider.key];
    if (typeof value === 'string' && value.length > 0) {
      return provider.buildUrl(value);
    }
  }

  return null;
};

export const joinArtists = (artists: string[], separator: string): string =>
  artists.join(separator);
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
A packages/providers/file-exporters/src/shared.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Implementing m3u.ts with helpers**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/m3u.ts
import { type PIFDocument, type PIFTrack } from '@app/contracts';

import { joinArtists, resolveTrackLocation } from './shared.js';

const ARTIST_SEPARATOR = ' & ';

const formatDurationSeconds = (duration: number | null | undefined): number => {
  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
    return -1;
  }

  const seconds = Math.round(duration / 1000);
  return seconds >= 0 ? seconds : -1;
};

const formatExtInf = (track: PIFTrack): string => {
  const duration = formatDurationSeconds(track.duration_ms);
  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
  return `#EXTINF:${duration},${artists} - ${track.title}`;
};

const trackLocation = (track: PIFTrack): string =>
  resolveTrackLocation(track) ?? track.title;

export const renderM3U = (playlist: PIFDocument): string => {
  const lines: string[] = ['#EXTM3U'];

  for (const track of playlist.tracks) {
    lines.push(formatExtInf(track));
    lines.push(trackLocation(track));
  }

  return `${lines.join('\n')}\n`;
};
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
A packages/providers/file-exporters/src/m3u.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ea8ea89fe9cd82fddc3f1e8164fda1f7caf7a982
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.js';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ea8ea89fe9cd82fddc3f1e8164fda1f7caf7a982
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.js';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Verifying module import extensions**
exec
bash -lc "sed -n '1,200p' packages/providers/spotify/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  ProviderName, ProviderAuth,
  Importer, Exporter, ProviderImpl,
  ReadPlaylistInput, ReadOptions,
  WritePlaylistInput, WriteOptions, WritePlaylistResult,
  PIF
} from '@app/contracts';

type Opts = {
  backoff?: { retries?: number; baseDelayMs?: number; maxDelayMs?: number };
  batch?: { batchSize?: number };
  baseUrl?: string;
};

export default class Spotify implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'spotify';
  private token: string;
  private opts: Required<Opts>;
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ea8ea89fe9cd82fddc3f1e8164fda1f7caf7a982
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.js';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Checking shared.js imports in TS files**
exec
bash -lc "rg \"\\.js'\" -n packages | head" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/file-exporters/src/m3u.ts:3:import { joinArtists, resolveTrackLocation } from './shared.js';
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ea8ea89fe9cd82fddc3f1e8164fda1f7caf7a982
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.js';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Adjusting import extensions to .ts**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/m3u.ts
@@ -2,3 +2,3 @@
 
-import { joinArtists, resolveTrackLocation } from './shared.js';
+import { joinArtists, resolveTrackLocation } from './shared.ts';
 
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M packages/providers/file-exporters/src/m3u.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Implementing XSPF renderer module**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/xspf.ts
import { type PIFDocument, type PIFTrack } from '@app/contracts';

import { joinArtists, resolveTrackLocation } from './shared.ts';

const escapeXml = (value: string): string =>
  value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

const pushTag = (
  lines: string[],
  indent: string,
  tagName: string,
  value: string | null | undefined,
) => {
  if (value === null || value === undefined || value === '') {
    return;
  }

  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
};

const pushTrack = (lines: string[], track: PIFTrack) => {
  lines.push('    <track>');
  pushTag(lines, '      ', 'title', track.title);
  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
  pushTag(lines, '      ', 'album', track.album ?? undefined);

  if (track.duration_ms !== null && track.duration_ms !== undefined) {
    pushTag(lines, '      ', 'duration', String(track.duration_ms));
  }

  const location = resolveTrackLocation(track);
  pushTag(lines, '      ', 'location', location ?? undefined);
  lines.push('    </track>');
};

export const renderXSPF = (playlist: PIFDocument): string => {
  const lines: string[] = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
  ];

  pushTag(lines, '  ', 'title', playlist.name);
  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);

  lines.push('  <trackList>');
  for (const track of playlist.tracks) {
    pushTrack(lines, track);
  }
  lines.push('  </trackList>');
  lines.push('</playlist>');

  return `${lines.join('\n')}\n`;
};
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
A packages/providers/file-exporters/src/xspf.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing CSV module implementation**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/csv.ts
import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
import { createRequire } from 'node:module';

import { joinArtists } from './shared.ts';

export type CsvVariant = 'lean' | 'verbose';

type CsvSchema = {
  'x-csv'?: {
    columnOrder?: string[];
  };
};

type CsvRow = Record<string, string>;

const require = createRequire(import.meta.url);

const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;

const FALLBACK_LEAN_COLUMNS = [
  'position',
  'title',
  'artists',
  'album',
  'duration_ms',
  'isrc',
] as const;

const FALLBACK_VERBOSE_COLUMNS = [
  'position',
  'title',
  'artists',
  'album',
  'release_date',
  'disc_number',
  'track_number',
  'duration_ms',
  'explicit',
  'isrc',
  'mb_recording_id',
  'mb_release_id',
  'mb_release_group_id',
  'mb_artist_ids',
  'spotify_track_id',
  'spotify_album_id',
  'deezer_track_id',
  'deezer_album_id',
  'tidal_track_id',
  'tidal_album_id',
  'youtube_video_id',
  'amazon_track_id',
  'upc',
  'iswc',
  'genres',
  'source_service',
  'source_playlist_id',
] as const;

const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
};

const NEWLINE = '\r\n';
const SPECIAL_CHARS_REGEX = /[",\r\n]/;

const quoteValue = (value: string): string => {
  if (value === '') {
    return '';
  }

  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
};

const stringOrEmpty = (value: string | null | undefined): string => value ?? '';

const numberOrEmpty = (value: number | null | undefined): string =>
  value === null || value === undefined ? '' : String(value);

const booleanOrEmpty = (value: boolean | null | undefined): string => {
  if (value === null || value === undefined) {
    return '';
  }

  return value ? 'true' : 'false';
};

const pickProvider = (
  providerIds: PIFProviderIds | undefined,
  key: keyof PIFProviderIds,
): string => {
  const value = providerIds?.[key];
  return stringOrEmpty(value ?? undefined);
};

const buildLeanRow = (track: PIFTrack): CsvRow => ({
  position: String(track.position),
  title: track.title,
  artists: joinArtists(track.artists, '; '),
  album: stringOrEmpty(track.album ?? undefined),
  duration_ms: numberOrEmpty(track.duration_ms),
  isrc: stringOrEmpty(track.isrc ?? undefined),
});

const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
  const providerIds = track.provider_ids;

  return {
    position: String(track.position),
    title: track.title,
    artists: joinArtists(track.artists, '; '),
    album: stringOrEmpty(track.album ?? undefined),
    release_date: stringOrEmpty(track.release_date ?? undefined),
    disc_number: '',
    track_number: '',
    duration_ms: numberOrEmpty(track.duration_ms),
    explicit: booleanOrEmpty(track.explicit),
    isrc: stringOrEmpty(track.isrc ?? undefined),
    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
    mb_release_group_id: '',
    mb_artist_ids: '',
    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
    spotify_album_id: '',
    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
    deezer_album_id: '',
    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
    tidal_album_id: '',
    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
    upc: '',
    iswc: '',
    genres: '',
    source_service: stringOrEmpty(playlist.source_service ?? undefined),
    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
  };
};

const rowForVariant = (
  playlist: PIFDocument,
  track: PIFTrack,
  variant: CsvVariant,
): CsvRow =>
  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);

const renderRow = (row: CsvRow, columns: string[]): string =>
  columns.map((column) => quoteValue(row[column] ?? '')).join(',');

export const renderCsv = (
  playlist: PIFDocument,
  variant: CsvVariant = 'lean',
): string => {
  const columns = COLUMN_ORDERS[variant];
  const lines: string[] = [columns.join(',')];

  for (const track of playlist.tracks) {
    const row = rowForVariant(playlist, track, variant);
    lines.push(renderRow(row, columns));
  }

  return `${lines.join(NEWLINE)}${NEWLINE}`;
};
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
A packages/providers/file-exporters/src/csv.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..644a2d97083acdee4e609d19b4724afa88d430de
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return stringOrEmpty(value ?? undefined);
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album ?? undefined),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc ?? undefined),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album ?? undefined),
+    release_date: stringOrEmpty(track.release_date ?? undefined),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc ?? undefined),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
+    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service ?? undefined),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..644a2d97083acdee4e609d19b4724afa88d430de
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return stringOrEmpty(value ?? undefined);
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album ?? undefined),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc ?? undefined),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album ?? undefined),
+    release_date: stringOrEmpty(track.release_date ?? undefined),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc ?? undefined),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
+    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service ?? undefined),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Confirming stringOrEmpty usage**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/index.ts
export { renderCsv, type CsvVariant } from './csv.ts';
export { renderM3U } from './m3u.ts';
export { renderXSPF } from './xspf.ts';
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
A packages/providers/file-exporters/src/index.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..644a2d97083acdee4e609d19b4724afa88d430de
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return stringOrEmpty(value ?? undefined);
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album ?? undefined),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc ?? undefined),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album ?? undefined),
+    release_date: stringOrEmpty(track.release_date ?? undefined),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc ?? undefined),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
+    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service ?? undefined),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..644a2d97083acdee4e609d19b4724afa88d430de
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return stringOrEmpty(value ?? undefined);
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album ?? undefined),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc ?? undefined),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album ?? undefined),
+    release_date: stringOrEmpty(track.release_date ?? undefined),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc ?? undefined),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
+    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service ?? undefined),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Simplifying stringOrEmpty usage and pickProvider logic**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/file-exporters/src/csv.ts
@@ -93,3 +93,3 @@
   const value = providerIds?.[key];
-  return stringOrEmpty(value ?? undefined);
+  return typeof value === 'string' ? value : '';
 };
@@ -100,5 +100,5 @@
   artists: joinArtists(track.artists, '; '),
-  album: stringOrEmpty(track.album ?? undefined),
+  album: stringOrEmpty(track.album),
   duration_ms: numberOrEmpty(track.duration_ms),
-  isrc: stringOrEmpty(track.isrc ?? undefined),
+  isrc: stringOrEmpty(track.isrc),
 });
@@ -112,4 +112,4 @@
     artists: joinArtists(track.artists, '; '),
-    album: stringOrEmpty(track.album ?? undefined),
-    release_date: stringOrEmpty(track.release_date ?? undefined),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
     disc_number: '',
@@ -118,5 +118,5 @@
     explicit: booleanOrEmpty(track.explicit),
-    isrc: stringOrEmpty(track.isrc ?? undefined),
-    mb_recording_id: stringOrEmpty(track.mb_recording_id ?? undefined),
-    mb_release_id: stringOrEmpty(track.mb_release_id ?? undefined),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
     mb_release_group_id: '',
@@ -134,4 +134,4 @@
     genres: '',
-    source_service: stringOrEmpty(playlist.source_service ?? undefined),
-    source_playlist_id: stringOrEmpty(playlist.source_playlist_id ?? undefined),
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
   };
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M packages/providers/file-exporters/src/csv.ts
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Ensuring TypeScript import consistency**
exec
bash -lc "rg \"\\.ts'\" packages -n | head" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/file-exporters/src/index.ts:1:export { renderCsv, type CsvVariant } from './csv.ts';
packages/providers/file-exporters/src/index.ts:2:export { renderM3U } from './m3u.ts';
packages/providers/file-exporters/src/index.ts:3:export { renderXSPF } from './xspf.ts';
packages/providers/file-exporters/src/csv.ts:4:import { joinArtists } from './shared.ts';
packages/providers/file-exporters/src/xspf.ts:3:import { joinArtists, resolveTrackLocation } from './shared.ts';
packages/providers/file-exporters/src/m3u.ts:3:import { joinArtists, resolveTrackLocation } from './shared.ts';
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Confirming implementation completion and preparing for tests**
Plan update
  ✓ Add codex tests and golden fixtures for M3U, XSPF, CSV exporters using the PIF sample (expect failure).
  ✓ Implement file exporter module with RFC4180 CSV quoting and format renderers for M3U/XSPF/CSV lean&verbose.
  → Run relevant test suite(s), adjust as needed until green.
  • Stage, commit with descriptive message, and prepare final summary.
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Running tests to verify changes**
exec
bash -lc 'pnpm vitest run codex/code/codex/05b_file_exporters/tests/exporters.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.06s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ codex/code/codex/05b_file_exporters/tests/exporters.test.ts (4 tests | 1 failed) 14ms
   ✓ file exporters > renders M3U output that matches the golden file 2ms
   ✓ file exporters > renders XSPF output that matches the golden file 1ms
   × file exporters > renders lean CSV output according to the golden file 9ms
     → expected 'position,title,artists,album,duration…' to deeply equal 'position,title,artists,album,duration…'
   ✓ file exporters > renders verbose CSV output according to the golden file 1ms

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/05b_file_exporters/tests/exporters.test.ts > file exporters > renders lean CSV output according to the golden file
AssertionError: expected 'position,title,artists,album,duration…' to deeply equal 'position,title,artists,album,duration…'

[32m- Expected[39m
[31m+ Received[39m

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Verifying CSV quoting standards**
exec
bash -lc 'cat -v codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
position,title,artists,album,duration_ms,isrc^M
1,"Analog ""Sunset""","Neon Echoes; Cityline","Signals, Vol. 2",200500,US-ABC-23-00002^M
2,Orbital Drift,Lofi Dreams,,,^M
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Deciding quoting strategy for artists**

I’m sorting out whether to keep or remove quotes around artist names in the golden file since the code doesn’t add them. The spec allows no quotes unless needed, so I’m leaning toward updating the golden to match code, focusing quoting only where necessary. I plan to regenerate the golden CSV with a Python script that mirrors the code’s quoting logic to keep everything consistent.
exec
bash -lc "python - <<'PY'
from pathlib import Path
header = [\"position\",\"title\",\"artists\",\"album\",\"duration_ms\",\"isrc\"]
rows = [
    [1, 'Analog \"Sunset\"', 'Neon Echoes; Cityline', 'Signals, Vol. 2', 200500, 'US-ABC-23-00002'],
    [2, 'Orbital Drift', 'Lofi Dreams', '', '', ''],
]

def quote(value: str) -> str:
    if any(ch in value for ch in '\"\\r\\n,'):
        return '\"' + value.replace('\"', '\"\"') + '\"'
    return value

def render_row(row):
    rendered = []
    for value in row:
        if isinstance(value, bool):
            rendered.append('true' if value else 'false')
        elif value is None:
            rendered.append('')
        else:
            rendered.append(str(value))
    return ','.join(quote(field) for field in rendered)

lines = [','.join(header)] + [render_row(row) for row in rows]
content = '\\r\\n'.join(lines) + '\\r\\n'
Path('codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv').write_text(content, encoding='utf-8')
PY" in /var/home/rick/Development/playlist-manager succeeded in 63ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Verifying file content**
exec
bash -lc 'cat -v codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
position,title,artists,album,duration_ms,isrc^M
1,"Analog ""Sunset""",Neon Echoes; Cityline,"Signals, Vol. 2",200500,US-ABC-23-00002^M
2,Orbital Drift,Lofi Dreams,,,^M
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Running tests again**
exec
bash -lc 'pnpm vitest run codex/code/codex/05b_file_exporters/tests/exporters.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 2.04s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/05b_file_exporters/tests/exporters.test.ts (4 tests) 5ms

 Test Files  1 passed (1)
      Tests  4 passed (4)
   Start at  00:00:34
   Duration  374ms (transform 69ms, setup 0ms, collect 66ms, tests 5ms, environment 0ms, prepare 75ms)

file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Updating plan status**
Plan update
  ✓ Add codex tests and golden fixtures for M3U, XSPF, CSV exporters using the PIF sample (expect failure).
  ✓ Implement file exporter module with RFC4180 CSV quoting and format renderers for M3U/XSPF/CSV lean&verbose.
  ✓ Run relevant test suite(s), adjust as needed until green.
  → Stage, commit with descriptive message, and prepare final summary.
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing to stage changes**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 1]
?? codex.toml
?? codex/LOGS/codex_run_2025-11-05_23-28-52.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log.done
?? codex/LOGS/tasklog_05b_file_exporters_1762404715.log
?? codex/TASKS/work_list
?? codex/code/codex/05b_file_exporters/
?? packages/providers/file-exporters/
?? test_codex_path.txt
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Selecting relevant files to stage**
exec
bash -lc 'git add codex/code/codex/05b_file_exporters packages/providers/file-exporters' in /var/home/rick/Development/playlist-manager succeeded in 82ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Verifying git staging status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 1]
A  codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
A  codex/code/codex/05b_file_exporters/tests/exporters.test.ts
A  codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv
A  codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
A  codex/code/codex/05b_file_exporters/tests/goldens/playlist.verbose.csv
A  codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
A  packages/providers/file-exporters/package.json
A  packages/providers/file-exporters/src/csv.ts
A  packages/providers/file-exporters/src/index.ts
A  packages/providers/file-exporters/src/m3u.ts
A  packages/providers/file-exporters/src/shared.ts
A  packages/providers/file-exporters/src/xspf.ts
A  packages/providers/file-exporters/tsconfig.json
?? codex.toml
?? codex/LOGS/codex_run_2025-11-05_23-28-52.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log.done
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Reviewing staged changes**
exec
bash -lc 'git diff --cached' in /var/home/rick/Development/playlist-manager succeeded in 68ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000..36c41cc
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing to commit changes**
exec
bash -lc 'git commit -m "feat(file-exporters): add PIF exporters with golden tests"' in /var/home/rick/Development/playlist-manager succeeded in 80ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[main 9728026] feat(file-exporters): add PIF exporters with golden tests
 13 files changed, 434 insertions(+)
 create mode 100644 codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
 create mode 100644 codex/code/codex/05b_file_exporters/tests/exporters.test.ts
 create mode 100644 codex/code/codex/05b_file_exporters/tests/goldens/playlist.lean.csv
 create mode 100644 codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
 create mode 100644 codex/code/codex/05b_file_exporters/tests/goldens/playlist.verbose.csv
 create mode 100644 codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
 create mode 100644 packages/providers/file-exporters/package.json
 create mode 100644 packages/providers/file-exporters/src/csv.ts
 create mode 100644 packages/providers/file-exporters/src/index.ts
 create mode 100644 packages/providers/file-exporters/src/m3u.ts
 create mode 100644 packages/providers/file-exporters/src/shared.ts
 create mode 100644 packages/providers/file-exporters/src/xspf.ts
 create mode 100644 packages/providers/file-exporters/tsconfig.json
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Marking final plan step completed**
Plan update
  ✓ Add codex tests and golden fixtures for M3U, XSPF, CSV exporters using the PIF sample (expect failure).
  ✓ Implement file exporter module with RFC4180 CSV quoting and format renderers for M3U/XSPF/CSV lean&verbose.
  ✓ Run relevant test suite(s), adjust as needed until green.
  ✓ Stage, commit with descriptive message, and prepare final summary.
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing final response details**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 2]
?? codex.toml
?? codex/LOGS/codex_run_2025-11-05_23-28-52.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log
?? codex/LOGS/tasklog_05a_pif_validator_1762403333.log.done
?? codex/LOGS/tasklog_05b_file_exporters_1762404715.log
?? codex/TASKS/work_list
?? test_codex_path.txt
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing detailed commit summary**
exec
bash -lc "nl -ba packages/providers/file-exporters/src/csv.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 115ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
     2	import { createRequire } from 'node:module';
     3	
     4	import { joinArtists } from './shared.ts';
     5	
     6	export type CsvVariant = 'lean' | 'verbose';
     7	
     8	type CsvSchema = {
     9	  'x-csv'?: {
    10	    columnOrder?: string[];
    11	  };
    12	};
    13	
    14	type CsvRow = Record<string, string>;
    15	
    16	const require = createRequire(import.meta.url);
    17	
    18	const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Requesting line numbers for m3u.ts**
exec
bash -lc 'nl -ba packages/providers/file-exporters/src/m3u.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { type PIFDocument, type PIFTrack } from '@app/contracts';
     2	
     3	import { joinArtists, resolveTrackLocation } from './shared.ts';
     4	
     5	const ARTIST_SEPARATOR = ' & ';
     6	
     7	const formatDurationSeconds = (duration: number | null | undefined): number => {
     8	  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
     9	    return -1;
    10	  }
    11	
    12	  const seconds = Math.round(duration / 1000);
    13	  return seconds >= 0 ? seconds : -1;
    14	};
    15	
    16	const formatExtInf = (track: PIFTrack): string => {
    17	  const duration = formatDurationSeconds(track.duration_ms);
    18	  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Checking line numbers in shared.ts**
exec
bash -lc 'nl -ba packages/providers/file-exporters/src/shared.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
     2	
     3	type ProviderResolver = {
     4	  key: keyof PIFProviderIds;
     5	  buildUrl: (id: string) => string;
     6	};
     7	
     8	const PROVIDER_PRIORITY: ProviderResolver[] = [
     9	  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
    10	  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
    11	  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
    12	  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
    13	  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
    14	];
    15	
    16	export const resolveTrackLocation = (track: PIFTrack): string | null => {
    17	  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
    18	  if (!providerIds) {
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Checking line numbers in xspf.ts**
exec
bash -lc 'nl -ba packages/providers/file-exporters/src/xspf.ts' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { type PIFDocument, type PIFTrack } from '@app/contracts';
     2	
     3	import { joinArtists, resolveTrackLocation } from './shared.ts';
     4	
     5	const escapeXml = (value: string): string =>
     6	  value
     7	    .replace(/&/g, '&amp;')
     8	    .replace(/</g, '&lt;')
     9	    .replace(/>/g, '&gt;')
    10	    .replace(/"/g, '&quot;')
    11	    .replace(/'/g, '&apos;');
    12	
    13	const pushTag = (
    14	  lines: string[],
    15	  indent: string,
    16	  tagName: string,
    17	  value: string | null | undefined,
    18	) => {
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Checking tests file line numbers**
exec
bash -lc 'nl -ba codex/code/codex/05b_file_exporters/tests/exporters.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { readFileSync } from 'node:fs';
     2	import { dirname, join } from 'node:path';
     3	import { fileURLToPath } from 'node:url';
     4	
     5	import { describe, expect, it } from 'vitest';
     6	
     7	import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
     8	import {
     9	  renderCsv,
    10	  renderM3U,
    11	  renderXSPF,
    12	} from '../../../../../packages/providers/file-exporters/src/index.ts';
    13	
    14	const here = dirname(fileURLToPath(import.meta.url));
    15	const fixturesDir = join(here, '..', 'fixtures');
    16	const goldensDir = join(here, 'goldens');
    17	
    18	const loadFixture = (name: string): PIFDocument =>
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}


thinking
**Preparing final summary and report**
codex
**Summary**
- `packages/providers/file-exporters/src/csv.ts:1` loads CSV schema metadata to drive lean/verbose column orders and applies RFC4180 quoting-plus-null handling when rendering playlist rows.
- `packages/providers/file-exporters/src/m3u.ts:1` and `packages/providers/file-exporters/src/shared.ts:1` build M3U output, preferring provider URLs (Spotify→Amazon fallback) and falling back to titles when none exist.
- `packages/providers/file-exporters/src/xspf.ts:1` emits XSPF XML with proper escaping and optional fields per track.
- `codex/code/codex/05b_file_exporters/tests/exporters.test.ts:1` adds fixture-driven Vitest coverage comparing exporter outputs to new goldens in `tests/goldens/*.csv|m3u|xspf`, backed by `fixtures/sample.playlist.json`.

**Tests**
- `pnpm vitest run codex/code/codex/05b_file_exporters/tests/exporters.test.ts`

Commit: `feat(file-exporters): add PIF exporters with golden tests`  
Git status: clean commit; untracked workspace files remain (`codex.toml`, `codex/LOGS/...`, `codex/TASKS/work_list`, `test_codex_path.txt`).

Optional next step: 1) Wire these exporters into the worker/export API flow once downstream tasks are active.
file update:
diff --git a/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..36c41cc8ee0ddfae52dfb1dc9f0311feae5c9a16
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/fixtures/sample.playlist.json
@@ -0,0 +1,39 @@
+{
+  "name": "Focus Flow",
+  "description": "Energy for creative sprints, remote-friendly.",
+  "source_service": "spotify",
+  "source_playlist_id": "abc123",
+  "tracks": [
+    {
+      "position": 1,
+      "title": "Analog \"Sunset\"",
+      "artists": ["Neon Echoes", "Cityline"],
+      "album": "Signals, Vol. 2",
+      "duration_ms": 200500,
+      "explicit": false,
+      "release_date": "2023-03-01",
+      "isrc": "US-ABC-23-00002",
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "spotify_track_id": "spotify123",
+        "youtube_video_id": "yt123456"
+      }
+    },
+    {
+      "position": 2,
+      "title": "Orbital Drift",
+      "artists": ["Lofi Dreams"],
+      "album": null,
+      "duration_ms": null,
+      "explicit": null,
+      "release_date": null,
+      "isrc": null,
+      "mb_recording_id": null,
+      "mb_release_id": null,
+      "provider_ids": {
+        "tidal_track_id": "tidal987"
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/05b_file_exporters/tests/exporters.test.ts b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e871033bec20a776c280537a855a6b1e1654ac59
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/exporters.test.ts
@@ -0,0 +1,44 @@
+import { readFileSync } from 'node:fs';
+import { dirname, join } from 'node:path';
+import { fileURLToPath } from 'node:url';
+
+import { describe, expect, it } from 'vitest';
+
+import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
+import {
+  renderCsv,
+  renderM3U,
+  renderXSPF,
+} from '../../../../../packages/providers/file-exporters/src/index.ts';
+
+const here = dirname(fileURLToPath(import.meta.url));
+const fixturesDir = join(here, '..', 'fixtures');
+const goldensDir = join(here, 'goldens');
+
+const loadFixture = (name: string): PIFDocument =>
+  JSON.parse(readFileSync(join(fixturesDir, name), 'utf-8'));
+
+const loadGolden = (name: string): string =>
+  readFileSync(join(goldensDir, name), 'utf-8');
+
+describe('file exporters', () => {
+  const playlist = loadFixture('sample.playlist.json');
+
+  it('renders M3U output that matches the golden file', () => {
+    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
+  });
+
+  it('renders XSPF output that matches the golden file', () => {
+    expect(renderXSPF(playlist)).toEqual(loadGolden('playlist.xspf'));
+  });
+
+  it('renders lean CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
+  });
+
+  it('renders verbose CSV output according to the golden file', () => {
+    expect(renderCsv(playlist, 'verbose')).toEqual(
+      loadGolden('playlist.verbose.csv'),
+    );
+  });
+});
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
new file mode 100644
index 0000000000000000000000000000000000000000..fb2881821d5d53f7bb3446730bb4f1541155894a
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u
@@ -0,0 +1,5 @@
+#EXTM3U
+#EXTINF:201,Neon Echoes & Cityline - Analog "Sunset"
+https://open.spotify.com/track/spotify123
+#EXTINF:-1,Lofi Dreams - Orbital Drift
+https://tidal.com/browse/track/tidal987
diff --git a/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
new file mode 100644
index 0000000000000000000000000000000000000000..e5dafc1cbd438caa66bf6f9af456628444e07161
--- /dev/null
+++ b/codex/code/codex/05b_file_exporters/tests/goldens/playlist.xspf
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<playlist version="1" xmlns="http://xspf.org/ns/0/">
+  <title>Focus Flow</title>
+  <annotation>Energy for creative sprints, remote-friendly.</annotation>
+  <trackList>
+    <track>
+      <title>Analog &quot;Sunset&quot;</title>
+      <creator>Neon Echoes; Cityline</creator>
+      <album>Signals, Vol. 2</album>
+      <duration>200500</duration>
+      <location>https://open.spotify.com/track/spotify123</location>
+    </track>
+    <track>
+      <title>Orbital Drift</title>
+      <creator>Lofi Dreams</creator>
+      <location>https://tidal.com/browse/track/tidal987</location>
+    </track>
+  </trackList>
+</playlist>
diff --git a/packages/providers/file-exporters/package.json b/packages/providers/file-exporters/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..545c4edae30187b32e01cfc40fb1d0e6358ae995
--- /dev/null
+++ b/packages/providers/file-exporters/package.json
@@ -0,0 +1,19 @@
+{
+  "name": "@app/providers-file-exporters",
+  "private": true,
+  "version": "0.1.0",
+  "type": "module",
+  "main": "src/index.ts",
+  "exports": {
+    ".": {
+      "types": "./src/index.ts",
+      "default": "./src/index.ts"
+    }
+  },
+  "dependencies": {
+    "@app/contracts": "workspace:*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3"
+  }
+}
diff --git a/packages/providers/file-exporters/src/csv.ts b/packages/providers/file-exporters/src/csv.ts
new file mode 100644
index 0000000000000000000000000000000000000000..224136c7b15ccb2936e648b70e408a3d8f5b2be5
--- /dev/null
+++ b/packages/providers/file-exporters/src/csv.ts
@@ -0,0 +1,163 @@
+import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
+import { createRequire } from 'node:module';
+
+import { joinArtists } from './shared.ts';
+
+export type CsvVariant = 'lean' | 'verbose';
+
+type CsvSchema = {
+  'x-csv'?: {
+    columnOrder?: string[];
+  };
+};
+
+type CsvRow = Record<string, string>;
+
+const require = createRequire(import.meta.url);
+
+const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
+const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;
+
+const FALLBACK_LEAN_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'duration_ms',
+  'isrc',
+] as const;
+
+const FALLBACK_VERBOSE_COLUMNS = [
+  'position',
+  'title',
+  'artists',
+  'album',
+  'release_date',
+  'disc_number',
+  'track_number',
+  'duration_ms',
+  'explicit',
+  'isrc',
+  'mb_recording_id',
+  'mb_release_id',
+  'mb_release_group_id',
+  'mb_artist_ids',
+  'spotify_track_id',
+  'spotify_album_id',
+  'deezer_track_id',
+  'deezer_album_id',
+  'tidal_track_id',
+  'tidal_album_id',
+  'youtube_video_id',
+  'amazon_track_id',
+  'upc',
+  'iswc',
+  'genres',
+  'source_service',
+  'source_playlist_id',
+] as const;
+
+const COLUMN_ORDERS: Record<CsvVariant, string[]> = {
+  lean: leanSchema['x-csv']?.columnOrder ?? [...FALLBACK_LEAN_COLUMNS],
+  verbose: verboseSchema['x-csv']?.columnOrder ?? [...FALLBACK_VERBOSE_COLUMNS],
+};
+
+const NEWLINE = '\r\n';
+const SPECIAL_CHARS_REGEX = /[",\r\n]/;
+
+const quoteValue = (value: string): string => {
+  if (value === '') {
+    return '';
+  }
+
+  return SPECIAL_CHARS_REGEX.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
+};
+
+const stringOrEmpty = (value: string | null | undefined): string => value ?? '';
+
+const numberOrEmpty = (value: number | null | undefined): string =>
+  value === null || value === undefined ? '' : String(value);
+
+const booleanOrEmpty = (value: boolean | null | undefined): string => {
+  if (value === null || value === undefined) {
+    return '';
+  }
+
+  return value ? 'true' : 'false';
+};
+
+const pickProvider = (
+  providerIds: PIFProviderIds | undefined,
+  key: keyof PIFProviderIds,
+): string => {
+  const value = providerIds?.[key];
+  return typeof value === 'string' ? value : '';
+};
+
+const buildLeanRow = (track: PIFTrack): CsvRow => ({
+  position: String(track.position),
+  title: track.title,
+  artists: joinArtists(track.artists, '; '),
+  album: stringOrEmpty(track.album),
+  duration_ms: numberOrEmpty(track.duration_ms),
+  isrc: stringOrEmpty(track.isrc),
+});
+
+const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
+  const providerIds = track.provider_ids;
+
+  return {
+    position: String(track.position),
+    title: track.title,
+    artists: joinArtists(track.artists, '; '),
+    album: stringOrEmpty(track.album),
+    release_date: stringOrEmpty(track.release_date),
+    disc_number: '',
+    track_number: '',
+    duration_ms: numberOrEmpty(track.duration_ms),
+    explicit: booleanOrEmpty(track.explicit),
+    isrc: stringOrEmpty(track.isrc),
+    mb_recording_id: stringOrEmpty(track.mb_recording_id),
+    mb_release_id: stringOrEmpty(track.mb_release_id),
+    mb_release_group_id: '',
+    mb_artist_ids: '',
+    spotify_track_id: pickProvider(providerIds, 'spotify_track_id'),
+    spotify_album_id: '',
+    deezer_track_id: pickProvider(providerIds, 'deezer_track_id'),
+    deezer_album_id: '',
+    tidal_track_id: pickProvider(providerIds, 'tidal_track_id'),
+    tidal_album_id: '',
+    youtube_video_id: pickProvider(providerIds, 'youtube_video_id'),
+    amazon_track_id: pickProvider(providerIds, 'amazon_track_id'),
+    upc: '',
+    iswc: '',
+    genres: '',
+    source_service: stringOrEmpty(playlist.source_service),
+    source_playlist_id: stringOrEmpty(playlist.source_playlist_id),
+  };
+};
+
+const rowForVariant = (
+  playlist: PIFDocument,
+  track: PIFTrack,
+  variant: CsvVariant,
+): CsvRow =>
+  variant === 'lean' ? buildLeanRow(track) : buildVerboseRow(playlist, track);
+
+const renderRow = (row: CsvRow, columns: string[]): string =>
+  columns.map((column) => quoteValue(row[column] ?? '')).join(',');
+
+export const renderCsv = (
+  playlist: PIFDocument,
+  variant: CsvVariant = 'lean',
+): string => {
+  const columns = COLUMN_ORDERS[variant];
+  const lines: string[] = [columns.join(',')];
+
+  for (const track of playlist.tracks) {
+    const row = rowForVariant(playlist, track, variant);
+    lines.push(renderRow(row, columns));
+  }
+
+  return `${lines.join(NEWLINE)}${NEWLINE}`;
+};
diff --git a/packages/providers/file-exporters/src/index.ts b/packages/providers/file-exporters/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1a0f2d98f55fe1216b58530800e898ace802dd
--- /dev/null
+++ b/packages/providers/file-exporters/src/index.ts
@@ -0,0 +1,3 @@
+export { renderCsv, type CsvVariant } from './csv.ts';
+export { renderM3U } from './m3u.ts';
+export { renderXSPF } from './xspf.ts';
diff --git a/packages/providers/file-exporters/src/m3u.ts b/packages/providers/file-exporters/src/m3u.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7d0f3ce5b6ec8ad2ed1e95e2cc251dbe1ae40ef4
--- /dev/null
+++ b/packages/providers/file-exporters/src/m3u.ts
@@ -0,0 +1,34 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const ARTIST_SEPARATOR = ' & ';
+
+const formatDurationSeconds = (duration: number | null | undefined): number => {
+  if (typeof duration !== 'number' || !Number.isFinite(duration)) {
+    return -1;
+  }
+
+  const seconds = Math.round(duration / 1000);
+  return seconds >= 0 ? seconds : -1;
+};
+
+const formatExtInf = (track: PIFTrack): string => {
+  const duration = formatDurationSeconds(track.duration_ms);
+  const artists = joinArtists(track.artists, ARTIST_SEPARATOR);
+  return `#EXTINF:${duration},${artists} - ${track.title}`;
+};
+
+const trackLocation = (track: PIFTrack): string =>
+  resolveTrackLocation(track) ?? track.title;
+
+export const renderM3U = (playlist: PIFDocument): string => {
+  const lines: string[] = ['#EXTM3U'];
+
+  for (const track of playlist.tracks) {
+    lines.push(formatExtInf(track));
+    lines.push(trackLocation(track));
+  }
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/src/shared.ts b/packages/providers/file-exporters/src/shared.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6693ba1b19398f648f76d883c82eb55373495c05
--- /dev/null
+++ b/packages/providers/file-exporters/src/shared.ts
@@ -0,0 +1,33 @@
+import { type PIFProviderIds, type PIFTrack } from '@app/contracts';
+
+type ProviderResolver = {
+  key: keyof PIFProviderIds;
+  buildUrl: (id: string) => string;
+};
+
+const PROVIDER_PRIORITY: ProviderResolver[] = [
+  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
+  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
+  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
+  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
+  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
+];
+
+export const resolveTrackLocation = (track: PIFTrack): string | null => {
+  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
+  if (!providerIds) {
+    return null;
+  }
+
+  for (const provider of PROVIDER_PRIORITY) {
+    const value = providerIds[provider.key];
+    if (typeof value === 'string' && value.length > 0) {
+      return provider.buildUrl(value);
+    }
+  }
+
+  return null;
+};
+
+export const joinArtists = (artists: string[], separator: string): string =>
+  artists.join(separator);
diff --git a/packages/providers/file-exporters/src/xspf.ts b/packages/providers/file-exporters/src/xspf.ts
new file mode 100644
index 0000000000000000000000000000000000000000..921085e96cfcde87d28b6daad01eb74caeb75647
--- /dev/null
+++ b/packages/providers/file-exporters/src/xspf.ts
@@ -0,0 +1,58 @@
+import { type PIFDocument, type PIFTrack } from '@app/contracts';
+
+import { joinArtists, resolveTrackLocation } from './shared.ts';
+
+const escapeXml = (value: string): string =>
+  value
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&apos;');
+
+const pushTag = (
+  lines: string[],
+  indent: string,
+  tagName: string,
+  value: string | null | undefined,
+) => {
+  if (value === null || value === undefined || value === '') {
+    return;
+  }
+
+  lines.push(`${indent}<${tagName}>${escapeXml(value)}</${tagName}>`);
+};
+
+const pushTrack = (lines: string[], track: PIFTrack) => {
+  lines.push('    <track>');
+  pushTag(lines, '      ', 'title', track.title);
+  pushTag(lines, '      ', 'creator', joinArtists(track.artists, '; '));
+  pushTag(lines, '      ', 'album', track.album ?? undefined);
+
+  if (track.duration_ms !== null && track.duration_ms !== undefined) {
+    pushTag(lines, '      ', 'duration', String(track.duration_ms));
+  }
+
+  const location = resolveTrackLocation(track);
+  pushTag(lines, '      ', 'location', location ?? undefined);
+  lines.push('    </track>');
+};
+
+export const renderXSPF = (playlist: PIFDocument): string => {
+  const lines: string[] = [
+    '<?xml version="1.0" encoding="UTF-8"?>',
+    '<playlist version="1" xmlns="http://xspf.org/ns/0/">',
+  ];
+
+  pushTag(lines, '  ', 'title', playlist.name);
+  pushTag(lines, '  ', 'annotation', playlist.description ?? undefined);
+
+  lines.push('  <trackList>');
+  for (const track of playlist.tracks) {
+    pushTrack(lines, track);
+  }
+  lines.push('  </trackList>');
+  lines.push('</playlist>');
+
+  return `${lines.join('\n')}\n`;
+};
diff --git a/packages/providers/file-exporters/tsconfig.json b/packages/providers/file-exporters/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..30b25791e6d7f9bc8506bcebe93f64b57e0499d6
--- /dev/null
+++ b/packages/providers/file-exporters/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "extends": "../../../tsconfig.json",
+  "compilerOptions": {
+    "strict": true,
+    "moduleResolution": "bundler",
+    "module": "ESNext",
+    "target": "ES2022",
+    "types": ["node"]
+  },
+  "include": ["src/**/*"]
+}

tokens used
227,454
**Summary**
- `packages/providers/file-exporters/src/csv.ts:1` loads CSV schema metadata to drive lean/verbose column orders and applies RFC4180 quoting-plus-null handling when rendering playlist rows.
- `packages/providers/file-exporters/src/m3u.ts:1` and `packages/providers/file-exporters/src/shared.ts:1` build M3U output, preferring provider URLs (Spotify→Amazon fallback) and falling back to titles when none exist.
- `packages/providers/file-exporters/src/xspf.ts:1` emits XSPF XML with proper escaping and optional fields per track.
- `codex/code/codex/05b_file_exporters/tests/exporters.test.ts:1` adds fixture-driven Vitest coverage comparing exporter outputs to new goldens in `tests/goldens/*.csv|m3u|xspf`, backed by `fixtures/sample.playlist.json`.

**Tests**
- `pnpm vitest run codex/code/codex/05b_file_exporters/tests/exporters.test.ts`

Commit: `feat(file-exporters): add PIF exporters with golden tests`  
Git status: clean commit; untracked workspace files remain (`codex.toml`, `codex/LOGS/...`, `codex/TASKS/work_list`, `test_codex_path.txt`).

Optional next step: 1) Wire these exporters into the worker/export API flow once downstream tasks are active.
