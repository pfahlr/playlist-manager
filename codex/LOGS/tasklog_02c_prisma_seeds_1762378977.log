OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a55f9-107e-7c63-80dd-9dee9a967f32
--------
user
Implement the functionality described in codex/TASKS/02c_prisma_seeds.yaml, then verify with any available tests.

thinking
**Inspecting task instructions for planning**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
00_repo_sanity_review.yaml
01a_spec_bootstrap.yaml
02a_prisma_init.yaml
02b_raw_migrations.yaml
02c_prisma_seeds.yaml
02d_db_indexes_bench.yaml
03a_dbpkg_singleton.yaml
03b_db_migration_ci_gate.yaml
03c_token_encryption_at_rest.yaml
04a_api_validation_wiring.yaml
04b_openapi_warning_silencer.yaml
04c_api_docs_ui.yaml
04d_config_feature_flags.yaml
05a_pif_validator.yaml
05b_file_exporters.yaml
05c_importers_file.yaml
06a_provider_interfaces.yaml
06b_spotify_impl.yaml

thinking
**Checking Task file**
exec
bash -lc 'cat codex/TASKS/02c_prisma_seeds.yaml' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 02c_prisma_seeds
title: Prisma seed data (minimal fixtures for contracts & demos)
branch: codex/02c_prisma_seeds
overview: >
  Create deterministic seed data (1 test user, 2 artists with MBIDs, 2 albums,
  1 playlist with 6 items) to enable local runs & contract tests without providers.
acceptance:
  - pnpm -F @app/db prisma db seed exits 0 and re-seeding is idempotent
  - db:health returns "ok"
  - SELECT COUNT(*) FROM playlist_items returns >= 6 after seeding
  - Seeds are deterministic (same IDs on re-run)
artifacts_to_touch:
  - packages/db/package.json
  - prisma/seed.ts
  - prisma/seed-data/*.json
  - README.md (brief "Seeding" section)
steps:
  - Add "prisma": { "seed": "tsx prisma/seed.ts" } to packages/db/package.json

thinking
**Investigating testing setup for DB seed tasks**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
AGENTS.md
apps
codex
codex_run_2025-11-05_15-53-33.log
codex_run_2025-11-05_15-56-49.log
codex_run_2025-11-05_15-58-09.log
codex_run_2025-11-05_16-04-53.log
codex_run_2025-11-05_16-34-27.log
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages

thinking
**Inspecting packages/db**
exec
bash -lc 'ls packages/db' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
node_modules
package.json
prisma
src
test
tsconfig.json

thinking
**Preparing to add Prisma seed script**
exec
bash -lc 'ls packages/db/prisma' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
migrations
schema.prisma
seed-data
seed.ts

thinking
**Inspecting existing seed.ts file**
exec
bash -lc 'ls packages/db/prisma/seed-data' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
albums.json
artists.json
recordings.json

thinking
**Inspecting JSON contents**
exec
bash -lc 'cat packages/db/prisma/seed-data/artists.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[
  { "name": "Boards of Canada", "mbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b" },
  { "name": "Aphex Twin", "mbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5" }
]

thinking
**Checking for albums**
exec
bash -lc 'cat packages/db/prisma/seed-data/albums.json' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[
  {
    "title": "Music Has the Right to Children",
    "releaseDate": "1998-04-20",
    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
  },
  {
    "title": "Selected Ambient Works 85-92",
    "releaseDate": "1992-11-09",
    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
  }
]

thinking
**Noting recordings**
exec
bash -lc 'cat packages/db/prisma/seed-data/recordings.json' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[
  {
    "title": "Roygbiv",
    "durationMs": 155000,
    "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
    "albumTitle": "Music Has the Right to Children"
  },
  {
    "title": "Xtal",
    "durationMs": 272000,
    "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
    "albumTitle": "Selected Ambient Works 85-92"
  }
]

thinking
**Examining playlist requirements**
exec
bash -lc 'cat packages/db/prisma/seed.ts' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { PrismaClient } from '@prisma/client';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const defaultPrisma = new PrismaClient();
const currentDir = path.dirname(fileURLToPath(import.meta.url));
const seedDataDir = path.join(currentDir, 'seed-data');

function readJSON<T>(fileName: string): T {
  const fullPath = path.join(seedDataDir, fileName);
  return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
}

async function upsertUserByEmail(client: PrismaClient, email: string) {
  return client.user.upsert({
    where: { email },
    update: {},

thinking
**Reviewing Seed.ts behavior and tests**
exec
bash -lc 'ls packages/db/test' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
seed.test.ts

thinking
**Starting inspection**
exec
bash -lc 'cat packages/db/test/seed.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { beforeEach, afterAll, expect, test } from 'vitest';
import { prisma } from '../src/client';
import { runSeed } from '../prisma/seed';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,

thinking
**Preparing tests for deterministic playlist behavior**
exec
bash -lc 'cat packages/db/package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "@app/db",
  "private": true,
  "type": "module",
  "scripts": {
    "prisma": "prisma",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0"
  },
  "devDependencies": {

thinking
**Checking existing prisma seed script**
exec
bash -lc 'rg "db:health" -n' in /var/home/rick/Development/playlist-manager succeeded in 3.68s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
tasklog_02c_prisma_seeds_1762378977.log:54:  - db:health returns "ok"
tasklog_02c_prisma_seeds_1762378977.log:263:bash -lc 'rg "db:health" -n' in /var/home/rick/Development/playlist-manager
AGENTS.md:41:pnpm db:health
codex/TASKS/03b_db_migration_ci_gate.yaml:5:  Add a CI job that boots Postgres service, runs prisma migrate deploy, executes db:health,
codex/TASKS/03b_db_migration_ci_gate.yaml:16:  - Run prisma migrate deploy; pnpm db:health; run a tiny node script to SELECT 1
codex/TASKS/02c_prisma_seeds.yaml:9:  - db:health returns "ok"
package.json:25:    "db:health": "tsx packages/db/src/healthcheck.ts",

thinking
**Planning seed data implementation**

I‚Äôm mapping out a multi-step approach for adding deterministic seed data and tests, so I'll use a plan with at least three steps. First, I want to gather more details about the data requirements and verify the Prisma schema to ensure the seed data matches the expected fields and structure. This includes creating JSON for users, artists with MBIDs, albums, and a playlist.
exec
bash -lc 'cat packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// Prisma Client + Postgres
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ===================== Users & Accounts =====================

model User {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  name       String?
  created_at DateTime @default(now()) @db.Timestamptz


thinking
**Planning seed updates and tests**

I‚Äôm mapping out steps to ensure seeding runs in transactions with proper error handling and unique playlist item positions. I‚Äôll start by adding tests that fail to nail down requirements, then update seed scripts and documentation accordingly. Let‚Äôs formalize this plan with a few clear steps to follow.
Plan update
  ‚Üí Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
  ‚Ä¢ Implement seed data & logic (JSON + seed.ts) to satisfy new tests and requirements.
  ‚Ä¢ Document seeding workflow and run relevant checks/tests (TDD green).

thinking
**Planning test improvements for seed data**

I‚Äôm outlining how to modify the seed tests following TDD principles‚Äîfocusing on verifying six playlist items with consistent user, artist, album, and recording data, plus ensuring idempotence and deterministic IDs on re-run. I‚Äôm also considering adding a health check after seeding.
exec
bash -lc 'cat packages/db/src/healthcheck.ts' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { prisma } from './client';

/** Lightweight DB ping for health checks and readiness probes */
export async function dbHealthcheck(): Promise<{ ok: true } | { ok: false; error: string }> {
  try {
    await prisma.$queryRaw`SELECT 1`;
    return { ok: true };
  } catch (e) {
    return { ok: false, error: (e as Error).message };
  }
}

thinking
**Enhancing seeding tests for determinism**

I'm updating tests to run the seed twice and verify that data like users, artists, recordings, and playlist items remain consistent and deterministic. I'll refine queries to include ordering to check item positions and IDs precisely, ensuring no duplicates or unexpected changes after rerunning the seed. This will help confirm the seeding behavior aligns with expectations.
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/seed.test.ts
@@ -31,3 +31,2 @@
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
@@ -35,27 +34,67 @@
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M packages/db/test/seed.test.ts
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Reevaluating test cleanup and sorting expectations**

I'm sifting through whether to keep the database reset after tests since truncation before each test might be enough. I'm spotting a mismatch in expected artist order‚Äîit's sorting by MBID ascending, which actually puts "Boards of Canada" before "Aphex Twin," so I'll fix the expected order accordingly. Also, the test expects six recordings but only has two, fitting TDD's red phase. Next up is running tests to confirm the failure before fixing code.
exec
bash -lc 'cat packages/db/package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "@app/db",
  "private": true,
  "type": "module",
  "scripts": {
    "prisma": "prisma",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0"
  },
  "devDependencies": {
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Checking for test scripts in package.json**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Determining test commands for database**
exec
bash -lc 'pnpm vitest run packages/db/test/seed.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 17.71s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Unhandled Errors [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m
[31m[1m
Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.[22m[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Unhandled Error [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m
[31m[1mError[22m: [vitest-pool]: Worker forks emitted error.[39m
[90m [2m‚ùØ[22m EventEmitter.<anonymous> node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6870:22[22m[39m
[90m [2m‚ùØ[22m EventEmitter.emit node:events:[2m519:28[22m[39m
[90m [2m‚ùØ[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6520:22[22m[39m
[90m [2m‚ùØ[22m ChildProcess.emit node:events:[2m519:28[22m[39m
[90m [2m‚ùØ[22m Process.ChildProcess._handle.onexit node:internal/child_process:[2m293:12[22m[39m

[31m[1mCaused by: Error[22m: Worker exited unexpectedly[39m
[90m [2m‚ùØ[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6519:33[22m[39m
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Investigating test database connection**
exec
bash -lc 'cat packages/db/src/client.ts' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Checking for DATABASE_URL and test database setup**
exec
bash -lc 'rg "DATABASE_URL"' in /var/home/rick/Development/playlist-manager succeeded in 104ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
tasklog_02c_prisma_seeds_1762378977.log:  url      = env("DATABASE_URL")
tasklog_02c_prisma_seeds_1762378977.log:**Checking for DATABASE_URL and test database setup**
tasklog_02c_prisma_seeds_1762378977.log:bash -lc 'rg "DATABASE_URL"' in /var/home/rick/Development/playlist-manager
packages/utils/src/env.ts:  DATABASE_URL: z.string().url(),
packages/db/prisma/schema.prisma:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:bash -lc 'rg "DATABASE_URL" -n' in /var/home/rick/Development/playlist-manager succeeded in 702ms:
tasklog_02b_raw_migrations_1762378467.log:tasklog_02b_raw_migrations_1762378467.log:169:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:tasklog_02b_raw_migrations_1762378467.log:536:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:tasklog_02b_raw_migrations_1762378467.log:576:bash -lc 'rg "DATABASE_URL" -n' in /var/home/rick/Development/playlist-manager
tasklog_02b_raw_migrations_1762378467.log:packages/utils/src/env.ts:4:  DATABASE_URL: z.string().url(),
tasklog_02b_raw_migrations_1762378467.log:packages/db/prisma/schema.prisma:4:  url      = env("DATABASE_URL")
tasklog_02b_raw_migrations_1762378467.log:  DATABASE_URL: z.string().url(),
tasklog_02b_raw_migrations_1762378467.log:# Postgres (Prisma reads from DATABASE_URL)
tasklog_02b_raw_migrations_1762378467.log:DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_dev?schema=public"
tasklog_02b_raw_migrations_1762378467.log:SHADOW_DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tmm_shadow?schema=public"
tasklog_02b_raw_migrations_1762378467.log:bash -lc 'printenv | grep DATABASE_URL || true' in /var/home/rick/Development/playlist-manager succeeded in 95ms:
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Investigating test database setup**
exec
bash -lc 'printenv | grep DATABASE_URL || true' in /var/home/rick/Development/playlist-manager succeeded in 113ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Assessing database setup for tests**
exec
bash -lc 'cat docker-compose.yml' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
version: '3.8'
services:
  db:
    image: postgres:16
    container_name: plmgr-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: playlistmgr
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d playlistmgr"]
      interval: 5s
      timeout: 5s
      retries: 10
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Evaluating database availability for tests**
exec
bash -lc 'cat env.json' in /var/home/rick/Development/playlist-manager succeeded in 51ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
"PROVIDERS_SPOTIFY":"true",
"PROVIDERS_DEEZER":"true",
"PROVIDERS_TIDAL":"true",
"PROVIDERS_YOUTUBE":"true",
"PROVIDERS_AMAZON":"false",
}
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Checking for running Postgres database**
exec
bash -lc 'ss -ltn | grep 5432 || true' in /var/home/rick/Development/playlist-manager succeeded in 93ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
Cannot open netlink socket: Operation not permitted
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Assessing environment restrictions and test dependencies**
exec
bash -lc 'tail -n 200 tasklog_02c_prisma_seeds_1762378977.log' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Analyzing test failures and environment issues**
exec
bash -lc 'which psql || true' in /var/home/rick/Development/playlist-manager succeeded in 91ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/usr/bin/psql
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Testing local PostgreSQL connection**
exec
bash -lc "PGPASSWORD=postgres psql -h 127.0.0.1 -p 5432 -U postgres -d playlistmgr -c 'select 1'" in /var/home/rick/Development/playlist-manager exited 2 in 113ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
psql: error: 
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Starting Postgres container**
exec
bash -lc 'docker compose up -d db' in /var/home/rick/Development/playlist-manager exited 125 in 68ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
Error: acquiring runtime init lock: open /run/user/1000/libpod/tmp/alive.lck: open /run/user/1000/libpod/tmp/alive.lck: permission denied
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Exploring database workaround options**

I'm evaluating ways to run tests without permission to start a real Postgres instance. I‚Äôm considering alternatives like using prisma‚Äôs sqlite option or in-memory DBs like pg-mem, but the schema and provider constraints complicate this. I‚Äôll check existing scripts or prior task logs to see if there‚Äôs a known workaround.
exec
bash -lc "sed -n '1,160p' tasklog_02b_raw_migrations_1762378467.log" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a55f1-4a25-7332-9e7e-39be970959e8
--------
user
Implement the functionality described in codex/TASKS/02b_raw_migrations.yaml, then verify with any available tests.

thinking
**Reviewing migration task instructions**
exec
bash -lc 'cat codex/TASKS/02b_raw_migrations.yaml' in /var/home/rick/Development/playlist-manager succeeded in 120ms:
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Investigating test DB setup challenges**
exec
bash -lc 'which initdb || true' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
which: no initdb in (/home/rick/.local/bin:/home/rick/bin:/tmp/.tmpJKzVFH:/var/home/rick/.npm-packages/lib/node_modules/@openai/codex/vendor/x86_64-unknown-linux-musl/path:/var/home/rick/binary_app_releases/google-cloud-sdk/bin:/home/rick/.bun/bin:/home/rick/.cargo/bin:/home/rick/bin:/usr/local/bin:/usr/local/sbin:/usr/lib64/qt-3.3/bin:/usr/bin:/bin:/usr/sbin:/sbin:/home/rick/bin:/home/rick/.local/bin:/home/rick/bash_scripts:/home/rick/.cargo/bin:/home/rick/.npm-packages/bin:/home/rick/go/bin)
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..7a710b5947c0b0796037aa6abf60ab68bccf2bef
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Aphex Twin',
+    'Boards of Canada',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Handling test environment limitations**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/seed.test.ts
@@ -51,4 +51,4 @@
   expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
     'Aphex Twin',
-    'Boards of Canada',
   ]);
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
M packages/db/test/seed.test.ts
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Adjusting test environment variables**
exec
bash -lc 'DATABASE_URL="postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr?schema=public" pnpm vitest run packages/db/test/seed.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 12.45s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Unhandled Errors [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m
[31m[1m
Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.[22m[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Unhandled Error [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m
[31m[1mError[22m: [vitest-pool]: Worker forks emitted error.[39m
[90m [2m‚ùØ[22m EventEmitter.<anonymous> node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6870:22[22m[39m
[90m [2m‚ùØ[22m EventEmitter.emit node:events:[2m519:28[22m[39m
[90m [2m‚ùØ[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6520:22[22m[39m
[90m [2m‚ùØ[22m ChildProcess.emit node:events:[2m519:28[22m[39m
[90m [2m‚ùØ[22m Process.ChildProcess._handle.onexit node:internal/child_process:[2m293:12[22m[39m

[31m[1mCaused by: Error[22m: Worker exited unexpectedly[39m
[90m [2m‚ùØ[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6519:33[22m[39m
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Diagnosing Vitest worker fork errors**
exec
bash -lc 'DATABASE_URL="postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr?schema=public" pnpm vitest run packages/db/test/seed.test.ts --pool=threads' in /var/home/rick/Development/playlist-manager exited 1 in 2.19s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[90mstdout[2m | packages/db/test/seed.test.ts[2m > [22m[2mrunSeed populates deterministic baseline catalog data
[22m[39mprisma:error 
Invalid `prisma.$executeRawUnsafe()` invocation:


Can't reach database server at `127.0.0.1:5432`

Please make sure your database server is running at `127.0.0.1:5432`.

 [31m‚ùØ[39m packages/db/test/seed.test.ts [2m([22m[2m1 test[22m[2m | [22m[31m1 failed[39m[2m)[22m[32m 102[2mms[22m[39m
[31m   [31m√ó[31m runSeed populates deterministic baseline catalog data[39m[32m 100[2mms[22m[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Failed Tests 1 [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m

[41m[1m FAIL [22m[49m packages/db/test/seed.test.ts[2m > [22mrunSeed populates deterministic baseline catalog data
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Identifying test failure cause**
Plan update
  ‚úì Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
  ‚Üí Implement seed data & logic (JSON + seed.ts) to satisfy new tests and requirements.
  ‚Ä¢ Document seeding workflow and run relevant checks/tests (TDD green).
file update:
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });



thinking
**Designing deterministic seeding with transactions**

I'm laying out a detailed plan to enhance seed.ts for deterministic upserts of users, artists, albums, recordings, and playlist items, ensuring transactional integrity, ordering, and process exit codes. I want to add a new playlist.json for ordered playlist seeding, revise seed-data JSON files with consistent MBIDs and other fields, and ensure idempotency by updating or removing playlist items to exactly match the spec while using Prisma transaction clients correctly.
thinking
**Refactoring playlist seeding with upsert and cleanup**

I'm preparing code to seed playlists inside transactions using a find-or-create approach, cleaning out old playlist items not in the spec, and upserting playlist items by their unique position to enforce deterministic ordering. This includes fetching recordings with albums to link metadata correctly and careful handling of JSON reading and Prisma client typing for consistency.
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -1,2 +1,2 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
@@ -14,3 +14,5 @@
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
@@ -23,3 +25,3 @@
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..0fbc2e29e29fa9f43e167d9ca9b7faeb307a16e3
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..0fbc2e29e29fa9f43e167d9ca9b7faeb307a16e3
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Updating album seeding with optional release ID**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -42,3 +42,3 @@
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
@@ -53,6 +53,16 @@
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
@@ -63,2 +73,3 @@
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..de88c40f7f8ccc06adf20bf6395f41849b5236a1
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..de88c40f7f8ccc06adf20bf6395f41849b5236a1
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Updating recording seed with ISRC**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -88,2 +88,3 @@
     albumTitle: string;
+    isrc?: string | null;
   };
@@ -104,2 +105,3 @@
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
@@ -110,2 +112,3 @@
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..9777411c1d2f0144909b5aba3ac2c7580b8cdbe6
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..9777411c1d2f0144909b5aba3ac2c7580b8cdbe6
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Rewriting seedPlaylist function**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -138,43 +138,94 @@
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..03297bbcfbdab52008a8e1649d33fd8143735cf7
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,47 +136,98 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..03297bbcfbdab52008a8e1649d33fd8143735cf7
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,47 +136,98 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Refactoring seed script with transaction and main function**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -233,13 +233,14 @@
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
@@ -251,11 +252,18 @@
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Updating seed-data JSON files with MBIDs and ISRCs**

I'm preparing detailed updates to the seed-data JSON files to include MusicBrainz IDs and ISRC codes for albums, artists, and recordings. I'll generate or assign realistic UUIDs and identifiers carefully, ensuring the seed playlist aligns with expected positions and the seeding process integrates these new fields consistently.
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed-data/albums.json
@@ -4,3 +4,4 @@
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
@@ -9,3 +10,4 @@
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M packages/db/prisma/seed-data/albums.json
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Updating recordings.json with new entries**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed-data/recordings.json
@@ -6,3 +6,20 @@
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
@@ -13,3 +30,20 @@
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/prisma/seed-data/recordings.json
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing to add playlist.json file**
file update
A /var/home/rick/Development/playlist-manager/packages/db/prisma/seed-data/playlist.json
{
  "name": "Seed Playlist",
  "description": "Deterministic seed playlist for local demos and contract tests.",
  "items": [
    {
      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
      "position": 0
    },
    {
      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
      "position": 1
    },
    {
      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
      "position": 2
    },
    {
      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
      "position": 3
    },
    {
      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
      "position": 4
    },
    {
      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
      "position": 5
    }
  ]
}
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A packages/db/prisma/seed-data/playlist.json
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..492e4eb6a84e4b94e8f464b81445777aba172dab
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBeGreaterThanOrEqual(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Updating test expectations and seed data**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/seed.test.ts
@@ -72,3 +72,3 @@
   });
-  expect(recordings.length).toBeGreaterThanOrEqual(6);
+  expect(recordings.length).toBe(6);
 
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M packages/db/test/seed.test.ts
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..e20b4d5f160ca1dad51ea9c68ca2e567c1c87fda
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..e20b4d5f160ca1dad51ea9c68ca2e567c1c87fda
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,72 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Planning test enhancement for MBID verification**
file update
M /var/home/rick/Development/playlist-manager/packages/db/test/seed.test.ts
@@ -84,2 +84,10 @@
   expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
   const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/db/test/seed.test.ts
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Re-running tests with threads pool**
exec
bash -lc 'DATABASE_URL="postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr?schema=public" pnpm vitest run packages/db/test/seed.test.ts --pool=threads' in /var/home/rick/Development/playlist-manager exited 1 in 3.69s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[90mstdout[2m | packages/db/test/seed.test.ts[2m > [22m[2mrunSeed populates deterministic baseline catalog data
[22m[39mprisma:error 
Invalid `prisma.$executeRawUnsafe()` invocation:


Can't reach database server at `127.0.0.1:5432`

Please make sure your database server is running at `127.0.0.1:5432`.

 [31m‚ùØ[39m packages/db/test/seed.test.ts [2m([22m[2m1 test[22m[2m | [22m[31m1 failed[39m[2m)[22m[32m 56[2mms[22m[39m
[31m   [31m√ó[31m runSeed populates deterministic baseline catalog data[39m[32m 54[2mms[22m[39m

[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m[1m[41m Failed Tests 1 [49m[22m[31m‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[39m

[41m[1m FAIL [22m[49m packages/db/test/seed.test.ts[2m > [22mrunSeed populates deterministic baseline catalog data
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..b238622d0b8afa4715b41d90b6298328f0c0b178
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,113 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
+
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
+
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +250,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Ensuring robust seed data handling**

I'm reviewing the seeding logic to confirm proper use of Prisma and update patterns, especially around `mb_release_id` and `seedArtists`. I'm adding safety checks to guard against missing or malformed `items` arrays in playlist seeds by throwing clear errors before sorting. This will help prevent crashes and improve the reliability of the seeding process.
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -175,2 +175,6 @@
 
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
   const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..e6ef59ec9c49b25767fff4a0d0471c051ecf3b1b
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..e6ef59ec9c49b25767fff4a0d0471c051ecf3b1b
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = sortedItems.map((item) => item.position);
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Ensuring unique allowedPositions**
file update
M /var/home/rick/Development/playlist-manager/packages/db/prisma/seed.ts
@@ -186,3 +186,3 @@
 
-  const allowedPositions = sortedItems.map((item) => item.position);
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/db/prisma/seed.ts
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Verifying database field assignments**
Plan update
  ‚úì Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
  ‚úì Implement seed data & logic (JSON + seed.ts) to satisfy new tests and requirements.
  ‚Üí Document seeding workflow and run relevant checks/tests (TDD green).
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing README for database seeding**
exec
bash -lc "sed -n '1,200p' README.md" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
# playlist-manager

## Spec workflow

We treat `openapi.yaml` as the source of truth for the service contract. Run these commands
before proposing spec changes:

1. `pnpm lint:api` ‚Äì validates the OpenAPI 3.1 document with Redocly.
2. `pnpm gen:types` ‚Äì regenerates `packages/contracts/src/api.types.ts`; rerunning the command
   should yield no diff when the spec and generated file are in sync.
3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
   Optic. The command exits non-zero when it detects a breaking change so you can spot
   incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
file update:
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Adding database seeding instructions**
file update
M /var/home/rick/Development/playlist-manager/README.md
@@ -13 +13,9 @@
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on.
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M README.md
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..665f1c73f9cc0e0546e20eabd6c3e5e1f8dba6f4
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..665f1c73f9cc0e0546e20eabd6c3e5e1f8dba6f4
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Adding database health check instructions**
file update
M /var/home/rick/Development/playlist-manager/README.md
@@ -20,2 +20,2 @@
 reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
-contract tests rely on.
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M README.md
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing test verification and git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 84ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main
 M README.md
 M packages/db/prisma/seed-data/albums.json
 M packages/db/prisma/seed-data/recordings.json
 M packages/db/prisma/seed.ts
 M packages/db/test/seed.test.ts
 M vitest.config.ts
?? codex/TASKS/work_list
?? codex/code/codex/02b_raw_migrations/
?? codex_run_2025-11-05_15-53-33.log
?? codex_run_2025-11-05_15-56-49.log
?? codex_run_2025-11-05_15-58-09.log
?? codex_run_2025-11-05_16-04-53.log
?? codex_run_2025-11-05_16-34-27.log
?? packages/db/prisma/seed-data/playlist.json
?? tasklog_02b_raw_migrations_1762376289.log
?? tasklog_02b_raw_migrations_1762376693.log
?? tasklog_02b_raw_migrations_1762376693.log.done
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Reviewing changes to vitest.config.ts**
exec
bash -lc 'git diff vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/vitest.config.ts b/vitest.config.ts
index 1625657..71e6371 100644
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -6,6 +6,7 @@ export default defineConfig({
       'packages/**/test/**/*.test.ts',
       'packages/**/tests/**/*.test.ts',
       'apps/**/src/**/__tests__/**/*.test.ts',
+      'codex/code/**/tests/**/*.test.ts',
     ],
     testTimeout: 30000,
   },
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing final message details**

I'll gather key file changes and testing context to clearly explain the database seeding updates, the expanded JSON data, and the testing approach. I‚Äôll also note the test run limitations due to the missing database and suggest next steps for verification before wrapping up the plan.
Plan update
  ‚úì Enhance DB seed tests to cover deterministic data, playlist length, and idempotency (TDD red).
  ‚úì Implement seed data & logic (JSON + seed.ts) to satisfy new tests and requirements.
  ‚úì Document seeding workflow and run relevant checks/tests (TDD green).
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing summary of test results and code changes**
exec
bash -lc 'git diff packages/db/prisma/seed.ts' in /var/home/rick/Development/playlist-manager succeeded in 76ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e27..4765005 100644
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@ function readJSON<T>(fileName: string): T {
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing line number references for files**
exec
bash -lc "nl -ba packages/db/prisma/seed.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 93ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { Prisma, PrismaClient } from '@prisma/client';
     2	import fs from 'node:fs';
     3	import path from 'node:path';
     4	import { fileURLToPath, pathToFileURL } from 'node:url';
     5	
     6	const defaultPrisma = new PrismaClient();
     7	const currentDir = path.dirname(fileURLToPath(import.meta.url));
     8	const seedDataDir = path.join(currentDir, 'seed-data');
     9	
    10	function readJSON<T>(fileName: string): T {
    11	  const fullPath = path.join(seedDataDir, fileName);
    12	  return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
    13	}
    14	
    15	type SeedClient = PrismaClient | Prisma.TransactionClient;
    16	
    17	async function upsertUserByEmail(client: SeedClient, email: string) {
    18	  return client.user.upsert({
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Retrieving additional logs**
exec
bash -lc "nl -ba packages/db/prisma/seed.ts | sed -n '200,320p'" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
   200	    const recording = await prisma.recording.findUniqueOrThrow({
   201	      where: { mb_recording_id: item.recordingMbid },
   202	      include: { album: true },
   203	    });
   204	
   205	    await prisma.playlistItem.upsert({
   206	      where: {
   207	        playlist_id_position: {
   208	          playlist_id: playlist.id,
   209	          position: item.position,
   210	        },
   211	      },
   212	      update: {
   213	        position: item.position,
   214	        recording_id: recording.id,
   215	        duration_ms: recording.duration_ms,
   216	        isrc: recording.isrc,
   217	        mb_recording_id: recording.mb_recording_id,
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing to add line numbers**
exec
bash -lc 'nl -ba packages/db/test/seed.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { beforeEach, afterAll, expect, test } from 'vitest';
     2	import { prisma } from '../src/client';
     3	import { runSeed } from '../prisma/seed';
     4	
     5	async function resetDatabase() {
     6	  await prisma.$executeRawUnsafe(`
     7	    TRUNCATE TABLE
     8	      playlist_item,
     9	      provider_track_map,
    10	      provider_playlist_map,
    11	      recording_artist,
    12	      recording,
    13	      album,
    14	      artist_relation,
    15	      artist_link,
    16	      artist_bio,
    17	      artist_follow,
    18	      playlist,
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Preparing line number references**
exec
bash -lc 'nl -ba README.md' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	# playlist-manager
     2	
     3	## Spec workflow
     4	
     5	We treat `openapi.yaml` as the source of truth for the service contract. Run these commands
     6	before proposing spec changes:
     7	
     8	1. `pnpm lint:api` ‚Äì validates the OpenAPI 3.1 document with Redocly.
     9	2. `pnpm gen:types` ‚Äì regenerates `packages/contracts/src/api.types.ts`; rerunning the command
    10	   should yield no diff when the spec and generated file are in sync.
    11	3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    12	   Optic. The command exits non-zero when it detects a breaking change so you can spot
    13	   incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
    14	
    15	## Database seeding
    16	
    17	With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
    18	fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });


thinking
**Summarizing final instructions for message**
codex
Wrapped the Prisma seed in a single transaction, driven entirely by JSON fixtures, so re-runs stay deterministic and cover the full demo catalog (`packages/db/prisma/seed.ts:15`). Expanded the seed data with release IDs, six recordings (with ISRCs), and an explicit playlist order (`packages/db/prisma/seed-data/albums.json:1`, `packages/db/prisma/seed-data/recordings.json:1`, `packages/db/prisma/seed-data/playlist.json:1`). Tightened the seed regression test to assert the exact artist/album catalog and playlist ordering while checking idempotency (`packages/db/test/seed.test.ts:35`). Documented how to run the seed and health check in the project README (`README.md:15`).

Tests:
- `DATABASE_URL="postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr?schema=public" pnpm vitest run packages/db/test/seed.test.ts --pool=threads` *(fails: Prisma cannot reach Postgres at 127.0.0.1:5432 in this environment)*

Next steps:
1. Ensure Postgres is running and migrated, then re-run the Vitest command above.
2. With `DATABASE_URL` set, run `pnpm -F @app/db prisma db seed` followed by `pnpm db:health` to confirm the green path end-to-end.
file update:
diff --git a/README.md b/README.md
index 92e3c20585935c3afb0a28f4230559b451b9c029..499cfad6f9ff4a124815222dcbf6120aaf6e7b35
--- a/README.md
+++ b/README.md
@@ -11,3 +11,11 @@
 3. `pnpm check:breaking` ‚Äì compares the working tree spec against `HEAD:openapi.yaml` with
    Optic. The command exits non-zero when it detects a breaking change so you can spot
    incompatible edits early (set `SPEC_BASE_REF` to diff against another git ref if needed).
+
+## Database seeding
+
+With `DATABASE_URL` pointing at a migrated Postgres instance you can load deterministic
+fixtures by running `pnpm -F @app/db prisma db seed`. The script wraps the Prisma seed in a
+transaction so you can safely run it multiple times; it always upserts the demo user, two
+reference artists/albums, six recordings, and a `Seed Playlist` with track metadata that
+contract tests rely on. Follow-up with `pnpm db:health` to confirm the database is reachable.
diff --git a/packages/db/prisma/seed-data/albums.json b/packages/db/prisma/seed-data/albums.json
index bdaf5a3613140f7a44ce1d6e86a822cb9ed62cd3..8ba7a10965b4eff7396b4ea34b3555fd7bf9798f
--- a/packages/db/prisma/seed-data/albums.json
+++ b/packages/db/prisma/seed-data/albums.json
@@ -2,11 +2,13 @@
   {
     "title": "Music Has the Right to Children",
     "releaseDate": "1998-04-20",
-    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b"
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "mbReleaseId": "e9e7c7ae-7be3-3d56-9716-6dbcfe5d9d7a"
   },
   {
     "title": "Selected Ambient Works 85-92",
     "releaseDate": "1992-11-09",
-    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5"
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "mbReleaseId": "0f1f8c40-3b63-3d7e-b7c0-9ec53fdf3f8f"
   }
 ]
diff --git a/packages/db/prisma/seed-data/playlist.json b/packages/db/prisma/seed-data/playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..22269d8ed7eadec3e8b0448bb4a6f2b586556be7
--- /dev/null
+++ b/packages/db/prisma/seed-data/playlist.json
@@ -0,0 +1,30 @@
+{
+  "name": "Seed Playlist",
+  "description": "Deterministic seed playlist for local demos and contract tests.",
+  "items": [
+    {
+      "recordingMbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
+      "position": 0
+    },
+    {
+      "recordingMbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+      "position": 1
+    },
+    {
+      "recordingMbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+      "position": 2
+    },
+    {
+      "recordingMbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
+      "position": 3
+    },
+    {
+      "recordingMbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+      "position": 4
+    },
+    {
+      "recordingMbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+      "position": 5
+    }
+  ]
+}
diff --git a/packages/db/prisma/seed-data/recordings.json b/packages/db/prisma/seed-data/recordings.json
index 0915c7a5e0998195dc4321b9c8af0096f50162e2..b6e28932263b29dec2efc5fe4e877983ced72de7
--- a/packages/db/prisma/seed-data/recordings.json
+++ b/packages/db/prisma/seed-data/recordings.json
@@ -4,13 +4,47 @@
     "durationMs": 155000,
     "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
     "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
-    "albumTitle": "Music Has the Right to Children"
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800164"
+  },
+  {
+    "title": "Turquoise Hexagon Sun",
+    "durationMs": 342000,
+    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800172"
+  },
+  {
+    "title": "Aquarius",
+    "durationMs": 354000,
+    "mbid": "0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2",
+    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
+    "albumTitle": "Music Has the Right to Children",
+    "isrc": "GBAYE9800111"
   },
   {
     "title": "Xtal",
     "durationMs": 272000,
     "mbid": "f0b8f033-0a23-4d51-9f9a-2ba1d210b040",
     "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
-    "albumTitle": "Selected Ambient Works 85-92"
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200001"
+  },
+  {
+    "title": "Pulsewidth",
+    "durationMs": 246000,
+    "mbid": "c0f01856-6b54-4c45-8729-3a4bc1d4a837",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200005"
+  },
+  {
+    "title": "Ageispolis",
+    "durationMs": 457000,
+    "mbid": "c8a4d5fb-6ad6-4f34-9a1d-99793926ab41",
+    "artistMbid": "a83b5f31-3505-4db9-b1e8-9b6cc53876b5",
+    "albumTitle": "Selected Ambient Works 85-92",
+    "isrc": "GBTDM9200006"
   }
 ]
diff --git a/packages/db/prisma/seed.ts b/packages/db/prisma/seed.ts
index 5701e278fe00838bf206eb94e582ef2e29b3329b..4765005e8e548d6e2b1482bd8d938d856a12b459
--- a/packages/db/prisma/seed.ts
+++ b/packages/db/prisma/seed.ts
@@ -1,4 +1,4 @@
-import { PrismaClient } from '@prisma/client';
+import { Prisma, PrismaClient } from '@prisma/client';
 import fs from 'node:fs';
 import path from 'node:path';
 import { fileURLToPath, pathToFileURL } from 'node:url';
@@ -12,7 +12,9 @@
   return JSON.parse(fs.readFileSync(fullPath, 'utf8')) as T;
 }
 
-async function upsertUserByEmail(client: PrismaClient, email: string) {
+type SeedClient = PrismaClient | Prisma.TransactionClient;
+
+async function upsertUserByEmail(client: SeedClient, email: string) {
   return client.user.upsert({
     where: { email },
     update: {},
@@ -21,7 +23,7 @@
 }
 
 type SeedContext = {
-  prisma: PrismaClient;
+  prisma: SeedClient;
 };
 
 async function seedArtists({ prisma }: SeedContext) {
@@ -38,7 +40,7 @@
 }
 
 async function seedAlbums({ prisma }: SeedContext) {
-  type AlbumRow = { title: string; artistMbid: string };
+  type AlbumRow = { title: string; artistMbid: string; mbReleaseId?: string | null };
   const albums = readJSON<AlbumRow[]>('albums.json');
 
   for (const album of albums) {
@@ -49,16 +51,27 @@
     });
 
     if (existing) {
+      const updates: Prisma.AlbumUpdateInput = {};
+
       if (!existing.primary_artist_id) {
+        updates.primary_artist = { connect: { id: artist.id } };
+      }
+
+      if (album.mbReleaseId && existing.mb_release_id !== album.mbReleaseId) {
+        updates.mb_release_id = album.mbReleaseId;
+      }
+
+      if (Object.keys(updates).length > 0) {
         await prisma.album.update({
           where: { id: existing.id },
-          data: { primary_artist_id: artist.id },
+          data: updates,
         });
       }
     } else {
       await prisma.album.create({
         data: {
           title: album.title,
+          mb_release_id: album.mbReleaseId ?? null,
           primary_artist: { connect: { id: artist.id } },
         },
       });
@@ -73,6 +86,7 @@
     mbid: string;
     artistMbid: string;
     albumTitle: string;
+    isrc?: string | null;
   };
 
   const recordings = readJSON<RecordingRow[]>('recordings.json');
@@ -89,12 +103,14 @@
         title: row.title,
         duration_ms: row.durationMs,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
       create: {
         title: row.title,
         duration_ms: row.durationMs,
         mb_recording_id: row.mbid,
         album_id: album.id,
+        isrc: row.isrc ?? null,
       },
     });
 
@@ -120,61 +136,117 @@
 }
 
 async function seedPlaylist({ prisma }: SeedContext, userId: number) {
-  const playlistTitle = 'Seed Playlist';
+  type PlaylistSeed = {
+    name: string;
+    description?: string | null;
+    items: Array<{
+      recordingMbid: string;
+      position: number;
+    }>;
+  };
+
+  const seed = readJSON<PlaylistSeed>('playlist.json');
+  const playlistName = seed.name;
 
-  const playlistExisting = await prisma.playlist.findFirst({
-    where: { user_id: userId, name: playlistTitle },
+  if (!playlistName) {
+    throw new Error('Playlist seed requires a name');
+  }
+
+  let playlist = await prisma.playlist.findFirst({
+    where: { user_id: userId, name: playlistName },
   });
 
-  const playlist =
-    playlistExisting ??
-    (await prisma.playlist.create({
+  const playlistDescription = seed.description ?? null;
+
+  if (!playlist) {
+    playlist = await prisma.playlist.create({
       data: {
         user_id: userId,
-        name: playlistTitle,
-        description: 'Deterministic seed',
+        name: playlistName,
+        description: playlistDescription,
       },
-    }));
+    });
+  } else if ((playlist.description ?? null) !== playlistDescription) {
+    playlist = await prisma.playlist.update({
+      where: { id: playlist.id },
+      data: { description: playlistDescription },
+    });
+  }
+
+  if (!Array.isArray(seed.items)) {
+    throw new Error('Playlist seed requires an items array');
+  }
+
+  const sortedItems = [...seed.items].sort((a, b) => a.position - b.position);
+
+  if (sortedItems.length === 0) {
+    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
+    return;
+  }
+
+  const allowedPositions = Array.from(new Set(sortedItems.map((item) => item.position)));
 
-  const recordings = await prisma.recording.findMany({
-    orderBy: { id: 'asc' },
-    take: 6,
-    include: { album: true },
+  await prisma.playlistItem.deleteMany({
+    where: {
+      playlist_id: playlist.id,
+      OR: [
+        { position: null },
+        { position: { notIn: allowedPositions } },
+      ],
+    },
   });
 
-  let position = 0;
-  for (const recording of recordings) {
-    const existing = await prisma.playlistItem.findFirst({
-      where: { playlist_id: playlist.id, recording_id: recording.id },
+  for (const item of sortedItems) {
+    const recording = await prisma.recording.findUniqueOrThrow({
+      where: { mb_recording_id: item.recordingMbid },
+      include: { album: true },
     });
 
-    if (!existing) {
-      await prisma.playlistItem.create({
-        data: {
+    await prisma.playlistItem.upsert({
+      where: {
+        playlist_id_position: {
           playlist_id: playlist.id,
-          recording_id: recording.id,
-          position: position++,
-          duration_ms: recording.duration_ms,
-          isrc: recording.isrc,
-          mb_recording_id: recording.mb_recording_id,
-          mb_release_id: recording.album?.mb_release_id,
+          position: item.position,
         },
-      });
-    }
+      },
+      update: {
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+        provider_track_id: null,
+        snapshot_album: null,
+        snapshot_artists: null,
+        snapshot_title: null,
+        snapshot_expires_at: null,
+      },
+      create: {
+        playlist_id: playlist.id,
+        position: item.position,
+        recording_id: recording.id,
+        duration_ms: recording.duration_ms,
+        isrc: recording.isrc,
+        mb_recording_id: recording.mb_recording_id,
+        mb_release_id: recording.album?.mb_release_id ?? null,
+      },
+    });
   }
 }
 
+const SEED_USER_EMAIL = 'demo@playlist-manager.local';
+
 export async function runSeed(prisma: PrismaClient = defaultPrisma) {
-  // ---- 0) Deterministic user
-  const user = await upsertUserByEmail(prisma, 'demo@playlist-manager.local');
+  return prisma.$transaction(async (tx) => {
+    const user = await upsertUserByEmail(tx, SEED_USER_EMAIL);
 
-  await seedArtists({ prisma });
-  await seedAlbums({ prisma });
-  await seedRecordings({ prisma });
-  await seedPlaylist({ prisma }, user.id);
+    await seedArtists({ prisma: tx });
+    await seedAlbums({ prisma: tx });
+    await seedRecordings({ prisma: tx });
+    await seedPlaylist({ prisma: tx }, user.id);
 
-  console.log('‚úÖ Seed complete:', {
-    user: user.email,
+    return { userEmail: user.email };
   });
 }
 
@@ -182,13 +254,20 @@
   process.argv[1] &&
   pathToFileURL(path.resolve(process.argv[1])).href === import.meta.url;
 
+async function main() {
+  try {
+    const { userEmail } = await runSeed(defaultPrisma);
+    console.log('‚úÖ Seed complete:', { user: userEmail });
+    await defaultPrisma.$disconnect();
+    process.exit(0);
+  } catch (error) {
+    console.error('‚ùå Seed failed');
+    console.error(error);
+    await defaultPrisma.$disconnect();
+    process.exit(1);
+  }
+}
+
 if (executedDirectly) {
-  runSeed()
-    .then(() => defaultPrisma.$disconnect())
-    .catch((error) => {
-      console.error(error);
-      return defaultPrisma
-        .$disconnect()
-        .finally(() => process.exit(1));
-    });
+  main();
 }
diff --git a/packages/db/test/seed.test.ts b/packages/db/test/seed.test.ts
index 5bf0987374cbce6e481b17ae8212bad401930571..718731fbf01b8503c5c0f9574b00eb6673ff6047
--- a/packages/db/test/seed.test.ts
+++ b/packages/db/test/seed.test.ts
@@ -29,33 +29,80 @@
 });
 
 afterAll(async () => {
-  await resetDatabase();
   await prisma.$disconnect();
 });
 
-test('runSeed populates baseline catalog data', async () => {
+test('runSeed populates deterministic baseline catalog data', async () => {
+  const user = await prisma.user.findUnique({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(user).toBeNull();
+
   await runSeed(prisma);
 
-  const artist = await prisma.artist.findUnique({
-    where: { mbid: 'a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b' },
+  const seededUser = await prisma.user.findUniqueOrThrow({
+    where: { email: 'demo@playlist-manager.local' },
+  });
+  expect(seededUser.id).toBeGreaterThan(0);
+
+  const artists = await prisma.artist.findMany({
+    orderBy: { mbid: 'asc' },
   });
-  expect(artist).not.toBeNull();
+  expect(artists.map((a) => a.name)).toEqual([
+    'Boards of Canada',
+    'Aphex Twin',
+  ]);
 
-  const album = await prisma.album.findFirst({
-    where: { title: 'Music Has the Right to Children' },
+  const albumTitles = await prisma.album.findMany({
     include: { primary_artist: true },
+    orderBy: { title: 'asc' },
   });
-  expect(album?.primary_artist?.name).toBe('Boards of Canada');
+  expect(
+    albumTitles.map((album) => ({
+      title: album.title,
+      artist: album.primary_artist?.name,
+    })),
+  ).toEqual([
+    { title: 'Music Has the Right to Children', artist: 'Boards of Canada' },
+    { title: 'Selected Ambient Works 85-92', artist: 'Aphex Twin' },
+  ]);
 
-  const recording = await prisma.recording.findUnique({
-    where: { mb_recording_id: '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f' },
-    include: { artists: true },
+  const recordings = await prisma.recording.findMany({
+    orderBy: { mb_recording_id: 'asc' },
   });
-  expect(recording?.artists.length).toBeGreaterThan(0);
+  expect(recordings.length).toBe(6);
 
-  const playlist = await prisma.playlist.findFirst({
-    where: { name: 'Seed Playlist' },
-    include: { items: true },
+  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
+    where: { name: 'Seed Playlist', user_id: seededUser.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
   });
-  expect(playlist?.items.length).toBeGreaterThan(0);
+  expect(playlistFirstRun.items.length).toBe(6);
+  expect(playlistFirstRun.items.map((item) => item.position)).toEqual([0, 1, 2, 3, 4, 5]);
+  expect(playlistFirstRun.items.map((item) => item.mb_recording_id)).toEqual([
+    '91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f',
+    '4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa',
+    '0a2ab4c1-2d9b-4ff4-9d8f-1f1e1c1f4db2',
+    'f0b8f033-0a23-4d51-9f9a-2ba1d210b040',
+    'c0f01856-6b54-4c45-8729-3a4bc1d4a837',
+    'c8a4d5fb-6ad6-4f34-9a1d-99793926ab41',
+  ]);
+  const playlistItemIds = playlistFirstRun.items.map((item) => item.id);
+
+  await runSeed(prisma);
+
+  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
+    where: { id: playlistFirstRun.id },
+    include: {
+      items: {
+        orderBy: { position: 'asc' },
+      },
+    },
+  });
+
+  expect(playlistSecondRun.items.map((item) => item.id)).toEqual(playlistItemIds);
+  expect(playlistSecondRun.items.length).toBe(6);
 });

tokens used
314,714
Wrapped the Prisma seed in a single transaction, driven entirely by JSON fixtures, so re-runs stay deterministic and cover the full demo catalog (`packages/db/prisma/seed.ts:15`). Expanded the seed data with release IDs, six recordings (with ISRCs), and an explicit playlist order (`packages/db/prisma/seed-data/albums.json:1`, `packages/db/prisma/seed-data/recordings.json:1`, `packages/db/prisma/seed-data/playlist.json:1`). Tightened the seed regression test to assert the exact artist/album catalog and playlist ordering while checking idempotency (`packages/db/test/seed.test.ts:35`). Documented how to run the seed and health check in the project README (`README.md:15`).

Tests:
- `DATABASE_URL="postgresql://postgres:postgres@127.0.0.1:5432/playlistmgr?schema=public" pnpm vitest run packages/db/test/seed.test.ts --pool=threads` *(fails: Prisma cannot reach Postgres at 127.0.0.1:5432 in this environment)*

Next steps:
1. Ensure Postgres is running and migrated, then re-run the Vitest command above.
2. With `DATABASE_URL` set, run `pnpm -F @app/db prisma db seed` followed by `pnpm db:health` to confirm the green path end-to-end.
