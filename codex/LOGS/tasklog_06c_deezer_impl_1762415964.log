OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a582d-89da-78a3-8854-1cc5d4bf8535
--------
user
Implement the functionality described in codex/TASKS/06c_deezer_impl.yaml, then verify with any available tests.

thinking
**Preparing to examine task file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/playlist-manager succeeded in 50ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
00_repo_sanity_review.yaml
01a_spec_bootstrap.yaml
02a_prisma_init.yaml
02b_raw_migrations.yaml
02c_prisma_seeds.yaml
02d_db_indexes_bench.yaml
03a_dbpkg_singleton.yaml
03b_db_migration_ci_gate.yaml
03c_token_encryption_at_rest.yaml
04a_api_validation_wiring.yaml
04b_openapi_warning_silencer.yaml
04c_api_docs_ui.yaml
04d_config_feature_flags.yaml
05a_pif_validator.yaml
05b_file_exporters.yaml
05c_importers_file.yaml
06a_provider_interfaces.yaml
06b_spotify_impl.yaml

thinking
**Opening YAML file**
exec
bash -lc 'cat codex/TASKS/06c_deezer_impl.yaml' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 06c_deezer_impl
title: Deezer importer/exporter (mocked HTTP) to/from PIF
branch: codex/06c_deezer_impl
overview: >
  Implement Deezer Importer/Exporter using the contracts from packages/contracts/src/providers.ts.
  Read a playlist -> PIF, write PIF -> created playlist. Handle paging/batching and 429 backoff (unit-tested).
acceptance:
  - Tests in codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts pass:
    * importer maps items with ISRC when present (track.isrc), else title/artist/duration fallback.
    * exporter creates a playlist and adds tracks in batches; respects 429 Retry-After.
artifacts_to_touch:
  - packages/providers/deezer/src/index.ts
  - packages/providers/deezer/src/deezer.client.ts
  - codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
  - codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
constraints:
  - No real HTTP. Use nock for deezer API base (https://api.deezer.com/*).
  - Keep batch size configurable; default 100.

thinking
**Preparing for test-driven implementation**
exec
bash -lc 'ls packages/providers/deezer/src' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
index.ts

thinking
**Checking a file**
exec
bash -lc 'cat packages/providers/deezer/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class Deezer implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'deezer';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');

thinking
**Preparing to implement client code**
exec
bash -lc 'rg "ProviderImpl" -n packages/contracts/src' in /var/home/rick/Development/playlist-manager succeeded in 196ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/contracts/src/providers.ts:93:export type ProviderImpl = Importer & Exporter;
exec
bash -lc "sed -n '1,200p' packages/contracts/src/providers.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// packages/contracts/src/providers.ts

/** Canonical provider IDs used across the app & OpenAPI spec */
export type ProviderName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

/** Minimal PIF v1 types (keep in sync with /schemas/pif-v1.schema.json) */
export interface PIF {
  name: string;
  description?: string | null;
  source_service?: ProviderName | 'amazon' | null;
  source_playlist_id?: string | null;
  tracks: PIFTrack[];
}

export interface PIFTrack {
  position: number;                // 1-based
  title: string;
  artists: string[];               // primary first; features after

thinking
**Examining existing provider implementations**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
core
deezer
file-exporters
spotify
tidal
youtube

thinking
**Checking Spotify provider folder**
exec
bash -lc 'ls packages/providers/spotify/src' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
index.ts
spotify.client.ts

thinking
**Checking index file**
exec
bash -lc "sed -n '1,200p' packages/providers/spotify/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  BackoffOptions,
  Exporter,
  Importer,
  PIF,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';
import { RateLimitError } from '@app/contracts';

import {
  SpotifyClient,
  type SpotifyPlaylist,
  type SpotifyPlaylistItem,
exec
bash -lc "sed -n '200,400p' packages/providers/spotify/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
      added += batch.length;
    }

    const report: WritePlaylistResult['report'] = {
      attempted: uris.length,
      added,
      failed: uris.length - added,
    };

    if (skipped > 0) {
      report.skipped = skipped;
      report.notes = [`${skipped} track(s) missing spotify_track_id`];
    }

    return {
      destId: created.id,
      report,
    };

thinking
**Noticing error patterns in Spotify client**
exec
bash -lc "sed -n '1,200p' packages/providers/spotify/src/spotify.client.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { RateLimitError } from '@app/contracts';

export interface SpotifyClientOptions {
  token: string;
  baseUrl?: string;
}

export interface SpotifyUserProfile {
  id: string;
}

export interface SpotifyArtist {
  name: string;
}

export interface SpotifyAlbum {
  name?: string | null;
  release_date?: string | null;

thinking
**Planning adaptation for Deezer**
exec
bash -lc "sed -n '1,200p' codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 58ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
sed: can't read codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts: No such file or directory

thinking
**Checking for existing tests**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Preparing to investigate further**
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces
06b_spotify_impl

thinking
**Preparing to add tests for 06c**
exec
bash -lc 'ls codex/code/codex/06b_spotify_impl/tests' in /var/home/rick/Development/playlist-manager succeeded in 58ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
fixtures
spotify.impl.test.ts

thinking
**Reviewing test style**
exec
bash -lc "sed -n '1,200p' codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 62ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import nock from 'nock';
import path from 'node:path';
import { readFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import Spotify from '../../../../../packages/providers/spotify/src/index.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const loadFixture = (name: string) =>
  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));

describe('Spotify provider integration', () => {
  const baseUrl = 'https://api.spotify.com';

  beforeEach(() => {

thinking
**Planning test creation**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager succeeded in 57ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
http
index.ts
match
types.ts

thinking
**Inspecting existing HTTP client code**
exec
bash -lc 'ls packages/providers/core/src/http' in /var/home/rick/Development/playlist-manager succeeded in 62ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
client.ts
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/http/client.ts" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export type HttpMethod = 'GET'|'POST'|'PUT'|'PATCH'|'DELETE';

export interface HttpClientOptions {
  baseUrl: string;
  headers?: Record<string, string>;
  getAuthHeader?: () => Promise<string | undefined>;
  retries?: number;
  retryBaseMs?: number;
}

function sleep(ms: number) { return new Promise((r) => setTimeout(r, ms)); }

export class HttpClient {
  constructor(private opts: HttpClientOptions) {}

  async request<T>(method: HttpMethod, url: string, init?: RequestInit): Promise<T> {
    const { retries = 3, retryBaseMs = 300 } = this.opts;
    let attempt = 0;

thinking
**Planning Deezer client implementation with tests**

I'll create a multi-step plan following TDD: first review specs and create failing tests, then implement Deezer client with auth header and fixtures, run tests to verify, and finally commit the changes automatically with a proper message.
Plan update
  → Add Deezer provider tests and fixtures per task spec to capture expected behaviour (failing initially).
  • Implement Deezer client and importer/exporter to satisfy tests (paging, batching, retry).
  • Run targeted tests, ensure green, then commit changes with descriptive message.

thinking
**Creating test directory**
exec
bash -lc 'mkdir -p codex/code/codex/06c_deezer_impl/tests/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 89ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Preparing detailed test file with fixtures and backoff handling**

I'm setting up a new test file for Deezer implementation, carefully designing fixtures to mock playlist and track data. I'll align with the spec by including both importer and exporter tests, especially to cover 429 rate-limiting and backoff logic using fake timers if needed. I want to make sure TypeScript imports are correct and create minimal Deezer API response fixtures for comprehensive mapping and batching behavior verification.
exec
bash -lc 'rg "env-driven" -n' in /var/home/rick/Development/playlist-manager succeeded in 3.74s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:349:bash -lc 'rg "env-driven" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/06c_deezer_impl.yaml:53:  - Add env-driven batch size and max retries (defaults inside class).
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:68:  • Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:758:  • Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:769:  • Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1779:  • Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:3128:  → Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:7928:  ✓ Implement env-driven feature flags and middleware updates to satisfy tests
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:15140:  ✓ Implement env-driven feature flags and middleware updates to satisfy tests

thinking
**Searching for environment configuration**
exec
bash -lc 'rg "batch" packages/providers -n | head' in /var/home/rick/Development/playlist-manager succeeded in 118ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/spotify/src/index.ts:40:const normalizeBatchSize = (batchSize: number | undefined): number => {
packages/providers/spotify/src/index.ts:41:  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
packages/providers/spotify/src/index.ts:44:  return Math.trunc(batchSize);
packages/providers/spotify/src/index.ts:175:    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
packages/providers/spotify/src/index.ts:197:    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
packages/providers/spotify/src/index.ts:198:      const batch = uris.slice(cursor, cursor + batchSize);
packages/providers/spotify/src/index.ts:199:      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
packages/providers/spotify/src/index.ts:200:      added += batch.length;

thinking
**Searching for environment variable usage**
exec
bash -lc "rg \"process\\.env\" packages/providers/deezer -n" in /var/home/rick/Development/playlist-manager exited 1 in 52ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Preparing Deezer integration tests and fixtures**

I’m mapping out test setup for Deezer’s importer and exporter, planning fixtures for playlist data and creation responses. I’ll align method calls with actual signatures (using string IDs), match import paths similar to Spotify tests, and design nock interceptors for HTTP mocking—including retry logic on 429 errors. I’ll also handle contributor fallback logic in fixtures and prepare tests for batching behavior and authorization handling. Creating tests first before implementation will help drive this integration steadily.
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
import { afterEach, beforeEach, expect, test, vi } from 'vitest';
import nock from 'nock';

import Deezer from '../../../../../packages/providers/deezer/src/index.ts';

import playlistFixture from './fixtures/deezer.playlist.json';
import createdFixture from './fixtures/deezer.created.json';

const baseUrl = 'https://api.deezer.com';

beforeEach(() => {
  nock.disableNetConnect();
});

afterEach(() => {
  nock.cleanAll();
  nock.enableNetConnect();
  vi.useRealTimers();
});

test('importer maps Deezer playlist tracks into PIF', async () => {
  const provider = new Deezer({ token: 'test-token' });

  const playlistId = '1234';

  nock(baseUrl)
    .get(`/playlist/${playlistId}`)
    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
    .get(`/playlist/${playlistId}/tracks`)
    .query({ limit: '50', index: '0' })
    .reply(200, playlistFixture);

  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });

  expect(result).toMatchObject({
    name: 'DX',
    description: 'deezer mix',
    source_service: 'deezer',
    source_playlist_id: playlistId,
  });
  expect(result.tracks).toHaveLength(2);
  expect(result.tracks[0].isrc).toBe('USABC1200001');
  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
  expect(result.tracks[1].title).toBeTruthy();
});

test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
  vi.useFakeTimers();

  const provider = new Deezer({ token: 'test-token' });
  const playlistId = createdFixture.id;

  const tracks = Array.from({ length: 205 }, (_, i) => ({
    position: i + 1,
    title: `Track ${i + 1}`,
    artists: ['Artist'],
    duration_ms: 180000,
    provider_ids: { deezer_track_id: `dz_${i + 1}` },
  }));

  const pif = {
    name: 'DX out',
    tracks,
  };

  nock(baseUrl)
    .post('/user/me/playlists', (body) => body?.title === 'DX out')
    .reply(200, createdFixture);

  const addScope = nock(baseUrl)
    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
    .reply(200, { success: true })
    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
    .reply(200, { success: true })
    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
    .reply(200, { success: true });

  const pending = provider.writePlaylist(pif);

  await vi.advanceTimersByTimeAsync(1000);
  const result = await pending;

  expect(result.destId).toBe(playlistId);
  expect(result.report).toMatchObject({
    attempted: 205,
    added: 205,
    failed: 0,
  });

  expect(addScope.isDone()).toBe(true);
});
apply_patch(auto_approved=true) exited 0 in 135ms:
Success. Updated the following files:
A codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});


thinking
**Adding test fixture for Deezer playlist**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
{
  "data": [
    {
      "id": "901",
      "title": "Eclipse",
      "duration": 215,
      "explicit_lyrics": false,
      "isrc": "USABC1200001",
      "link": "https://www.deezer.com/track/901",
      "artist": {
        "id": "111",
        "name": "Aurora Duo"
      },
      "contributors": [
        { "id": "111", "name": "Aurora Duo" },
        { "id": "112", "name": "Solar Keys" }
      ],
      "album": {
        "id": "301",
        "title": "Skyline",
        "cover": "https://cdn.test/cover.jpg",
        "release_date": "2023-07-14"
      }
    },
    {
      "id": "902",
      "title": "Mirage",
      "duration": 189,
      "explicit_lyrics": true,
      "isrc": null,
      "link": "https://www.deezer.com/track/902",
      "artist": {
        "id": "113",
        "name": "Neon Pulse"
      },
      "contributors": [
        { "id": "113", "name": "Neon Pulse" }
      ],
      "album": {
        "id": "302",
        "title": "Desert Bloom",
        "cover": "https://cdn.test/cover2.jpg",
        "release_date": "2022-04-22"
      }
    }
  ],
  "total": 2,
  "next": null
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Adding new JSON file**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
{
  "id": "pz9",
  "title": "DX out",
  "link": "https://www.deezer.com/playlist/pz9"
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Reviewing type usage in tests**
exec
bash -lc 'ls packages/contracts/src' in /var/home/rick/Development/playlist-manager succeeded in 122ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
api.types.ts
constants.ts
index.ts
pif.ts
providers.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82971df6bb30b4a1a63489ee48f5f75a56750058
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,93 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  };
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Adjusting type imports and test queries**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -3,2 +3,3 @@
 
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
 import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
@@ -63,3 +64,3 @@
     tracks,
-  };
+  } satisfies PIF;
 
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Verifying test setup and commands**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Preparing to run targeted tests**
Plan update
  ✓ Add Deezer provider tests and fixtures per task spec to capture expected behaviour (failing initially).
  → Implement Deezer client and importer/exporter to satisfy tests (paging, batching, retry).
  • Run targeted tests, ensure green, then commit changes with descriptive message.
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Running initial tests to confirm failure**
exec
bash -lc 'pnpm vitest run codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.56s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

(node:453943) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 2)
(Use `node --trace-warnings ...` to show where the warning was created)
 ❯ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests | 2 failed) 13ms
   × importer maps Deezer playlist tracks into PIF 7ms
     → NIY
   × exporter creates playlist then batches track adds with Retry-After respect 4ms
     → NIY

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts > importer maps Deezer playlist tracks into PIF
Error: NIY
 ❯ Deezer.readPlaylist packages/providers/deezer/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Designing Deezer client architecture**

I'm planning to build a `DeezerClient` with GET/POST methods and 429 retry handling based on `Retry-After` headers. It will support auth headers, JSON parsing, configurable base URLs, max retries from environment variables, and core playlist-related methods matching expected request formats and tests. I'll keep async retrying compatible with testing timers. Next, I'll check repo patterns for naming env vars.
exec
bash -lc 'rg "DEEZER" -n' in /var/home/rick/Development/playlist-manager succeeded in 636ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
env.json:3:"PROVIDERS_DEEZER":"true",
apps/worker/src/providers/config.ts:7:  deezer:  envBool(process.env.PROVIDERS_DEEZER  ?? 'true'),
codex/TASKS/06f_provider_factory_tests.yaml:57:        process.env.PROVIDERS_DEEZER  = 'true';
apps/api/src/config/flags.ts:9:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
apps/api/src/routes/__tests__/auth.providers.test.ts:12:  delete process.env.PROVIDERS_DEEZER_ENABLED;
apps/api/src/routes/__tests__/auth.providers.test.ts:73:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
apps/api/src/routes/__tests__/auth.providers.test.ts:98:    process.env.PROVIDERS_DEEZER_ENABLED = 'true';
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:2503:bash -lc 'rg "DEEZER" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_03a_dbpkg_singleton_1762387258.log:362:"PROVIDERS_DEEZER":"true",
codex/LOGS/tasklog_03a_dbpkg_singleton_1762387258.log:542:PROVIDERS_DEEZER=true
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:1449:"PROVIDERS_DEEZER":"true",
codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:371:"PROVIDERS_DEEZER":"true",
codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:409:PROVIDERS_DEEZER=true
codex/LOGS/tasklog_03c_token_encryption_at_rest_1762393669.log:678:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:108:    deezer:  bool(process.env.PROVIDERS_DEEZER_ENABLED, false),
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1588:+PROVIDERS_DEEZER_ENABLED="false"
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1606:+PROVIDERS_DEEZER_ENABLED="false"
codex/LOGS/tasklog_04d_config_feature_flags_1762396882.log:1695:+PROVIDERS_DEEZER_ENABLED="false"
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Checking environment variable usage patterns**
exec
bash -lc 'rg "BATCH_SIZE" packages/providers -n' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/spotify/src/index.ts:24:const DEFAULT_BATCH_SIZE = 100;
packages/providers/spotify/src/index.ts:42:    return DEFAULT_BATCH_SIZE;
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Considering environment variable naming**
exec
bash -lc 'cat codex/TASKS/06b_spotify_impl.yaml' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 06b_spotify_impl
title: Spotify importer/exporter (mocked HTTP) to/from PIF
branch: codex/06b_spotify_impl
overview: >
  Implement Spotify Importer/Exporter with network mocked via nock. Focus on: read playlist → PIF, write PIF → created playlist.
acceptance:
  - Tests in codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts pass:
    * importer maps items (with ISRC when available) into PIF.
    * exporter creates a playlist and adds tracks in batches.
artifacts_to_touch:
  - packages/providers/spotify/src/index.ts
  - packages/providers/spotify/src/spotify.client.ts
  - fixtures under codex/code/codex/06b_spotify_impl/tests/fixtures/*
constraints:
  - No real tokens; use nock fixtures resembling Spotify Web API responses.
steps:
  - Build tiny client wrapper; implement read/write using endpoints for playlists & tracks.
  - Map external_ids.isrc → track.isrc; fallback to title/artist/duration.
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Planning DeezerClient implementation details**

I’m mapping out how to implement DeezerClient with playlist metadata and track fetching, including pagination and detailed track mapping. I’m also considering batch options driven by environment variables, focusing on clean parsing and deferring environment reads to class initialization to keep tests easier. Let’s explore helpers for env parsing next.
exec
bash -lc 'rg "envInt" -n' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:3068:bash -lc 'rg "envInt" -n' in /var/home/rick/Development/playlist-manager
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}


thinking
**Searching for envNumber helper**
exec
bash -lc 'rg "envNumber" -n' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:3242:**Searching for envNumber helper**
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:3244:bash -lc 'rg "envNumber" -n' in /var/home/rick/Development/playlist-manager
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}




thinking
**Designing Deezer client and provider with env-configured retry and batch settings**

I’m outlining the Deezer client to handle token auth, 429 retries with `Retry-After` parsing, and a `sleep` helper for backoff. The provider will accept batch size and max retries from environment variables or options, ensuring tests can override these. I’m planning pagination logic for reading playlists and batch-processing tracks for writing, carefully handling missing Deezer IDs by skipping them. The design aims to smoothly integrate retries at the client level so the provider doesn’t need special retry logic. Overall, I’m setting up the core interfaces, API calls, and helper utilities to match the provided specs and test expectations.
thinking
**Specifying DeezerClient methods and playlist mapping**

I’m detailing DeezerClient’s API methods with proper typing and URL building, ensuring requests include auth headers and handle 429 retries with backoff. I’m also defining track and playlist interfaces to map Deezer’s data to internal PIF structures, including careful processing of artists, durations, positions, and optional fields. Pagination will loop safely to collect all tracks, and playlist metadata and tracks will combine into a full playlist object. Everything aligns with test expectations for request formats and response handling.
thinking
**Refining playlist track mapping and batch processing**

I’m making sure mapped tracks keep sequential positions by pushing only defined mappings and adjusting position by current array length. For fetching all tracks, I’m handling paging via index and total, looping safely with limits and next checks. The playlist writing method batches track additions using a configurable batch size with sensible defaults from env or options, tracking skipped tracks and reporting counts. Parsing and fallback logic for batch size and retry counts are also set up carefully to ensure robust retries and rate-limit handling in requests.
file update
A /var/home/rick/Development/playlist-manager/packages/providers/deezer/src/deezer.client.ts
import { RateLimitError } from '@app/contracts';

export interface DeezerClientOptions {
  token: string;
  baseUrl?: string;
  retries?: number;
}

export interface DeezerPlaylistMetadata {
  id?: string | number;
  title?: string | null;
  description?: string | null;
  nb_tracks?: number | null;
}

export interface DeezerArtist {
  id?: string | number;
  name?: string | null;
}

export interface DeezerAlbum {
  id?: string | number;
  title?: string | null;
  release_date?: string | null;
}

export interface DeezerTrack {
  id?: string | number;
  title?: string | null;
  title_short?: string | null;
  duration?: number | null;
  explicit_lyrics?: boolean | null;
  isrc?: string | null;
  artist?: DeezerArtist | null;
  contributors?: DeezerArtist[] | null;
  album?: DeezerAlbum | null;
}

export interface DeezerTrackPage {
  data: DeezerTrack[];
  total?: number | null;
  next?: string | null;
}

const defaultBaseUrl = 'https://api.deezer.com';

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const parseRetryAfter = (value: string | null): number | undefined => {
  if (!value) return undefined;
  const numeric = Number(value);
  if (Number.isFinite(numeric)) {
    return Math.max(0, numeric) * 1000;
  }
  const parsedDate = Date.parse(value);
  if (!Number.isNaN(parsedDate)) {
    return Math.max(0, parsedDate - Date.now());
  }
  return undefined;
};

const normalizeRetries = (retries: number | undefined): number => {
  if (retries === undefined || retries === null) return 3;
  if (Number.isNaN(retries) || retries < 0) return 3;
  return Math.trunc(retries);
};

export class DeezerClient {
  private readonly baseUrl: string;
  private readonly retries: number;

  constructor(private readonly options: DeezerClientOptions) {
    if (!options?.token) {
      throw new Error('Deezer token is required');
    }
    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
    this.retries = normalizeRetries(options.retries);
  }

  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
    const url = new URL(path, `${this.baseUrl}/`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value === undefined || value === null) continue;
        url.searchParams.set(key, String(value));
      }
    }
    return url.toString();
  }

  private async request<T>(
    method: 'GET' | 'POST',
    path: string,
    options?: {
      body?: unknown;
      query?: Record<string, string | number | undefined>;
    },
  ): Promise<T> {
    const url = this.buildUrl(path, options?.query);

    let attempt = 0;
    while (true) {
      const headers: Record<string, string> = {
        authorization: `Bearer ${this.options.token}`,
      };
      const init: RequestInit = { method, headers };
      if (options?.body !== undefined) {
        headers['content-type'] = 'application/json';
        init.body = JSON.stringify(options.body);
      }

      const response = await fetch(url, init);

      if (response.status === 429) {
        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
        if (attempt >= this.retries) {
          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
        }
        attempt += 1;
        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
        continue;
      }

      if (!response.ok) {
        const message = await response.text().catch(() => response.statusText);
        throw new Error(`Deezer API ${response.status}: ${message}`);
      }

      if (response.status === 204) {
        return undefined as T;
      }

      const text = await response.text();
      if (!text) {
        return undefined as T;
      }

      try {
        return JSON.parse(text) as T;
      } catch {
        return undefined as T;
      }
    }
  }

  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
    const encoded = encodeURIComponent(id);
    return this.request('GET', `/playlist/${encoded}`);
  }

  getPlaylistTracks(
    id: string,
    opts: { index: number; limit: number },
  ): Promise<DeezerTrackPage> {
    const encoded = encodeURIComponent(id);
    return this.request('GET', `/playlist/${encoded}/tracks`, {
      query: {
        limit: opts.limit,
        index: opts.index,
      },
    });
  }

  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
    return this.request('POST', '/user/me/playlists', { body: payload });
  }

  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
    const encoded = encodeURIComponent(playlistId);
    return this.request('POST', `/playlist/${encoded}/tracks`, {
      body: { songs: trackIds },
    });
  }
}
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
A packages/providers/deezer/src/deezer.client.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}


thinking
**Implementing Deezer index.ts functions**
file update
D /var/home/rick/Development/playlist-manager/packages/providers/deezer/src/index.ts
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class Deezer implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'deezer';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');
  }

  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
    throw new Error('NIY');
  }
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
D packages/providers/deezer/src/index.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
deleted file mode 100644
index e055d176eee07e38acef2c33270204d1d4d1ef0f..0000000000000000000000000000000000000000
--- a/packages/providers/deezer/src/index.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Deezer implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'deezer';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
deleted file mode 100644
index e055d176eee07e38acef2c33270204d1d4d1ef0f..0000000000000000000000000000000000000000
--- a/packages/providers/deezer/src/index.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Deezer implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'deezer';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}


thinking
**Adding new content**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/deezer/src/index.ts
import type {
  Exporter,
  Importer,
  PIF,
  PIFTrack,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

import {
  DeezerClient,
  type DeezerTrack,
} from './deezer.client.ts';

type Milliseconds = number;

const DEFAULT_PAGE_SIZE = 100;
const DEFAULT_BATCH_SIZE = 100;
const DEFAULT_MAX_RETRIES = 3;

const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
  if (value === undefined || value === null) return undefined;
  const numeric = typeof value === 'number' ? value : Number(value);
  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
  return Math.trunc(numeric);
};

const normalizePageSize = (pageSize: number | undefined): number => {
  const parsed = parsePositiveInt(pageSize);
  if (!parsed) return DEFAULT_PAGE_SIZE;
  return Math.min(parsed, 100);
};

const dedupe = (items: string[]): string[] => {
  const seen = new Set<string>();
  const unique: string[] = [];
  for (const item of items) {
    const trimmed = item?.trim();
    if (!trimmed) continue;
    if (seen.has(trimmed)) continue;
    seen.add(trimmed);
    unique.push(trimmed);
  }
  return unique;
};

const extractArtists = (track: DeezerTrack): string[] => {
  const candidates: string[] = [];
  if (track.artist?.name) {
    candidates.push(track.artist.name);
  }
  if (Array.isArray(track.contributors)) {
    for (const contributor of track.contributors) {
      if (contributor?.name) {
        candidates.push(contributor.name);
      }
    }
  }
  return dedupe(candidates);
};

const toMilliseconds = (value: number | string | null | undefined): number | null => {
  if (value === undefined || value === null) return null;
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) return null;
  return Math.max(0, Math.round(numeric * 1000));
};

const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
  if (!next) return fallback;
  try {
    const url = new URL(next);
    const raw = url.searchParams.get('index');
    if (raw !== null) {
      const numeric = Number(raw);
      if (Number.isFinite(numeric) && numeric >= 0) {
        return Math.trunc(numeric);
      }
    }
  } catch {
    // ignore parsing issues and fallback
  }
  return fallback;
};

const resolveBatchSize = (optsBatchSize?: number): number => {
  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
  const provided = parsePositiveInt(optsBatchSize);
  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
};

const resolveRetries = (optsRetries?: number): number => {
  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
  const provided = parsePositiveInt(optsRetries);
  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
};

const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));

interface DeezerOptions {
  token?: string;
  auth?: ProviderAuth;
  baseUrl?: string;
  batchSize?: number;
  maxRetries?: number;
}

export default class Deezer implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'deezer';

  private readonly options: DeezerOptions;
  private readonly defaultBatchSize: number;
  private readonly maxRetries: number;
  private client?: DeezerClient;

  constructor(options?: DeezerOptions) {
    this.options = options ?? {};
    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
    this.maxRetries = resolveRetries(this.options.maxRetries);
  }

  private ensureClient(): DeezerClient {
    if (this.client) return this.client;
    const token = this.options.token ?? this.options.auth?.token;
    if (!token) {
      throw new Error('Deezer auth token is required');
    }
    this.client = new DeezerClient({
      token,
      baseUrl: this.options.baseUrl,
      retries: this.maxRetries,
    });
    return this.client;
  }

  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
    const client = this.ensureClient();
    const tracks: DeezerTrack[] = [];
    let index = 0;
    let iterations = 0;
    let total: number | undefined;

    while (true) {
      iterations += 1;
      if (iterations > 1000) break;

      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
      const data = Array.isArray(page.data) ? page.data : [];
      if (data.length === 0) {
        break;
      }

      tracks.push(...data);

      if (page.total !== undefined && page.total !== null) {
        const numericTotal = Number(page.total);
        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
          total = Math.trunc(numericTotal);
        }
      }

      const nextIndex = parseNextIndex(page.next, index + data.length);
      if (!page.next || nextIndex <= index) {
        break;
      }
      index = nextIndex;

      if (total !== undefined && index >= total) {
        break;
      }
    }

    return tracks;
  }

  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
    const title = track.title ?? track.title_short ?? null;
    if (!title) return undefined;

    const artists = extractArtists(track);
    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];

    const providerId =
      track.id === undefined || track.id === null ? undefined : String(track.id);

    const explicit =
      track.explicit_lyrics === null || track.explicit_lyrics === undefined
        ? null
        : Boolean(track.explicit_lyrics);

    const mapped: PIFTrack = {
      position: position + 1,
      title,
      artists: artistList,
      album: track.album?.title ?? null,
      duration_ms: toMilliseconds(track.duration),
      explicit,
      release_date: track.album?.release_date ?? null,
      isrc: track.isrc ?? null,
    };

    if (providerId) {
      mapped.provider_ids = { deezer_track_id: providerId };
    }

    return mapped;
  }

  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
    const client = this.ensureClient();
    const pageSize = normalizePageSize(opts?.pageSize);
    const metadata = await client.getPlaylistMetadata(id);
    const rawTracks = await this.fetchAllTracks(id, pageSize);

    const tracks: PIFTrack[] = [];
    for (const track of rawTracks) {
      const mapped = this.mapTrack(track, tracks.length);
      if (mapped) {
        tracks.push(mapped);
      }
    }

    return {
      name: metadata.title ?? `Deezer playlist ${id}`,
      description: metadata.description ?? null,
      source_service: 'deezer',
      source_playlist_id: metadata.id ? String(metadata.id) : id,
      tracks,
    };
  }

  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
    const client = this.ensureClient();
    let attempt = 0;
    while (attempt <= this.maxRetries) {
      try {
        await client.addTracks(playlistId, chunk);
        return;
      } catch (error) {
        attempt += 1;
        if (attempt > this.maxRetries || !(error instanceof Error)) {
          throw error;
        }
        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
          await sleep((error as any).retryAfterMs);
          continue;
        }
        await sleep(Math.min(1000 * attempt, 4000));
      }
    }
  }

  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
    const client = this.ensureClient();
    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;

    const created = await client.createPlaylist({
      title: pif.name,
      description: pif.description ?? undefined,
    });

    const trackIds: string[] = [];
    let skipped = 0;
    for (const track of pif.tracks) {
      const deezerId = track.provider_ids?.deezer_track_id;
      if (!deezerId) {
        skipped += 1;
        continue;
      }
      trackIds.push(deezerId);
    }

    let added = 0;
    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
      const chunk = trackIds.slice(offset, offset + batchSize);
      await this.addTracksWithRetry(created.id, chunk);
      added += chunk.length;
    }

    const report: WritePlaylistResult['report'] = {
      attempted: trackIds.length,
      added,
      failed: trackIds.length - added,
    };

    if (skipped > 0) {
      report.skipped = skipped;
      report.notes = [`${skipped} track(s) missing deezer_track_id`];
    }

    return {
      destId: created.id,
      report,
    };
  }
}
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A packages/providers/deezer/src/index.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Analyzing retry and sleep mechanisms**
Plan update
  ✓ Add Deezer provider tests and fixtures per task spec to capture expected behaviour (failing initially).
  ✓ Implement Deezer client and importer/exporter to satisfy tests (paging, batching, retry).
  → Run targeted tests, ensure green, then commit changes with descriptive message.
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Running tests again**
exec
bash -lc 'pnpm vitest run codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 3.08s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 29ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  03:06:13
   Duration  642ms (transform 127ms, setup 0ms, collect 220ms, tests 29ms, environment 0ms, prepare 95ms)

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Marking plan step as completed**
Plan update
  ✓ Add Deezer provider tests and fixtures per task spec to capture expected behaviour (failing initially).
  ✓ Implement Deezer client and importer/exporter to satisfy tests (paging, batching, retry).
  ✓ Run targeted tests, ensure green, then commit changes with descriptive message.
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Verifying test coverage and git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 222ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 2]
 M packages/providers/deezer/src/index.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/TASKS/work_list
?? codex/code/codex/06c_deezer_impl/
?? packages/providers/deezer/src/deezer.client.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Evaluating files to commit**
exec
bash -lc 'git add packages/providers/deezer/src/index.ts packages/providers/deezer/src/deezer.client.ts codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json' in /var/home/rick/Development/playlist-manager succeeded in 1.20s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Verifying staged changes with git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 53ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 2]
A  codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
A  codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
A  codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
A  packages/providers/deezer/src/deezer.client.ts
M  packages/providers/deezer/src/index.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Reviewing staged changes**
exec
bash -lc 'git diff --staged' in /var/home/rick/Development/playlist-manager succeeded in 76ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000..cf271bb
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..223d2d9204f4fba6361f33f4535e536452d10bbc
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,290 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
+
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    return mapped;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(created.id, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }


thinking
**Analyzing playlist writing improvements**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/deezer/src/index.ts
@@ -265,2 +265,7 @@
 
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
     const trackIds: string[] = [];
@@ -279,3 +284,3 @@
       const chunk = trackIds.slice(offset, offset + batchSize);
-      await this.addTracksWithRetry(created.id, chunk);
+      await this.addTracksWithRetry(destId, chunk);
       added += chunk.length;
@@ -295,3 +300,3 @@
     return {
-      destId: created.id,
+      destId,
       report,
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M packages/providers/deezer/src/index.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Restaging updated files**
exec
bash -lc 'git add packages/providers/deezer/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 74ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Considering whether to rerun tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 3.03s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 36ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  03:06:59
   Duration  1.11s (transform 199ms, setup 0ms, collect 355ms, tests 36ms, environment 0ms, prepare 122ms)

file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Checking git staging status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 2]
A  codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
A  codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
A  codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
A  packages/providers/deezer/src/deezer.client.ts
M  packages/providers/deezer/src/index.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Reviewing index changes**
exec
bash -lc 'git diff --staged packages/providers/deezer/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 186ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d17..764c8ef 100644
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@ import type {
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@ import type {
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Preparing final commit**
exec
bash -lc 'git commit -m "feat(deezer): add importer/exporter with retryable client"' in /var/home/rick/Development/playlist-manager succeeded in 916ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[main f76728b] feat(deezer): add importer/exporter with retryable client
 5 files changed, 608 insertions(+), 5 deletions(-)
 create mode 100644 codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
 create mode 100644 codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
 create mode 100644 codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
 create mode 100644 packages/providers/deezer/src/deezer.client.ts
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Verifying commit details and working tree status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 3]
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Preparing final commit summary**
exec
bash -lc "nl -ba packages/providers/deezer/src/index.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 90ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import type {
     2	  Exporter,
     3	  Importer,
     4	  PIF,
     5	  PIFTrack,
     6	  ProviderAuth,
     7	  ProviderImpl,
     8	  ProviderName,
     9	  ReadOptions,
    10	  WriteOptions,
    11	  WritePlaylistResult,
    12	} from '@app/contracts';
    13	
    14	import {
    15	  DeezerClient,
    16	  type DeezerTrack,
    17	} from './deezer.client.ts';
    18	
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Planning line extraction in deezer.client.ts**
exec
bash -lc "nl -ba packages/providers/deezer/src/deezer.client.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 52ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { RateLimitError } from '@app/contracts';
     2	
     3	export interface DeezerClientOptions {
     4	  token: string;
     5	  baseUrl?: string;
     6	  retries?: number;
     7	}
     8	
     9	export interface DeezerPlaylistMetadata {
    10	  id?: string | number;
    11	  title?: string | null;
    12	  description?: string | null;
    13	  nb_tracks?: number | null;
    14	}
    15	
    16	export interface DeezerArtist {
    17	  id?: string | number;
    18	  name?: string | null;
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Noting test file details**
exec
bash -lc "nl -ba codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 51ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { afterEach, beforeEach, expect, test, vi } from 'vitest';
     2	import nock from 'nock';
     3	
     4	import type { PIF } from '../../../../../packages/contracts/src/index.ts';
     5	import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
     6	
     7	import playlistFixture from './fixtures/deezer.playlist.json';
     8	import createdFixture from './fixtures/deezer.created.json';
     9	
    10	const baseUrl = 'https://api.deezer.com';
    11	
    12	beforeEach(() => {
    13	  nock.disableNetConnect();
    14	});
    15	
    16	afterEach(() => {
    17	  nock.cleanAll();
    18	  nock.enableNetConnect();
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }


thinking
**Preparing final summary and commit details**

I’m organizing a clear final message that explains code changes with file paths and line numbers, notes tests run with commands, includes the exact commit message, and summarizes modified files plus a concise Git status summary including untracked logs. This way, the user gets a complete overview before the final delivery.
codex
Deezer provider now supports full import/export flows with 429-aware HTTP handling and env-driven batching.

- `packages/providers/deezer/src/index.ts:25-208` adds pagination, track mapping, env-resolved batch/retry defaults, and write batching with fallback retry scheduling.
- `packages/providers/deezer/src/deezer.client.ts:1-174` introduces a minimal Deezer REST client that injects auth headers, parses `Retry-After`, and retries before surfacing `RateLimitError`.
- `codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts:22-93` adds nock-backed importer/exporter specs, including a 429 replay that drives the retry logic.
- Fixtures under `codex/code/codex/06c_deezer_impl/tests/fixtures/` provide canned playlist metadata and playlist creation responses for the tests.

Tests run: `pnpm vitest run codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts`

Commit: `feat(deezer): add importer/exporter with retryable client`

Modified files:
- `packages/providers/deezer/src/index.ts`
- `packages/providers/deezer/src/deezer.client.ts`
- `codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts`
- `codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json`
- `codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json`

Git status:
- branch `main` (ahead 3); working tree clean aside from untracked log files (`codex/LOGS/...`, `codex/TASKS/work_list`).
file update:
diff --git a/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cf271bb623f3262d33936c272045553f556d5e4f
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts
@@ -0,0 +1,94 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Deezer from '../../../../../packages/providers/deezer/src/index.ts';
+
+import playlistFixture from './fixtures/deezer.playlist.json';
+import createdFixture from './fixtures/deezer.created.json';
+
+const baseUrl = 'https://api.deezer.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps Deezer playlist tracks into PIF', async () => {
+  const provider = new Deezer({ token: 'test-token' });
+
+  const playlistId = '1234';
+
+  nock(baseUrl)
+    .get(`/playlist/${playlistId}`)
+    .reply(200, { title: 'DX', description: 'deezer mix', nb_tracks: 2 })
+    .get(`/playlist/${playlistId}/tracks`)
+    .query({ limit: '50', index: '0' })
+    .reply(200, playlistFixture);
+
+  const result = await provider.readPlaylist(playlistId, { pageSize: 50 });
+
+  expect(result).toMatchObject({
+    name: 'DX',
+    description: 'deezer mix',
+    source_service: 'deezer',
+    source_playlist_id: playlistId,
+  });
+  expect(result.tracks).toHaveLength(2);
+  expect(result.tracks[0].isrc).toBe('USABC1200001');
+  expect(result.tracks[0]?.provider_ids?.deezer_track_id).toBe('901');
+  expect(result.tracks[1].title).toBeTruthy();
+});
+
+test('exporter creates playlist then batches track adds with Retry-After respect', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Deezer({ token: 'test-token' });
+  const playlistId = createdFixture.id;
+
+  const tracks = Array.from({ length: 205 }, (_, i) => ({
+    position: i + 1,
+    title: `Track ${i + 1}`,
+    artists: ['Artist'],
+    duration_ms: 180000,
+    provider_ids: { deezer_track_id: `dz_${i + 1}` },
+  }));
+
+  const pif = {
+    name: 'DX out',
+    tracks,
+  } satisfies PIF;
+
+  nock(baseUrl)
+    .post('/user/me/playlists', (body) => body?.title === 'DX out')
+    .reply(200, createdFixture);
+
+  const addScope = nock(baseUrl)
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(429, { error: 'rate limit' }, { 'Retry-After': '1' })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 100)
+    .reply(200, { success: true })
+    .post(`/playlist/${playlistId}/tracks`, (body) => body?.songs?.length === 5)
+    .reply(200, { success: true });
+
+  const pending = provider.writePlaylist(pif);
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe(playlistId);
+  expect(result.report).toMatchObject({
+    attempted: 205,
+    added: 205,
+    failed: 0,
+  });
+
+  expect(addScope.isDone()).toBe(true);
+});
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
new file mode 100644
index 0000000000000000000000000000000000000000..b37334c37bced6ffc514f471d326ecd3e6a50408
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json
@@ -0,0 +1,5 @@
+{
+  "id": "pz9",
+  "title": "DX out",
+  "link": "https://www.deezer.com/playlist/pz9"
+}
diff --git a/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..573761189de5cc3d3c5948d0e164b887fb0e7240
--- /dev/null
+++ b/codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json
@@ -0,0 +1,49 @@
+{
+  "data": [
+    {
+      "id": "901",
+      "title": "Eclipse",
+      "duration": 215,
+      "explicit_lyrics": false,
+      "isrc": "USABC1200001",
+      "link": "https://www.deezer.com/track/901",
+      "artist": {
+        "id": "111",
+        "name": "Aurora Duo"
+      },
+      "contributors": [
+        { "id": "111", "name": "Aurora Duo" },
+        { "id": "112", "name": "Solar Keys" }
+      ],
+      "album": {
+        "id": "301",
+        "title": "Skyline",
+        "cover": "https://cdn.test/cover.jpg",
+        "release_date": "2023-07-14"
+      }
+    },
+    {
+      "id": "902",
+      "title": "Mirage",
+      "duration": 189,
+      "explicit_lyrics": true,
+      "isrc": null,
+      "link": "https://www.deezer.com/track/902",
+      "artist": {
+        "id": "113",
+        "name": "Neon Pulse"
+      },
+      "contributors": [
+        { "id": "113", "name": "Neon Pulse" }
+      ],
+      "album": {
+        "id": "302",
+        "title": "Desert Bloom",
+        "cover": "https://cdn.test/cover2.jpg",
+        "release_date": "2022-04-22"
+      }
+    }
+  ],
+  "total": 2,
+  "next": null
+}
diff --git a/packages/providers/deezer/src/deezer.client.ts b/packages/providers/deezer/src/deezer.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ca5b4885e9acc049ee705cb28b88fddb66ec4bd9
--- /dev/null
+++ b/packages/providers/deezer/src/deezer.client.ts
@@ -0,0 +1,174 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface DeezerClientOptions {
+  token: string;
+  baseUrl?: string;
+  retries?: number;
+}
+
+export interface DeezerPlaylistMetadata {
+  id?: string | number;
+  title?: string | null;
+  description?: string | null;
+  nb_tracks?: number | null;
+}
+
+export interface DeezerArtist {
+  id?: string | number;
+  name?: string | null;
+}
+
+export interface DeezerAlbum {
+  id?: string | number;
+  title?: string | null;
+  release_date?: string | null;
+}
+
+export interface DeezerTrack {
+  id?: string | number;
+  title?: string | null;
+  title_short?: string | null;
+  duration?: number | null;
+  explicit_lyrics?: boolean | null;
+  isrc?: string | null;
+  artist?: DeezerArtist | null;
+  contributors?: DeezerArtist[] | null;
+  album?: DeezerAlbum | null;
+}
+
+export interface DeezerTrackPage {
+  data: DeezerTrack[];
+  total?: number | null;
+  next?: string | null;
+}
+
+const defaultBaseUrl = 'https://api.deezer.com';
+
+const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+const normalizeRetries = (retries: number | undefined): number => {
+  if (retries === undefined || retries === null) return 3;
+  if (Number.isNaN(retries) || retries < 0) return 3;
+  return Math.trunc(retries);
+};
+
+export class DeezerClient {
+  private readonly baseUrl: string;
+  private readonly retries: number;
+
+  constructor(private readonly options: DeezerClientOptions) {
+    if (!options?.token) {
+      throw new Error('Deezer token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+    this.retries = normalizeRetries(options.retries);
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: {
+      body?: unknown;
+      query?: Record<string, string | number | undefined>;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+
+    let attempt = 0;
+    while (true) {
+      const headers: Record<string, string> = {
+        authorization: `Bearer ${this.options.token}`,
+      };
+      const init: RequestInit = { method, headers };
+      if (options?.body !== undefined) {
+        headers['content-type'] = 'application/json';
+        init.body = JSON.stringify(options.body);
+      }
+
+      const response = await fetch(url, init);
+
+      if (response.status === 429) {
+        const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+        if (attempt >= this.retries) {
+          throw new RateLimitError('Deezer rate limit exceeded', retryAfter);
+        }
+        attempt += 1;
+        await sleep(retryAfter ?? Math.min(2000 * attempt, 8000));
+        continue;
+      }
+
+      if (!response.ok) {
+        const message = await response.text().catch(() => response.statusText);
+        throw new Error(`Deezer API ${response.status}: ${message}`);
+      }
+
+      if (response.status === 204) {
+        return undefined as T;
+      }
+
+      const text = await response.text();
+      if (!text) {
+        return undefined as T;
+      }
+
+      try {
+        return JSON.parse(text) as T;
+      } catch {
+        return undefined as T;
+      }
+    }
+  }
+
+  getPlaylistMetadata(id: string): Promise<DeezerPlaylistMetadata> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}`);
+  }
+
+  getPlaylistTracks(
+    id: string,
+    opts: { index: number; limit: number },
+  ): Promise<DeezerTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/playlist/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        index: opts.index,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/user/me/playlists', { body: payload });
+  }
+
+  addTracks(playlistId: string, trackIds: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request('POST', `/playlist/${encoded}/tracks`, {
+      body: { songs: trackIds },
+    });
+  }
+}
diff --git a/packages/providers/deezer/src/index.ts b/packages/providers/deezer/src/index.ts
index e055d176eee07e38acef2c33270204d1d4d1ef0f..764c8ef9216bf972f23fdf84c58baaa101af5799
--- a/packages/providers/deezer/src/index.ts
+++ b/packages/providers/deezer/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,295 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  DeezerClient,
+  type DeezerTrack,
+} from './deezer.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_MAX_RETRIES = 3;
+
+const parsePositiveInt = (value: string | number | undefined | null): number | undefined => {
+  if (value === undefined || value === null) return undefined;
+  const numeric = typeof value === 'number' ? value : Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return undefined;
+  return Math.trunc(numeric);
+};
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  const parsed = parsePositiveInt(pageSize);
+  if (!parsed) return DEFAULT_PAGE_SIZE;
+  return Math.min(parsed, 100);
+};
+
+const dedupe = (items: string[]): string[] => {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+  for (const item of items) {
+    const trimmed = item?.trim();
+    if (!trimmed) continue;
+    if (seen.has(trimmed)) continue;
+    seen.add(trimmed);
+    unique.push(trimmed);
+  }
+  return unique;
+};
+
+const extractArtists = (track: DeezerTrack): string[] => {
+  const candidates: string[] = [];
+  if (track.artist?.name) {
+    candidates.push(track.artist.name);
+  }
+  if (Array.isArray(track.contributors)) {
+    for (const contributor of track.contributors) {
+      if (contributor?.name) {
+        candidates.push(contributor.name);
+      }
+    }
+  }
+  return dedupe(candidates);
+};
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric)) return null;
+  return Math.max(0, Math.round(numeric * 1000));
+};
+
+const parseNextIndex = (next: string | null | undefined, fallback: number): number => {
+  if (!next) return fallback;
+  try {
+    const url = new URL(next);
+    const raw = url.searchParams.get('index');
+    if (raw !== null) {
+      const numeric = Number(raw);
+      if (Number.isFinite(numeric) && numeric >= 0) {
+        return Math.trunc(numeric);
+      }
+    }
+  } catch {
+    // ignore parsing issues and fallback
+  }
+  return fallback;
+};
+
+const resolveBatchSize = (optsBatchSize?: number): number => {
+  const envBatch = parsePositiveInt(process.env.PROVIDERS_DEEZER_BATCH_SIZE);
+  const provided = parsePositiveInt(optsBatchSize);
+  return provided ?? envBatch ?? DEFAULT_BATCH_SIZE;
+};
+
+const resolveRetries = (optsRetries?: number): number => {
+  const envRetries = parsePositiveInt(process.env.PROVIDERS_DEEZER_MAX_RETRIES);
+  const provided = parsePositiveInt(optsRetries);
+  return provided ?? envRetries ?? DEFAULT_MAX_RETRIES;
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+interface DeezerOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+  batchSize?: number;
+  maxRetries?: number;
+}
+
 export default class Deezer implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'deezer';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: DeezerOptions;
+  private readonly defaultBatchSize: number;
+  private readonly maxRetries: number;
+  private client?: DeezerClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: DeezerOptions) {
+    this.options = options ?? {};
+    this.defaultBatchSize = resolveBatchSize(this.options.batchSize);
+    this.maxRetries = resolveRetries(this.options.maxRetries);
+  }
+
+  private ensureClient(): DeezerClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Deezer auth token is required');
+    }
+    this.client = new DeezerClient({
+      token,
+      baseUrl: this.options.baseUrl,
+      retries: this.maxRetries,
+    });
+    return this.client;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async fetchAllTracks(id: string, pageSize: number): Promise<DeezerTrack[]> {
+    const client = this.ensureClient();
+    const tracks: DeezerTrack[] = [];
+    let index = 0;
+    let iterations = 0;
+    let total: number | undefined;
+
+    while (true) {
+      iterations += 1;
+      if (iterations > 1000) break;
+
+      const page = await client.getPlaylistTracks(id, { index, limit: pageSize });
+      const data = Array.isArray(page.data) ? page.data : [];
+      if (data.length === 0) {
+        break;
+      }
+
+      tracks.push(...data);
+
+      if (page.total !== undefined && page.total !== null) {
+        const numericTotal = Number(page.total);
+        if (Number.isFinite(numericTotal) && numericTotal >= 0) {
+          total = Math.trunc(numericTotal);
+        }
+      }
+
+      const nextIndex = parseNextIndex(page.next, index + data.length);
+      if (!page.next || nextIndex <= index) {
+        break;
+      }
+      index = nextIndex;
+
+      if (total !== undefined && index >= total) {
+        break;
+      }
+    }
+
+    return tracks;
+  }
+
+  private mapTrack(track: DeezerTrack, position: number): PIFTrack | undefined {
+    const title = track.title ?? track.title_short ?? null;
+    if (!title) return undefined;
+
+    const artists = extractArtists(track);
+    const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+    const providerId =
+      track.id === undefined || track.id === null ? undefined : String(track.id);
+
+    const explicit =
+      track.explicit_lyrics === null || track.explicit_lyrics === undefined
+        ? null
+        : Boolean(track.explicit_lyrics);
+
+    const mapped: PIFTrack = {
+      position: position + 1,
+      title,
+      artists: artistList,
+      album: track.album?.title ?? null,
+      duration_ms: toMilliseconds(track.duration),
+      explicit,
+      release_date: track.album?.release_date ?? null,
+      isrc: track.isrc ?? null,
+    };
+
+    if (providerId) {
+      mapped.provider_ids = { deezer_track_id: providerId };
+    }
+
+    return mapped;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const metadata = await client.getPlaylistMetadata(id);
+    const rawTracks = await this.fetchAllTracks(id, pageSize);
+
+    const tracks: PIFTrack[] = [];
+    for (const track of rawTracks) {
+      const mapped = this.mapTrack(track, tracks.length);
+      if (mapped) {
+        tracks.push(mapped);
+      }
+    }
+
+    return {
+      name: metadata.title ?? `Deezer playlist ${id}`,
+      description: metadata.description ?? null,
+      source_service: 'deezer',
+      source_playlist_id: metadata.id ? String(metadata.id) : id,
+      tracks,
+    };
+  }
+
+  private async addTracksWithRetry(playlistId: string, chunk: string[]): Promise<void> {
+    const client = this.ensureClient();
+    let attempt = 0;
+    while (attempt <= this.maxRetries) {
+      try {
+        await client.addTracks(playlistId, chunk);
+        return;
+      } catch (error) {
+        attempt += 1;
+        if (attempt > this.maxRetries || !(error instanceof Error)) {
+          throw error;
+        }
+        if ('retryAfterMs' in error && typeof (error as any).retryAfterMs === 'number') {
+          await sleep((error as any).retryAfterMs);
+          continue;
+        }
+        await sleep(Math.min(1000 * attempt, 4000));
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = parsePositiveInt(opts?.batch?.batchSize) ?? this.defaultBatchSize;
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? undefined,
+    });
+
+    const destId = created?.id ? String(created.id) : undefined;
+    if (!destId) {
+      throw new Error('Deezer playlist creation failed');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+    for (const track of pif.tracks) {
+      const deezerId = track.provider_ids?.deezer_track_id;
+      if (!deezerId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(deezerId);
+    }
+
+    let added = 0;
+    for (let offset = 0; offset < trackIds.length; offset += batchSize) {
+      const chunk = trackIds.slice(offset, offset + batchSize);
+      await this.addTracksWithRetry(destId, chunk);
+      added += chunk.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: trackIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing deezer_track_id`];
+    }
+
+    return {
+      destId,
+      report,
+    };
   }
 }

tokens used
88,430
Deezer provider now supports full import/export flows with 429-aware HTTP handling and env-driven batching.

- `packages/providers/deezer/src/index.ts:25-208` adds pagination, track mapping, env-resolved batch/retry defaults, and write batching with fallback retry scheduling.
- `packages/providers/deezer/src/deezer.client.ts:1-174` introduces a minimal Deezer REST client that injects auth headers, parses `Retry-After`, and retries before surfacing `RateLimitError`.
- `codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts:22-93` adds nock-backed importer/exporter specs, including a 429 replay that drives the retry logic.
- Fixtures under `codex/code/codex/06c_deezer_impl/tests/fixtures/` provide canned playlist metadata and playlist creation responses for the tests.

Tests run: `pnpm vitest run codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts`

Commit: `feat(deezer): add importer/exporter with retryable client`

Modified files:
- `packages/providers/deezer/src/index.ts`
- `packages/providers/deezer/src/deezer.client.ts`
- `codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts`
- `codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.playlist.json`
- `codex/code/codex/06c_deezer_impl/tests/fixtures/deezer.created.json`

Git status:
- branch `main` (ahead 3); working tree clean aside from untracked log files (`codex/LOGS/...`, `codex/TASKS/work_list`).
