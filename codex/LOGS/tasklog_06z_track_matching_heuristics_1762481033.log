OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5c0e-549b-7d63-8c69-7f21a03173c5
--------
user
Implement the functionality described in codex/TASKS/06z_track_matching_heuristics.yaml, then verify with any available tests.

thinking
**Planning implementation with spec-first and TDD**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 151ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas
scripts
tsconfig.json

thinking
**Inspecting codex task file**
exec
bash -lc 'cat codex/TASKS/06z_track_matching_heuristics.yaml' in /var/home/rick/Development/playlist-manager succeeded in 207ms:
id: 06z_track_matching_heuristics
title: Deterministic track matching to MBID (heuristic ladder + tests)
branch: codex/06z_track_matching_heuristics
overview: >
  Implement a resolver that maps provider track â†’ MBID using a strict priority:
  (1) direct MBID tag; (2) ISRCâ†’MBID map; (3) exact title+primary_artist+duration;
  (4) fuzzy title+artist with thresholds. Provide unit tests and golden fixtures.
acceptance:
  - tests pass with golden fixtures covering edge cases (live versions, remasters)
  - Resolver exposes confidences and the chosen rule for auditing
  - No external network during tests (fixtures only)
artifacts_to_touch:
  - packages/providers/core/src/match/mbidResolver.ts
  - packages/providers/core/test/mbidResolver.test.ts
  - packages/providers/core/fixtures/*.json
steps:
  - Implement pure functions with deterministic sorting & thresholds
  - Add configurable thresholds via env/params
  - Export types for MatchResult { mbid, confidence, rule, candidates[] }

thinking
**Preparing to implement with TDD**
exec
bash -lc 'ls packages/providers/core' in /var/home/rick/Development/playlist-manager succeeded in 200ms:
src
test

thinking
**Examining source structure**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager succeeded in 131ms:
http
index.ts
match
types.ts

thinking
**Checking match folder**
exec
bash -lc 'ls packages/providers/core/src/match' in /var/home/rick/Development/playlist-manager succeeded in 111ms:
mbidResolver.ts

thinking
**Viewing file**
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/match/mbidResolver.ts" in /var/home/rick/Development/playlist-manager succeeded in 101ms:
export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';

export interface Candidate {
  mbid: string;
  title: string;
  primaryArtist: string;
  durationMs?: number | null;
  isrc?: string | null;
}

export interface MatchResult {
  mbid: string;
  confidence: number;
  rule: MatchRule;
  candidates: Candidate[];
}

export interface ResolveInput {
  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
  catalog: Candidate[];

thinking
**Evaluating current resolver and tests**
exec
bash -lc "sed -n '1,200p' packages/providers/core/test/mbidResolver.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 79ms:
import { describe, it, expect } from 'vitest';
import { resolveMbid } from '../src/match/mbidResolver';

describe('resolveMbid', () => {
  it('prefers direct mbid', () => {
    const r = resolveMbid({
      provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
      catalog: []
    });
    expect(r?.rule).toBe('mbid');
  });

  it('matches by isrc', () => {
    const r = resolveMbid({
      provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
    });
    expect(r?.rule).toBe('isrc');
  });
});

thinking
**Planning test improvements**
exec
bash -lc 'ls packages/providers/core/fixtures' in /var/home/rick/Development/playlist-manager exited 2 in 126ms:
ls: cannot access 'packages/providers/core/fixtures': No such file or directory

thinking
**Planning heuristic enhancements and config setup**
exec
bash -lc 'rg -n "fuzzy" -n "mbid" packages/providers/core -g"*.ts"' in /var/home/rick/Development/playlist-manager exited 2 in 77ms:
rg: mbid: No such file or directory (os error 2)
packages/providers/core/src/match/mbidResolver.ts:1:export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';
packages/providers/core/src/match/mbidResolver.ts:21:  thresholds?: { fuzzyMin?: number };
packages/providers/core/src/match/mbidResolver.ts:40:  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
packages/providers/core/src/match/mbidResolver.ts:51:  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
packages/providers/core/src/match/mbidResolver.ts:52:    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };

thinking
**Planning MBID resolver tests and heuristics**
exec
bash -lc 'rg -n "resolveMbid" -n packages -n' in /var/home/rick/Development/playlist-manager succeeded in 382ms:
packages/providers/core/src/match/mbidResolver.ts:24:export function resolveMbid(input: ResolveInput): MatchResult | null {
packages/providers/core/test/mbidResolver.test.ts:2:import { resolveMbid } from '../src/match/mbidResolver';
packages/providers/core/test/mbidResolver.test.ts:4:describe('resolveMbid', () => {
packages/providers/core/test/mbidResolver.test.ts:6:    const r = resolveMbid({
packages/providers/core/test/mbidResolver.test.ts:14:    const r = resolveMbid({

thinking
**Reviewing test impact and setup**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 52ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",

thinking
**Gathering testing approach details**
exec
bash -lc 'ls packages/providers/core/test' in /var/home/rick/Development/playlist-manager succeeded in 65ms:
fixtureHarness.test.ts
fixtureHarness.ts
fixtures
mbidResolver.test.ts

thinking
**Checking for fixtures in test folder**
exec
bash -lc 'ls packages/providers/core/test/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 80ms:
get_https_fixtures_test_artist.json

thinking
**Inspecting test fixture setup**
exec
bash -lc "sed -n '1,200p' packages/providers/core/test/fixtureHarness.ts" in /var/home/rick/Development/playlist-manager succeeded in 93ms:
import fs from 'node:fs';
import path from 'node:path';

type Mode = 'live' | 'record' | 'replay';

interface FixtureRecord {
  url: string;
  method: string;
  status: number;
  headers: Record<string, string>;
  body: string;
  recordedAt: string;
}

const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
const IGNORED_HEADERS = new Set([
  'age',
  'cache-control',
  'connection',
  'date',

thinking
**Evaluating fixture directory alignment**
Plan update
  â†’ Design matching scenarios + fixtures and add failing tests for heuristic ladder + auditing outputs
  â€¢ Implement deterministic resolver with configurable thresholds + candidate ranking
  â€¢ Run targeted tests, adjust as needed, and prepare commit

thinking
**Planning detailed test design**

I'm focusing on designing tests first following TDD principles, planning golden fixtures and heuristics for matching. Iâ€™m considering how to expose match results with candidates including scores and reasons for confidence, aligning with the expected `MatchResult` types. I also want to support configurable thresholds from environment variables or parameters, so Iâ€™ll check the repoâ€™s config pattern for variables like `MBID_MATCH`.
exec
bash -lc 'rg -n "MBID" -n' in /var/home/rick/Development/playlist-manager exited 124 in 12.03s:
openapi.yaml:505:      summary: Follow an artist by MBID
apps/api/src/routes/artists/[mbid].get.ts:9:const MBID_REGEX = /^[0-9a-fA-F-]{36}$/;
apps/api/src/routes/artists/[mbid].get.ts:16:  if (!MBID_REGEX.test(mbid)) {
apps/api/src/routes/artists/[mbid].get.ts:17:    throw problem({ status: 400, code: 'invalid_mbid', message: 'Invalid MBID' });
apps/api/src/routes/artists/[mbid]/relations.get.ts:13:const MBID_REGEX = /^[0-9a-fA-F-]{36}$/;
apps/api/src/routes/artists/[mbid]/relations.get.ts:20:  if (!MBID_REGEX.test(mbid)) {
apps/api/src/routes/artists/[mbid]/relations.get.ts:21:    throw problem({ status: 400, code: 'invalid_mbid', message: 'Invalid MBID' });
apps/api/src/routes/artists/[mbid]/follow.delete.ts:9:const MBID_REGEX = /^[0-9a-fA-F-]{36}$/;
apps/api/src/routes/artists/[mbid]/follow.delete.ts:16:  if (!MBID_REGEX.test(mbid)) {
apps/api/src/routes/artists/[mbid]/follow.delete.ts:17:    throw problem({ status: 400, code: 'invalid_mbid', message: 'Invalid MBID' });
apps/api/src/routes/artists/[mbid]/follow.post.ts:9:const MBID_REGEX = /^[0-9a-fA-F-]{36}$/;
apps/api/src/routes/artists/[mbid]/follow.post.ts:16:  if (!MBID_REGEX.test(mbid)) {
apps/api/src/routes/artists/[mbid]/follow.post.ts:17:    throw problem({ status: 400, code: 'invalid_mbid', message: 'Invalid MBID' });
apps/api/src/lib/openapi/openapi.json:662:        "summary": "Follow an artist by MBID",
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:45:title: Deterministic track matching to MBID (heuristic ladder + tests)
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:48:  Implement a resolver that maps provider track â†’ MBID using a strict priority:
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:49:  (1) direct MBID tag; (2) ISRCâ†’MBID map; (3) exact title+primary_artist+duration;
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:154:**Planning MBID resolver tests and heuristics**
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:238:I'm focusing on designing tests first following TDD principles, planning golden fixtures and heuristics for matching. Iâ€™m considering how to expose match results with candidates including scores and reasons for confidence, aligning with the expected `MatchResult` types. I also want to support configurable thresholds from environment variables or parameters, so Iâ€™ll check the repoâ€™s config pattern for variables like `MBID_MATCH`.
codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log:240:bash -lc 'rg -n "MBID" -n' in /var/home/rick/Development/playlist-manager

thinking
**Checking task-specific log file**
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log" in /var/home/rick/Development/playlist-manager succeeded in 57ms:
OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5c0e-549b-7d63-8c69-7f21a03173c5
--------
user
Implement the functionality described in codex/TASKS/06z_track_matching_heuristics.yaml, then verify with any available tests.

thinking
**Planning implementation with spec-first and TDD**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 151ms:
AGENTS.md
apps




thinking
**Outlining MBID resolution heuristics and tests**

I'm mapping out detailed heuristics to resolve MBIDs from provider and catalog data, including direct MBID usage, ISRC mapping, exact and fuzzy matching with threshold configs and normalization functions. Iâ€™m also planning golden fixture-driven unit tests covering edge cases like live versions and remasters to verify these heuristics systematically. This includes defining MatchResult structures, scoring methods, and fixture formats to ensure deterministic and auditable resolver behavior.
thinking
**Designing failing test scenarios for heuristics**

Iâ€™m crafting test cases that expose current resolver weaknessesâ€”like punctuation and descriptor differences, duration mismatches, and complex artist namingâ€”to ensure new heuristics are truly needed. These tests aim to fail with existing simple token-based matching and require improved normalization, duration checks, and candidate ranking to pass later.
thinking
**Planning extended fixture-driven tests and type adjustments**

Iâ€™m outlining detailed tests using fixture files to catch matcher weaknesses like punctuation and descriptor differences, plus adding checks for new properties like candidate confidence. Iâ€™m also considering how to update type definitions and implementation smoothly so tests compile while still ensuring failures that drive the TDD process.
thinking
**Outlining multi-step test and fixture setup plan**

Iâ€™m planning to add fixture files with detailed test cases covering live and remaster scenarios, while carefully managing type checks by using type assertions or partial typing to allow TDD without breaking compilation. This approach balances writing thorough tests first and preparing for type and implementation updates later.
exec
bash -lc 'mkdir -p packages/providers/core/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 2.28s:


thinking
**Designing fixture JSON files with detailed test cases**

Iâ€™m planning two fixture JSONs to test live and remaster matching with nuanced candidate ordering, expected rules, and confidence thresholds; the goal is to ensure tests catch cases where old heuristics fail and new canonicalization and duration heuristics improve ranking accuracy.
exec
bash -lc "cat <<'EOF' > packages/providers/core/fixtures/live_variation.json
{
  \"name\": \"Live performance disambiguation\",
  \"provider\": {
    \"title\": \"Don't Stop Me Now - Live in Montreal 1981\",
    \"artist\": \"Queen feat. Freddie Mercury\",
    \"durationMs\": 316500
  },
  \"catalog\": [
    {
      \"mbid\": \"8a68cd44-1111-4c1f-b4b2-111111111111\",
      \"title\": \"Dont Stop Me Now (Live In Montreal)\",
      \"primaryArtist\": \"Queen\",
      \"durationMs\": 316200
    },
    {
      \"mbid\": \"a5f2ba31-2222-4cc4-bf9a-222222222222\",
      \"title\": \"Don't Stop Me Now\",
      \"primaryArtist\": \"Queen\",
      \"durationMs\": 210000
    },
    {
      \"mbid\": \"c59d4c77-3333-4e55-b4ce-333333333333\",
      \"title\": \"Don't Stop Me Now (Live At Wembley '86)\",
      \"primaryArtist\": \"Queen\",
      \"durationMs\": 283000
    }
  ],
  \"expected\": {
    \"rule\": \"fuzzy\",
    \"mbid\": \"8a68cd44-1111-4c1f-b4b2-111111111111\",
    \"candidateOrder\": [
      \"8a68cd44-1111-4c1f-b4b2-111111111111\",
      \"c59d4c77-3333-4e55-b4ce-333333333333\",
      \"a5f2ba31-2222-4cc4-bf9a-222222222222\"
    ],
    \"confidenceAtLeast\": 0.7
  }
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 131ms:


thinking
**Adding second fixture**
exec
bash -lc "cat <<'EOF' > packages/providers/core/fixtures/remaster_ladder.json
{
  \"name\": \"Remaster prioritization\",
  \"provider\": {
    \"title\": \"Everything In Its Right Place [2008 Remaster]\",
    \"artist\": \"Radiohead\",
    \"durationMs\": 257200
  },
  \"catalog\": [
    {
      \"mbid\": \"db1f0a10-aaaa-4ce8-aaaa-aaaaaaaaaaaa\",
      \"title\": \"Everything In Its Right Place - 2008 Remastered\",
      \"primaryArtist\": \"Radiohead\",
      \"durationMs\": 257230
    },
    {
      \"mbid\": \"fb6d84c2-bbbb-4e4a-bbbb-bbbbbbbbbbbb\",
      \"title\": \"Everything In Its Right Place\",
      \"primaryArtist\": \"Radiohead\",
      \"durationMs\": 256800
    },
    {
      \"mbid\": \"8f3ddd63-cccc-4f20-cccc-cccccccccccc\",
      \"title\": \"Everything In Its Right Place (Live From BBC Maida Vale)\",
      \"primaryArtist\": \"Radiohead\",
      \"durationMs\": 311000
    }
  ],
  \"expected\": {
    \"rule\": \"exact\",
    \"mbid\": \"db1f0a10-aaaa-4ce8-aaaa-aaaaaaaaaaaa\",
    \"candidateOrder\": [
      \"db1f0a10-aaaa-4ce8-aaaa-aaaaaaaaaaaa\",
      \"fb6d84c2-bbbb-4e4a-bbbb-bbbbbbbbbbbb\",
      \"8f3ddd63-cccc-4f20-cccc-cccccccccccc\"
    ],
    \"confidenceAtLeast\": 0.85
  }
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 50ms:



thinking
**Planning test and type updates**
thinking
**Drafting detailed test helpers and scenarios**

I'm designing helpers to coerce and audit resolveMbid results for strong typing in tests. I'll rewrite the test file structure to load JSON fixtures, verify properties like confidence and candidate order, and craft scenarios checking that isrcMap takes precedence over catalog entries. This approach lets me test new behaviors cleanly while accommodating TypeScript quirks by using type assertions and helper wrappers.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/mbidResolver.test.ts
@@ -1,4 +1,30 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
@@ -7,13 +33,50 @@
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
apply_patch(auto_approved=true) exited 0 in 745ms:
Success. Updated the following files:
M packages/providers/core/test/mbidResolver.test.ts
file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Running targeted TypeScript tests**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/mbidResolver.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 16.65s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 â¯ packages/providers/core/test/mbidResolver.test.ts (5 tests | 3 failed) 29ms
   âœ“ resolveMbid > prefers direct mbid 3ms
   Ã— resolveMbid > maps via explicit ISRC index before heuristics 16ms
     â†’ expected 'exact' to be 'isrc' // Object.is equality
   Ã— resolveMbid > matches golden fixture: live_variation 4ms
     â†’ expected undefined to be 'fuzzy' // Object.is equality
   Ã— resolveMbid > matches golden fixture: remaster_ladder 3ms
     â†’ expected 'fuzzy' to be 'exact' // Object.is equality
   âœ“ resolveMbid > honors fuzzy threshold overrides 1ms

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Tests 3 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/providers/core/test/mbidResolver.test.ts > resolveMbid > maps via explicit ISRC index before heuristics
AssertionError: expected 'exact' to be 'isrc' // Object.is equality

Expected: [32m"isrc"[39m
Received: [31m"exact"[39m
file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Updating progress plan**
Plan update
  âœ“ Design matching scenarios + fixtures and add failing tests for heuristic ladder + auditing outputs
  â†’ Implement deterministic resolver with configurable thresholds + candidate ranking
  â€¢ Run targeted tests, adjust as needed, and prepare commit
file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Designing detailed MBID resolver logic**
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/match/mbidResolver.ts" in /var/home/rick/Development/playlist-manager succeeded in 87ms:
export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';

export interface Candidate {
  mbid: string;
  title: string;
  primaryArtist: string;
  durationMs?: number | null;
  isrc?: string | null;
}

export interface MatchResult {
  mbid: string;
  confidence: number;
  rule: MatchRule;
  candidates: Candidate[];
}

export interface ResolveInput {
  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
  catalog: Candidate[];
file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });




thinking
**Designing comprehensive rewrite plan**

Iâ€™m outlining a full rewrite to introduce new types, helper functions, and detailed heuristics for matching candidates, including normalization, deterministic catalog sorting, ISRC mapping with normalization, multi-stage confidence scoring, and nuanced candidate ranking for auditingâ€”with careful thoughts on test expectations and how to expose confidence scores consistently across stages.
thinking
**Clarifying multi-stage scoring and candidate ordering**

Iâ€™m exploring how to merge exact and fuzzy scoring into a unified ranked candidate list that satisfies test expectations by building a fuzzy-score-based scoreboard for all candidates, then boosting exact matchesâ€™ confidence and rules accordingly. This approach maintains deterministic ordering, exposes rich candidate details for auditing, and aligns with fixture orders, while handling stage-specific nuances like direct and ISRC matches separately.
thinking
**Implementing candidate scoring and exact match logic**

Iâ€™m working on computing all candidate similarity scores against the provider, including duration and token-based title/artist matches, then identifying exact matches via canonical strings and duration tolerance. I plan to build a ranked scoreboard mixing exact and fuzzy matches with confidence scores adjusted accordingly, ensuring rounding precision and preparing to export the main resolver function cleanly.
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 54ms:
export * from './types';
file update:
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Planning full resolver rewrite**
file update
D /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';

export interface Candidate {
  mbid: string;
  title: string;
  primaryArtist: string;
  durationMs?: number | null;
  isrc?: string | null;
}

export interface MatchResult {
  mbid: string;
  confidence: number;
  rule: MatchRule;
  candidates: Candidate[];
}

export interface ResolveInput {
  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
  catalog: Candidate[];
  thresholds?: { fuzzyMin?: number };
}

export function resolveMbid(input: ResolveInput): MatchResult | null {
  const { provider, catalog } = input;
  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };

  if (provider.isrc) {
    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
  }

  const exact = catalog.find(c =>
    c.title.toLowerCase() === provider.title.toLowerCase() &&
    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
  );
  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };

  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
  let best: { score: number; c: Candidate } | null = null;
  for (const c of catalog) {
    const a = toks(provider.title + ' ' + provider.artist);
    const b = toks(c.title + ' ' + c.primaryArtist);
    const inter = [...a].filter(x => b.has(x)).length;
    const union = new Set([...a, ...b]).size;
    const score = union ? inter / union : 0;
    if (!best || score > best.score) best = { score, c };
  }
  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
  }
  return null;
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
D packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
deleted file mode 100644
index b4722d561831bd1b32b01a771ff6529429f5dbb6..0000000000000000000000000000000000000000
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';
-
-export interface Candidate {
-  mbid: string;
-  title: string;
-  primaryArtist: string;
-  durationMs?: number | null;
-  isrc?: string | null;
-}
-
-export interface MatchResult {
-  mbid: string;
-  confidence: number;
-  rule: MatchRule;
-  candidates: Candidate[];
-}
-
-export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
-  catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
-}
-
-export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
-
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
-  }
-
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
-  );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
-
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
-  }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
-  }
-  return null;
-}
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
deleted file mode 100644
index b4722d561831bd1b32b01a771ff6529429f5dbb6..0000000000000000000000000000000000000000
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';
-
-export interface Candidate {
-  mbid: string;
-  title: string;
-  primaryArtist: string;
-  durationMs?: number | null;
-  isrc?: string | null;
-}
-
-export interface MatchResult {
-  mbid: string;
-  confidence: number;
-  rule: MatchRule;
-  candidates: Candidate[];
-}
-
-export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
-  catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
-}
-
-export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
-
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
-  }
-
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
-  );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
-
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
-  }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
-  }
-  return null;
-}
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Adding a new file with updates**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';

export interface Candidate {
  mbid: string;
  title: string;
  primaryArtist: string;
  durationMs?: number | null;
  isrc?: string | null;
}

export interface CandidateDetails {
  titleScore?: number;
  artistScore?: number;
  durationScore?: number;
  durationDeltaMs?: number;
}

export interface RankedCandidate {
  candidate: Candidate;
  confidence: number;
  rule: MatchRule;
  details?: CandidateDetails;
}

export interface MatchResult {
  mbid: string;
  confidence: number;
  rule: MatchRule;
  candidates: RankedCandidate[];
}

export interface ProviderTrack {
  title: string;
  artist: string;
  durationMs?: number | null;
  isrc?: string | null;
  mbid?: string | null;
}

export interface ThresholdConfig {
  fuzzyMin: number;
  durationToleranceMs: number;
  fuzzyDurationPenaltyMs: number;
  fuzzyTitleWeight: number;
  fuzzyArtistWeight: number;
  fuzzyDurationWeight: number;
}

export interface ResolveInput {
  provider: ProviderTrack;
  catalog: Candidate[];
  isrcMap?: Record<string, string>;
  thresholds?: Partial<ThresholdConfig>;
}

interface PreparedCandidate {
  candidate: Candidate;
  normalizedTitle: string;
  normalizedArtist: string;
  titleTokens: Set<string>;
  artistTokens: Set<string>;
}

interface CandidateScore {
  prepared: PreparedCandidate;
  titleScore: number;
  artistScore: number;
  durationScore: number;
  durationDeltaMs?: number;
  combinedScore: number;
}

const DIRECT_CONFIDENCE = 1;
const ISRC_MAP_CONFIDENCE = 0.99;
const ISRC_CATALOG_CONFIDENCE = 0.98;
const EXACT_BASE_CONFIDENCE = 0.94;
const EXACT_DECAY = 0.02;

export function resolveMbid(input: ResolveInput): MatchResult | null {
  const thresholds = resolveThresholds(input.thresholds);
  const provider = input.provider;
  const normalizedCatalog = prepareCatalog(input.catalog);
  const normalizedProviderTitle = normalizeTitle(provider.title);
  const normalizedProviderArtist = normalizeArtist(provider.artist);
  const providerTitleTokens = tokenSet(normalizedProviderTitle);
  const providerArtistTokens = tokenSet(normalizedProviderArtist);
  const candidateScores = buildCandidateScores(
    provider,
    normalizedCatalog,
    providerTitleTokens,
    providerArtistTokens,
    thresholds,
  );

  if (provider.mbid) {
    return {
      mbid: provider.mbid,
      confidence: DIRECT_CONFIDENCE,
      rule: 'mbid',
      candidates: [],
    };
  }

  const providerIsrc = normalizeIsrc(provider.isrc);
  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);

  if (providerIsrc) {
    const mapHit = normalizedIsrcMap?.[providerIsrc];
    if (mapHit) {
      const catalogCandidate =
        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
        {
          mbid: mapHit,
          title: provider.title,
          primaryArtist: provider.artist,
          durationMs: provider.durationMs,
          isrc: provider.isrc,
        };
      return {
        mbid: mapHit,
        confidence: ISRC_MAP_CONFIDENCE,
        rule: 'isrc',
        candidates: [
          createRankedCandidate(
            {
              prepared: {
                candidate: catalogCandidate,
                normalizedArtist: normalizedProviderArtist,
                normalizedTitle: normalizedProviderTitle,
                artistTokens: providerArtistTokens,
                titleTokens: providerTitleTokens,
              },
              titleScore: 1,
              artistScore: 1,
              durationScore: 1,
              combinedScore: 1,
            },
            'isrc',
            ISRC_MAP_CONFIDENCE,
          ),
        ],
      };
    }

    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
    if (catalogHit) {
      return {
        mbid: catalogHit.candidate.mbid,
        confidence: ISRC_CATALOG_CONFIDENCE,
        rule: 'isrc',
        candidates: [
          createRankedCandidate(
            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
            'isrc',
            ISRC_CATALOG_CONFIDENCE,
          ),
        ],
      };
    }
  }

  const exactMatches = normalizedCatalog.filter(entry =>
    entry.normalizedTitle === normalizedProviderTitle &&
    entry.normalizedArtist === normalizedProviderArtist &&
    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
  );

  if (exactMatches.length) {
    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
    if (winner) {
      return {
        mbid: winner.candidate.mbid,
        confidence: winner.confidence,
        rule: 'exact',
        candidates: scoreboard,
      };
    }
  }

  const fuzzyMatches = candidateScores
    .filter(score => score.combinedScore > 0)
    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
    .sort(sortRankedCandidates);

  const bestFuzzy = fuzzyMatches[0];
  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
    return null;
  }

  return {
    mbid: bestFuzzy.candidate.mbid,
    confidence: bestFuzzy.confidence,
    rule: 'fuzzy',
    candidates: fuzzyMatches,
  };
}

function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
  return [...catalog]
    .map(candidate => {
      const normalizedTitle = normalizeTitle(candidate.title);
      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
      return {
        candidate,
        normalizedTitle,
        normalizedArtist,
        titleTokens: tokenSet(normalizedTitle),
        artistTokens: tokenSet(normalizedArtist),
      };
    })
    .sort((a, b) =>
      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
      a.candidate.mbid.localeCompare(b.candidate.mbid)
    );
}

function buildCandidateScores(
  provider: ProviderTrack,
  catalog: PreparedCandidate[],
  providerTitleTokens: Set<string>,
  providerArtistTokens: Set<string>,
  thresholds: ThresholdConfig,
): CandidateScore[] {
  return catalog.map(entry => {
    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
    return {
      prepared: entry,
      titleScore,
      artistScore,
      durationScore,
      durationDeltaMs: durationDeltaMs ?? undefined,
      combinedScore,
    };
  });
}

function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
  return scores
    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
    .map(score => {
      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
      if (idx === -1) {
        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
      }
      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
      return createRankedCandidate(score, 'exact', confidence);
    })
    .sort(sortRankedCandidates);
}

function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
  return {
    candidate: score.prepared.candidate,
    confidence: roundScore(confidence),
    rule,
    details: {
      titleScore: roundScore(score.titleScore),
      artistScore: roundScore(score.artistScore),
      durationScore: roundScore(score.durationScore),
      durationDeltaMs: score.durationDeltaMs,
    },
  };
}

function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
  return a.candidate.mbid.localeCompare(b.candidate.mbid);
}

function roundScore(value: number): number {
  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
}

function computeDurationDelta(a?: number | null, b?: number | null): number | null {
  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
  return Math.abs((a ?? 0) - (b ?? 0));
}

function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
  if (delta === null) return 0.5;
  if (delta <= 0) return 1;
  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
}

function computeCombinedScore(
  titleScore: number,
  artistScore: number,
  durationScore: number,
  thresholds: ThresholdConfig,
): number {
  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
  if (!weightSum) return 0;
  const weighted =
    titleScore * thresholds.fuzzyTitleWeight +
    artistScore * thresholds.fuzzyArtistWeight +
    durationScore * thresholds.fuzzyDurationWeight;
  return weighted / weightSum;
}

function diceCoefficient(left: Set<string>, right: Set<string>): number {
  if (!left.size || !right.size) return 0;
  let intersection = 0;
  left.forEach(token => {
    if (right.has(token)) intersection += 1;
  });
  return (2 * intersection) / (left.size + right.size);
}

function tokenSet(value: string): Set<string> {
  const tokens = value.split(' ').filter(Boolean);
  return new Set(tokens);
}

function normalizeTitle(value: string): string {
  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
}

function normalizeArtist(value: string): string {
  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
}

function normalizeString(value: string): string {
  return value
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/&/g, ' and ')
    .replace(/['â€™]/g, '')
    .replace(/[^a-z0-9\s]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();
}

function normalizeIsrc(value?: string | null): string {
  if (!value) return '';
  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
}

function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
  if (!map) return null;
  const normalized: Record<string, string> = {};
  for (const [key, value] of Object.entries(map)) {
    const normalizedKey = normalizeIsrc(key);
    if (!normalizedKey) continue;
    normalized[normalizedKey] = value;
  }
  return normalized;
}

function withinDuration(
  providerDuration?: number | null,
  candidateDuration?: number | null,
  tolerance?: number,
): boolean {
  const delta = computeDurationDelta(providerDuration, candidateDuration);
  if (delta === null) return true;
  return delta <= (tolerance ?? 0);
}

function isFiniteNumber(value?: number | null): value is number {
  return typeof value === 'number' && Number.isFinite(value);
}

function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
  const defaults: ThresholdConfig = {
    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
  };
  if (!overrides) return defaults;
  return {
    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
  };
}

function envNumber(key: string, fallback: number): number {
  const raw = process.env[key];
  if (!raw) return fallback;
  const parsed = Number(raw);
  return Number.isFinite(parsed) ? parsed : fallback;
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..5f0493662d1a0da3bd320c3345fa9a4075ee1d0d
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,83 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture {
+  name: string;
+  provider: ResolveInput['provider'];
+  catalog: ResolveInput['catalog'];
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
+const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
+  rule: string;
+  confidence: number;
+  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
+};
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      // @ts-expect-error temporary shape for upcoming resolver work
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, ...input } = fx;
+      const result = resolveMbid(input);
+      const audited = asAudited(result);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Reviewing type adjustments and test updates**

Iâ€™m carefully verifying that all TypeScript interfaces and usages align, especially around `PreparedCandidate`, `CandidateScore`, and related types, ensuring properties like `candidate` and token sets are consistent. Iâ€™m also planning comprehensive test updates to replace hacks like `@ts-expect-error` with proper typed fixtures and to validate candidate ordering and scores according to the new scoreboard logic. This involves restructuring fixture types, importing actual types like `MatchResult`, and modifying test assertions to expect real, typed results. It feels like a thorough cleanup and strengthening of type safety while improving test clarity and accuracy.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/mbidResolver.test.ts
@@ -3,3 +3,3 @@
 import { describe, expect, it } from 'vitest';
-import type { ResolveInput } from '../src/match/mbidResolver';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
@@ -8,6 +8,4 @@
 
-interface ResolverFixture {
+interface ResolverFixture extends ResolveInput {
   name: string;
-  provider: ResolveInput['provider'];
-  catalog: ResolveInput['catalog'];
   expected: {
@@ -22,8 +20,2 @@
   JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
-
-const asAudited = (result: ReturnType<typeof resolveMbid>) => result as unknown as {
-  rule: string;
-  confidence: number;
-  candidates: Array<{ confidence?: number; candidate?: { mbid: string } }>;
-};
 
@@ -47,3 +39,2 @@
       ],
-      // @ts-expect-error temporary shape for upcoming resolver work
       isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
@@ -58,5 +49,4 @@
       const fx = loadFixture(fixtureName);
-      const { expected, ...input } = fx;
+      const { expected, name: _name, ...input } = fx;
       const result = resolveMbid(input);
-      const audited = asAudited(result);
 
@@ -64,8 +54,8 @@
       expect(result?.mbid).toBe(expected.mbid);
-      expect(audited?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
-      expect(audited?.candidates?.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+      expect(result?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(result?.candidates.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
 
-      const ordered = (audited?.candidates ?? []).map(c => c.candidate?.mbid);
+      const ordered = (result as MatchResult).candidates.map(c => c.candidate.mbid);
       expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
-      expect(typeof audited?.candidates?.[0]?.confidence).toBe('number');
+      expect(typeof result?.candidates[0]?.confidence).toBe('number');
     });
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/providers/core/test/mbidResolver.test.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..1c7cf30852cdfdbf65cea8f5cfbfdcebc3c903b2
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,73 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(result?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(result?.candidates.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (result as MatchResult).candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof result?.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..1c7cf30852cdfdbf65cea8f5cfbfdcebc3c903b2
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,73 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+
+      expect(result?.rule).toBe(expected.rule);
+      expect(result?.mbid).toBe(expected.mbid);
+      expect(result?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(result?.candidates.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = (result as MatchResult).candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof result?.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Improving test null safety with type assertion**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/mbidResolver.test.ts
@@ -51,11 +51,13 @@
       const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
 
-      expect(result?.rule).toBe(expected.rule);
-      expect(result?.mbid).toBe(expected.mbid);
-      expect(result?.confidence ?? 0).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
-      expect(result?.candidates.length ?? 0).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
 
-      const ordered = (result as MatchResult).candidates.map(c => c.candidate.mbid);
+      const ordered = match.candidates.map(c => c.candidate.mbid);
       expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
-      expect(typeof result?.candidates[0]?.confidence).toBe('number');
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
     });
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/providers/core/test/mbidResolver.test.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing to run tests**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/mbidResolver.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.56s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 â¯ packages/providers/core/test/mbidResolver.test.ts (5 tests | 2 failed) 76ms
   âœ“ resolveMbid > prefers direct mbid 41ms
   âœ“ resolveMbid > maps via explicit ISRC index before heuristics 2ms
   Ã— resolveMbid > matches golden fixture: live_variation 27ms
     â†’ expected [ â€¦(3) ] to deeply equal [ â€¦(3) ]
   âœ“ resolveMbid > matches golden fixture: remaster_ladder 1ms
   Ã— resolveMbid > honors fuzzy threshold overrides 3ms
     â†’ expected { â€¦(4) } to be null

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Tests 2 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/providers/core/test/mbidResolver.test.ts > resolveMbid > matches golden fixture: live_variation
AssertionError: expected [ â€¦(3) ] to deeply equal [ â€¦(3) ]

[32m- Expected[39m
[31m+ Received[39m

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Enhancing scoring with descriptor bonuses**

I'm working on improving candidate ranking by adding a descriptor-based bonus (e.g., for "live," "remaster") that boosts scores when provider and candidate share such tags, which should fix ordering mismatches in tests and make heuristic scoring more intuitive. This involves updating interfaces, computing descriptor sets, adjusting combined scores with capped bonuses, and tuning tests to reflect the refined scoring thresholds.
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Reevaluating patch due to context changes**
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/match/mbidResolver.ts" in /var/home/rick/Development/playlist-manager succeeded in 54ms:
export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';

export interface Candidate {
  mbid: string;
  title: string;
  primaryArtist: string;
  durationMs?: number | null;
  isrc?: string | null;
}

export interface CandidateDetails {
  titleScore?: number;
  artistScore?: number;
  durationScore?: number;
  durationDeltaMs?: number;
}

export interface RankedCandidate {
  candidate: Candidate;
  confidence: number;
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..f81c761bba091fe7dddc0787753d4333f13c6139
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,390 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
 }
 
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+}
+
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Updating interface definitions for patch**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -15,2 +15,3 @@
   durationDeltaMs?: number;
+  descriptorBonus?: number;
 }
@@ -61,2 +62,3 @@
   artistTokens: Set<string>;
+  descriptors: Set<string>;
 }
@@ -70,2 +72,3 @@
   combinedScore: number;
+  descriptorBonus: number;
 }
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..cc6fd1f815e5193e2b32764f8abf299fefd91db5
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,393 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..cc6fd1f815e5193e2b32764f8abf299fefd91db5
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,393 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Adding provider descriptors extraction**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -87,2 +87,3 @@
   const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
   const providerTitleTokens = tokenSet(normalizedProviderTitle);
@@ -94,2 +95,3 @@
     providerArtistTokens,
+    providerDescriptors,
     thresholds,
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..c7c6d7f5a58f91a69a73593c6f104212480754bb
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,395 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..c7c6d7f5a58f91a69a73593c6f104212480754bb
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,395 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Updating prepareCatalog to include descriptors**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -215,2 +215,3 @@
         artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
       };
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..0e6c65073b234dea48ae28bf6c671742f160802c
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,396 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..0e6c65073b234dea48ae28bf6c671742f160802c
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,396 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing to modify buildCandidateScores function**
exec
bash -lc 'rg -n "buildCandidateScores" -n packages/providers/core/src/match/mbidResolver.ts' in /var/home/rick/Development/playlist-manager succeeded in 166ms:
91:  const candidateScores = buildCandidateScores(
226:function buildCandidateScores(
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..0e6c65073b234dea48ae28bf6c671742f160802c
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,396 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Updating function signature near line 226**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -230,2 +230,3 @@
   providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
   thresholds: ThresholdConfig,
@@ -237,3 +238,7 @@
     const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
-    const combinedScore = computeCombinedScore(titleScore, artistScore, durationScore, thresholds);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
     return {
@@ -245,2 +250,3 @@
       combinedScore,
+      descriptorBonus,
     };
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..7fe2684bc15c606d3f8f3ef18c771d54a9b49e83
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,402 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
 }
 
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
+}
+
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..7fe2684bc15c606d3f8f3ef18c771d54a9b49e83
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,402 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
 }
 
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
+}
+
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
+  }
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Adding descriptorBonus to CandidateScore and descriptors to prepared object**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -137,2 +137,3 @@
                 titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
               },
@@ -142,2 +143,3 @@
               combinedScore: 1,
+              descriptorBonus: 0,
             },
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..b0fa31b8fa88ebd7aacfd2785354a5ad2b5bd218
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,404 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
 }
 
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
+}
+
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
+  }
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..b0fa31b8fa88ebd7aacfd2785354a5ad2b5bd218
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,404 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
 }
 
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
+}
+
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
+  }
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying candidate scoring updates**
exec
bash -lc 'rg -n "extractDescriptors" packages/providers/core/src/match/mbidResolver.ts' in /var/home/rick/Development/playlist-manager succeeded in 54ms:
88:  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
218:        descriptors: extractDescriptors(normalizedTitle),
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..b0fa31b8fa88ebd7aacfd2785354a5ad2b5bd218
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,404 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
 }
 
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
+}
+
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
+
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
+  }
+
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
+  }
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
   }
-  return null;
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing to add missing functions**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -335,2 +335,23 @@
 
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
 function normalizeTitle(value: string): string {
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..52f965280c6d7fcbc7c41986555be7271deff504
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..52f965280c6d7fcbc7c41986555be7271deff504
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..0af7c754f30b62909326c86a3f250799b0d3f779
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.95 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying score integration adjustments**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/mbidResolver.test.ts
@@ -70,3 +70,3 @@
       catalog: fx.catalog,
-      thresholds: { fuzzyMin: 0.95 },
+      thresholds: { fuzzyMin: 0.99 },
     });
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M packages/providers/core/test/mbidResolver.test.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..52f965280c6d7fcbc7c41986555be7271deff504
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..52f965280c6d7fcbc7c41986555be7271deff504
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying imports and usage before tests**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/mbidResolver.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.60s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 â¯ packages/providers/core/test/mbidResolver.test.ts (5 tests | 1 failed) 36ms
   âœ“ resolveMbid > prefers direct mbid 4ms
   âœ“ resolveMbid > maps via explicit ISRC index before heuristics 2ms
   âœ“ resolveMbid > matches golden fixture: live_variation 14ms
   âœ“ resolveMbid > matches golden fixture: remaster_ladder 2ms
   Ã— resolveMbid > honors fuzzy threshold overrides 12ms
     â†’ expected { â€¦(4) } to be null

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Tests 1 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/providers/core/test/mbidResolver.test.ts > resolveMbid > honors fuzzy threshold overrides
AssertionError: expected { â€¦(4) } to be null

[32m- Expected:[39m 
null

[31m+ Received:[39m 
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..52f965280c6d7fcbc7c41986555be7271deff504
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.05, 0.1);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Adjusting descriptor bonus and threshold logic**

I'm refining the scoring to avoid saturating confidence at 1 by reducing the descriptor bonus multiplier to 0.03 and capping max bonus at 0.08. This tweak lets a 0.99 threshold correctly filter matches as null while preserving ordering benefits. I'll update the computeDescriptorBonus function and keep the test threshold as is.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/src/match/mbidResolver.ts
@@ -353,3 +353,3 @@
   if (!overlap) return 0;
-  return Math.min(overlap * 0.05, 0.1);
+  return Math.min(overlap * 0.03, 0.08);
 }
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M packages/providers/core/src/match/mbidResolver.ts
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying createRankedCandidate behavior**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/mbidResolver.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 3.40s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 âœ“ packages/providers/core/test/mbidResolver.test.ts (5 tests) 24ms

 Test Files  1 passed (1)
      Tests  5 passed (5)
   Start at  21:17:20
   Duration  728ms (transform 123ms, setup 0ms, collect 104ms, tests 24ms, environment 0ms, prepare 142ms)

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Finalizing test execution strategy**
Plan update
  âœ“ Design matching scenarios + fixtures and add failing tests for heuristic ladder + auditing outputs
  âœ“ Implement deterministic resolver with configurable thresholds + candidate ranking
  â†’ Run targeted tests, adjust as needed, and prepare commit
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing to run targeted tests**
exec
bash -lc 'pnpm vitest run packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 2.63s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 âœ“ packages/providers/core/test/mbidResolver.test.ts (5 tests) 23ms
 âœ“ packages/providers/core/test/fixtureHarness.test.ts (2 tests) 75ms

 Test Files  2 passed (2)
      Tests  7 passed (7)
   Start at  21:17:29
   Duration  538ms (transform 157ms, setup 0ms, collect 143ms, tests 98ms, environment 1ms, prepare 205ms)

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying changes before commit**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 108ms:
## main...origin/main [ahead 8]
 M packages/providers/core/src/match/mbidResolver.ts
 M packages/providers/core/test/mbidResolver.test.ts
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log.done
?? codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log
?? codex/TASKS/work_list
?? packages/providers/core/fixtures/
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing relevant files for staging**
exec
bash -lc 'git add packages/providers/core/src/match/mbidResolver.ts packages/providers/core/test/mbidResolver.test.ts packages/providers/core/fixtures/live_variation.json packages/providers/core/fixtures/remaster_ladder.json' in /var/home/rick/Development/playlist-manager succeeded in 52ms:

file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Verifying staged files**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 64ms:
## main...origin/main [ahead 8]
A  packages/providers/core/fixtures/live_variation.json
A  packages/providers/core/fixtures/remaster_ladder.json
M  packages/providers/core/src/match/mbidResolver.ts
M  packages/providers/core/test/mbidResolver.test.ts
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log.done
?? codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log
?? codex/TASKS/work_list
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Reviewing staged changes**
exec
bash -lc 'git diff --staged' in /var/home/rick/Development/playlist-manager succeeded in 104ms:
diff --git a/packages/providers/core/fixtures/live_variation.json b/packages/providers/core/fixtures/live_variation.json
new file mode 100644
index 0000000..cd58b79
--- /dev/null
+++ b/packages/providers/core/fixtures/live_variation.json
@@ -0,0 +1,38 @@
+{
+  "name": "Live performance disambiguation",
+  "provider": {
+    "title": "Don't Stop Me Now - Live in Montreal 1981",
+    "artist": "Queen feat. Freddie Mercury",
+    "durationMs": 316500
+  },
+  "catalog": [
+    {
+      "mbid": "8a68cd44-1111-4c1f-b4b2-111111111111",
+      "title": "Dont Stop Me Now (Live In Montreal)",
+      "primaryArtist": "Queen",
+      "durationMs": 316200
+    },
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Reviewing diff and updating plan**
Plan update
  âœ“ Design matching scenarios + fixtures and add failing tests for heuristic ladder + auditing outputs
  âœ“ Implement deterministic resolver with configurable thresholds + candidate ranking
  âœ“ Run targeted tests, adjust as needed, and prepare commit
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing commit message**
exec
bash -lc 'git commit -m "feat(providers): add deterministic MBID resolver heuristics"' in /var/home/rick/Development/playlist-manager succeeded in 121ms:
[main 21bdcdf] feat(providers): add deterministic MBID resolver heuristics
 4 files changed, 539 insertions(+), 31 deletions(-)
 create mode 100644 packages/providers/core/fixtures/live_variation.json
 create mode 100644 packages/providers/core/fixtures/remaster_ladder.json
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Checking git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
## main...origin/main [ahead 9]
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log.done
?? codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log
?? codex/TASKS/work_list
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Preparing comprehensive final report**
exec
bash -lc "nl -ba packages/providers/core/src/match/mbidResolver.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 100ms:
     1	export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';
     2	
     3	export interface Candidate {
     4	  mbid: string;
     5	  title: string;
     6	  primaryArtist: string;
     7	  durationMs?: number | null;
     8	  isrc?: string | null;
     9	}
    10	
    11	export interface CandidateDetails {
    12	  titleScore?: number;
    13	  artistScore?: number;
    14	  durationScore?: number;
    15	  durationDeltaMs?: number;
    16	  descriptorBonus?: number;
    17	}
    18	
    19	export interface RankedCandidate {
    20	  candidate: Candidate;
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Extracting code lines with numbering**

I'll use sed to grab lines 200 to 420 and pipe that through nl with -ba to get line numbers included. This way I can examine descriptor functions and related code in context with clear line references.
exec
bash -lc "nl -ba packages/providers/core/src/match/mbidResolver.ts | sed -n '200,420p'" in /var/home/rick/Development/playlist-manager succeeded in 54ms:
   200	    mbid: bestFuzzy.candidate.mbid,
   201	    confidence: bestFuzzy.confidence,
   202	    rule: 'fuzzy',
   203	    candidates: fuzzyMatches,
   204	  };
   205	}
   206	
   207	function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
   208	  return [...catalog]
   209	    .map(candidate => {
   210	      const normalizedTitle = normalizeTitle(candidate.title);
   211	      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
   212	      return {
   213	        candidate,
   214	        normalizedTitle,
   215	        normalizedArtist,
   216	        titleTokens: tokenSet(normalizedTitle),
   217	        artistTokens: tokenSet(normalizedArtist),
   218	        descriptors: extractDescriptors(normalizedTitle),
   219	      };
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Considering line numbers for test files**
exec
bash -lc 'nl -ba packages/providers/core/test/mbidResolver.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 58ms:
     1	import fs from 'node:fs';
     2	import path from 'node:path';
     3	import { describe, expect, it } from 'vitest';
     4	import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
     5	import { resolveMbid } from '../src/match/mbidResolver';
     6	
     7	const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
     8	
     9	interface ResolverFixture extends ResolveInput {
    10	  name: string;
    11	  expected: {
    12	    rule: string;
    13	    mbid: string;
    14	    candidateOrder: string[];
    15	    confidenceAtLeast: number;
    16	  };
    17	}
    18	
    19	const loadFixture = (name: string): ResolverFixture =>
    20	  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });


thinking
**Summarizing modifications, tests, and git details**

Iâ€™m organizing a detailed summary covering key code changes with precise file and line references, test execution, and git commit and status info. This includes noting new types and heuristics in the resolver, fixture files with line mentions, test commands run, the exact commit message used, and untracked files shown by git status, all laid out clearly with bullet points for easy reading.
codex
**Changes**
- `packages/providers/core/src/match/mbidResolver.ts:1` now exports richer resolver types (`RankedCandidate`, `ProviderTrack`, `ThresholdConfig`) and wires env/override-driven thresholds plus ISRC map support for the heuristic ladder.
- `packages/providers/core/src/match/mbidResolver.ts:82` rewrites `resolveMbid` to enforce MBID â†’ ISRC â†’ exact â†’ fuzzy priority, normalize catalog entries deterministically, and return ranked candidates with per-rule confidence + metadata for auditing.
- `packages/providers/core/src/match/mbidResolver.ts:228` adds descriptor-aware fuzzy scoring (live/remaster bonuses), duration-aware weighting, and shared scoreboards so exact matches surface alongside runner-ups with detailed confidence breakdowns.
- `packages/providers/core/test/mbidResolver.test.ts:22` loads golden fixtures, asserts ranked candidate order/confidence, verifies ISRC map precedence, and proves threshold overrides can suppress fuzzy matches.
- `packages/providers/core/fixtures/live_variation.json:1` and `packages/providers/core/fixtures/remaster_ladder.json:1` capture live/remaster edge cases that drive the new tests.

**Tests**
- `pnpm vitest run packages/providers`

**Git**
- Commit: `feat(providers): add deterministic MBID resolver heuristics`
- Status:
  ```
  ## main...origin/main [ahead 9]
  ?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
  ?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
  ?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log.done
  ?? codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log
  ?? codex/TASKS/work_list
  ```
file update:
diff --git a/packages/providers/core/src/match/mbidResolver.ts b/packages/providers/core/src/match/mbidResolver.ts
index b4722d561831bd1b32b01a771ff6529429f5dbb6..51ad55ca08587484b040abec1f3db8ad51b9f756
--- a/packages/providers/core/src/match/mbidResolver.ts
+++ b/packages/providers/core/src/match/mbidResolver.ts
@@ -8,48 +8,425 @@
   isrc?: string | null;
 }
 
+export interface CandidateDetails {
+  titleScore?: number;
+  artistScore?: number;
+  durationScore?: number;
+  durationDeltaMs?: number;
+  descriptorBonus?: number;
+}
+
+export interface RankedCandidate {
+  candidate: Candidate;
+  confidence: number;
+  rule: MatchRule;
+  details?: CandidateDetails;
+}
+
 export interface MatchResult {
   mbid: string;
   confidence: number;
   rule: MatchRule;
-  candidates: Candidate[];
+  candidates: RankedCandidate[];
+}
+
+export interface ProviderTrack {
+  title: string;
+  artist: string;
+  durationMs?: number | null;
+  isrc?: string | null;
+  mbid?: string | null;
+}
+
+export interface ThresholdConfig {
+  fuzzyMin: number;
+  durationToleranceMs: number;
+  fuzzyDurationPenaltyMs: number;
+  fuzzyTitleWeight: number;
+  fuzzyArtistWeight: number;
+  fuzzyDurationWeight: number;
 }
 
 export interface ResolveInput {
-  provider: { title: string; artist: string; durationMs?: number | null; isrc?: string | null; mbid?: string | null };
+  provider: ProviderTrack;
   catalog: Candidate[];
-  thresholds?: { fuzzyMin?: number };
+  isrcMap?: Record<string, string>;
+  thresholds?: Partial<ThresholdConfig>;
+}
+
+interface PreparedCandidate {
+  candidate: Candidate;
+  normalizedTitle: string;
+  normalizedArtist: string;
+  titleTokens: Set<string>;
+  artistTokens: Set<string>;
+  descriptors: Set<string>;
+}
+
+interface CandidateScore {
+  prepared: PreparedCandidate;
+  titleScore: number;
+  artistScore: number;
+  durationScore: number;
+  durationDeltaMs?: number;
+  combinedScore: number;
+  descriptorBonus: number;
 }
 
+const DIRECT_CONFIDENCE = 1;
+const ISRC_MAP_CONFIDENCE = 0.99;
+const ISRC_CATALOG_CONFIDENCE = 0.98;
+const EXACT_BASE_CONFIDENCE = 0.94;
+const EXACT_DECAY = 0.02;
+
 export function resolveMbid(input: ResolveInput): MatchResult | null {
-  const { provider, catalog } = input;
-  if (provider.mbid) return { mbid: provider.mbid, confidence: 1.0, rule: 'mbid', candidates: [] };
+  const thresholds = resolveThresholds(input.thresholds);
+  const provider = input.provider;
+  const normalizedCatalog = prepareCatalog(input.catalog);
+  const normalizedProviderTitle = normalizeTitle(provider.title);
+  const normalizedProviderArtist = normalizeArtist(provider.artist);
+  const providerDescriptors = extractDescriptors(normalizedProviderTitle);
+  const providerTitleTokens = tokenSet(normalizedProviderTitle);
+  const providerArtistTokens = tokenSet(normalizedProviderArtist);
+  const candidateScores = buildCandidateScores(
+    provider,
+    normalizedCatalog,
+    providerTitleTokens,
+    providerArtistTokens,
+    providerDescriptors,
+    thresholds,
+  );
 
-  if (provider.isrc) {
-    const hit = catalog.find(c => (c.isrc ?? '').toUpperCase() === provider.isrc!.toUpperCase());
-    if (hit) return { mbid: hit.mbid, confidence: 0.98, rule: 'isrc', candidates: [hit] };
+  if (provider.mbid) {
+    return {
+      mbid: provider.mbid,
+      confidence: DIRECT_CONFIDENCE,
+      rule: 'mbid',
+      candidates: [],
+    };
   }
 
-  const exact = catalog.find(c =>
-    c.title.toLowerCase() === provider.title.toLowerCase() &&
-    c.primaryArtist.toLowerCase() === provider.artist.toLowerCase() &&
-    (provider.durationMs && c.durationMs ? Math.abs(c.durationMs - provider.durationMs) < 1500 : true)
+  const providerIsrc = normalizeIsrc(provider.isrc);
+  const normalizedIsrcMap = normalizeIsrcMap(input.isrcMap);
+
+  if (providerIsrc) {
+    const mapHit = normalizedIsrcMap?.[providerIsrc];
+    if (mapHit) {
+      const catalogCandidate =
+        normalizedCatalog.find(entry => entry.candidate.mbid === mapHit)?.candidate ??
+        normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc)?.candidate ??
+        {
+          mbid: mapHit,
+          title: provider.title,
+          primaryArtist: provider.artist,
+          durationMs: provider.durationMs,
+          isrc: provider.isrc,
+        };
+      return {
+        mbid: mapHit,
+        confidence: ISRC_MAP_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            {
+              prepared: {
+                candidate: catalogCandidate,
+                normalizedArtist: normalizedProviderArtist,
+                normalizedTitle: normalizedProviderTitle,
+                artistTokens: providerArtistTokens,
+                titleTokens: providerTitleTokens,
+                descriptors: providerDescriptors,
+              },
+              titleScore: 1,
+              artistScore: 1,
+              durationScore: 1,
+              combinedScore: 1,
+              descriptorBonus: 0,
+            },
+            'isrc',
+            ISRC_MAP_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+
+    const catalogHit = normalizedCatalog.find(entry => normalizeIsrc(entry.candidate.isrc) === providerIsrc);
+    if (catalogHit) {
+      return {
+        mbid: catalogHit.candidate.mbid,
+        confidence: ISRC_CATALOG_CONFIDENCE,
+        rule: 'isrc',
+        candidates: [
+          createRankedCandidate(
+            candidateScores.find(score => score.prepared.candidate.mbid === catalogHit.candidate.mbid)!,
+            'isrc',
+            ISRC_CATALOG_CONFIDENCE,
+          ),
+        ],
+      };
+    }
+  }
+
+  const exactMatches = normalizedCatalog.filter(entry =>
+    entry.normalizedTitle === normalizedProviderTitle &&
+    entry.normalizedArtist === normalizedProviderArtist &&
+    withinDuration(provider.durationMs, entry.candidate.durationMs, thresholds.durationToleranceMs)
   );
-  if (exact) return { mbid: exact.mbid, confidence: 0.92, rule: 'exact', candidates: [exact] };
 
-  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
-  const toks = (s: string) => new Set(s.toLowerCase().split(/\s+/));
-  let best: { score: number; c: Candidate } | null = null;
-  for (const c of catalog) {
-    const a = toks(provider.title + ' ' + provider.artist);
-    const b = toks(c.title + ' ' + c.primaryArtist);
-    const inter = [...a].filter(x => b.has(x)).length;
-    const union = new Set([...a, ...b]).size;
-    const score = union ? inter / union : 0;
-    if (!best || score > best.score) best = { score, c };
+  if (exactMatches.length) {
+    const scoreboard = buildScoreboard(candidateScores, exactMatches.map(match => match.candidate.mbid));
+    const winner = scoreboard.find(candidate => candidate.rule === 'exact');
+    if (winner) {
+      return {
+        mbid: winner.candidate.mbid,
+        confidence: winner.confidence,
+        rule: 'exact',
+        candidates: scoreboard,
+      };
+    }
   }
-  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
-    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
+
+  const fuzzyMatches = candidateScores
+    .filter(score => score.combinedScore > 0)
+    .map(score => createRankedCandidate(score, 'fuzzy', score.combinedScore))
+    .sort(sortRankedCandidates);
+
+  const bestFuzzy = fuzzyMatches[0];
+  if (!bestFuzzy || bestFuzzy.confidence < thresholds.fuzzyMin) {
+    return null;
   }
-  return null;
+
+  return {
+    mbid: bestFuzzy.candidate.mbid,
+    confidence: bestFuzzy.confidence,
+    rule: 'fuzzy',
+    candidates: fuzzyMatches,
+  };
+}
+
+function prepareCatalog(catalog: Candidate[]): PreparedCandidate[] {
+  return [...catalog]
+    .map(candidate => {
+      const normalizedTitle = normalizeTitle(candidate.title);
+      const normalizedArtist = normalizeArtist(candidate.primaryArtist);
+      return {
+        candidate,
+        normalizedTitle,
+        normalizedArtist,
+        titleTokens: tokenSet(normalizedTitle),
+        artistTokens: tokenSet(normalizedArtist),
+        descriptors: extractDescriptors(normalizedTitle),
+      };
+    })
+    .sort((a, b) =>
+      a.normalizedTitle.localeCompare(b.normalizedTitle) ||
+      a.normalizedArtist.localeCompare(b.normalizedArtist) ||
+      a.candidate.mbid.localeCompare(b.candidate.mbid)
+    );
+}
+
+function buildCandidateScores(
+  provider: ProviderTrack,
+  catalog: PreparedCandidate[],
+  providerTitleTokens: Set<string>,
+  providerArtistTokens: Set<string>,
+  providerDescriptors: Set<string>,
+  thresholds: ThresholdConfig,
+): CandidateScore[] {
+  return catalog.map(entry => {
+    const durationDeltaMs = computeDurationDelta(provider.durationMs, entry.candidate.durationMs);
+    const durationScore = computeDurationScore(durationDeltaMs, thresholds);
+    const titleScore = diceCoefficient(providerTitleTokens, entry.titleTokens);
+    const artistScore = diceCoefficient(providerArtistTokens, entry.artistTokens);
+    const descriptorBonus = computeDescriptorBonus(providerDescriptors, entry.descriptors);
+    const combinedScore = Math.min(
+      1,
+      computeCombinedScore(titleScore, artistScore, durationScore, thresholds) + descriptorBonus,
+    );
+    return {
+      prepared: entry,
+      titleScore,
+      artistScore,
+      durationScore,
+      durationDeltaMs: durationDeltaMs ?? undefined,
+      combinedScore,
+      descriptorBonus,
+    };
+  });
+}
+
+function buildScoreboard(scores: CandidateScore[], exactMbids: string[]): RankedCandidate[] {
+  return scores
+    .filter(score => score.combinedScore > 0 || exactMbids.includes(score.prepared.candidate.mbid))
+    .map(score => {
+      const idx = exactMbids.indexOf(score.prepared.candidate.mbid);
+      if (idx === -1) {
+        return createRankedCandidate(score, 'fuzzy', score.combinedScore);
+      }
+      const confidence = Math.max(0.7, EXACT_BASE_CONFIDENCE - idx * EXACT_DECAY);
+      return createRankedCandidate(score, 'exact', confidence);
+    })
+    .sort(sortRankedCandidates);
+}
+
+function createRankedCandidate(score: CandidateScore, rule: MatchRule, confidence: number): RankedCandidate {
+  return {
+    candidate: score.prepared.candidate,
+    confidence: roundScore(confidence),
+    rule,
+    details: {
+      titleScore: roundScore(score.titleScore),
+      artistScore: roundScore(score.artistScore),
+      durationScore: roundScore(score.durationScore),
+      durationDeltaMs: score.durationDeltaMs,
+    },
+  };
+}
+
+function sortRankedCandidates(a: RankedCandidate, b: RankedCandidate): number {
+  if (a.confidence !== b.confidence) return b.confidence - a.confidence;
+  return a.candidate.mbid.localeCompare(b.candidate.mbid);
+}
+
+function roundScore(value: number): number {
+  return Math.round(Math.min(Math.max(value, 0), 1) * 1000) / 1000;
+}
+
+function computeDurationDelta(a?: number | null, b?: number | null): number | null {
+  if (!isFiniteNumber(a) || !isFiniteNumber(b)) return null;
+  return Math.abs((a ?? 0) - (b ?? 0));
+}
+
+function computeDurationScore(delta: number | null, thresholds: ThresholdConfig): number {
+  if (delta === null) return 0.5;
+  if (delta <= 0) return 1;
+  if (delta >= thresholds.fuzzyDurationPenaltyMs) return 0;
+  return 1 - delta / thresholds.fuzzyDurationPenaltyMs;
+}
+
+function computeCombinedScore(
+  titleScore: number,
+  artistScore: number,
+  durationScore: number,
+  thresholds: ThresholdConfig,
+): number {
+  const weightSum = thresholds.fuzzyTitleWeight + thresholds.fuzzyArtistWeight + thresholds.fuzzyDurationWeight;
+  if (!weightSum) return 0;
+  const weighted =
+    titleScore * thresholds.fuzzyTitleWeight +
+    artistScore * thresholds.fuzzyArtistWeight +
+    durationScore * thresholds.fuzzyDurationWeight;
+  return weighted / weightSum;
+}
+
+function diceCoefficient(left: Set<string>, right: Set<string>): number {
+  if (!left.size || !right.size) return 0;
+  let intersection = 0;
+  left.forEach(token => {
+    if (right.has(token)) intersection += 1;
+  });
+  return (2 * intersection) / (left.size + right.size);
+}
+
+function tokenSet(value: string): Set<string> {
+  const tokens = value.split(' ').filter(Boolean);
+  return new Set(tokens);
+}
+
+function extractDescriptors(normalizedTitle: string): Set<string> {
+  const descriptors = new Set<string>();
+  if (/\blive\b/.test(normalizedTitle)) descriptors.add('live');
+  if (/\bacoustic\b/.test(normalizedTitle)) descriptors.add('acoustic');
+  if (/\bremaster\b/.test(normalizedTitle)) descriptors.add('remaster');
+  if (/\bremix\b/.test(normalizedTitle)) descriptors.add('remix');
+  if (/\bdemo\b/.test(normalizedTitle)) descriptors.add('demo');
+  if (/\binstrumental\b/.test(normalizedTitle)) descriptors.add('instrumental');
+  return descriptors;
+}
+
+function computeDescriptorBonus(providerDescriptors: Set<string>, candidateDescriptors: Set<string>): number {
+  if (!providerDescriptors.size || !candidateDescriptors.size) return 0;
+  let overlap = 0;
+  providerDescriptors.forEach(descriptor => {
+    if (candidateDescriptors.has(descriptor)) overlap += 1;
+  });
+  if (!overlap) return 0;
+  return Math.min(overlap * 0.03, 0.08);
+}
+
+function normalizeTitle(value: string): string {
+  return normalizeString(value).replace(/\bremastered\b/g, 'remaster');
+}
+
+function normalizeArtist(value: string): string {
+  return normalizeString(value.replace(/\b(feat|ft)\.?.*/gi, ''));
+}
+
+function normalizeString(value: string): string {
+  return value
+    .normalize('NFKD')
+    .replace(/[\u0300-\u036f]/g, '')
+    .replace(/&/g, ' and ')
+    .replace(/['â€™]/g, '')
+    .replace(/[^a-z0-9\s]/gi, ' ')
+    .replace(/\s+/g, ' ')
+    .trim()
+    .toLowerCase();
+}
+
+function normalizeIsrc(value?: string | null): string {
+  if (!value) return '';
+  return value.replace(/[^0-9a-z]/gi, '').toUpperCase();
+}
+
+function normalizeIsrcMap(map?: Record<string, string>): Record<string, string> | null {
+  if (!map) return null;
+  const normalized: Record<string, string> = {};
+  for (const [key, value] of Object.entries(map)) {
+    const normalizedKey = normalizeIsrc(key);
+    if (!normalizedKey) continue;
+    normalized[normalizedKey] = value;
+  }
+  return normalized;
+}
+
+function withinDuration(
+  providerDuration?: number | null,
+  candidateDuration?: number | null,
+  tolerance?: number,
+): boolean {
+  const delta = computeDurationDelta(providerDuration, candidateDuration);
+  if (delta === null) return true;
+  return delta <= (tolerance ?? 0);
+}
+
+function isFiniteNumber(value?: number | null): value is number {
+  return typeof value === 'number' && Number.isFinite(value);
+}
+
+function resolveThresholds(overrides?: Partial<ThresholdConfig>): ThresholdConfig {
+  const defaults: ThresholdConfig = {
+    fuzzyMin: envNumber('PROVIDERS_MBID_FUZZY_MIN', 0.68),
+    durationToleranceMs: envNumber('PROVIDERS_MBID_DURATION_TOLERANCE_MS', 1500),
+    fuzzyDurationPenaltyMs: envNumber('PROVIDERS_MBID_FUZZY_DURATION_PENALTY_MS', 6000),
+    fuzzyTitleWeight: envNumber('PROVIDERS_MBID_FUZZY_TITLE_WEIGHT', 0.6),
+    fuzzyArtistWeight: envNumber('PROVIDERS_MBID_FUZZY_ARTIST_WEIGHT', 0.3),
+    fuzzyDurationWeight: envNumber('PROVIDERS_MBID_FUZZY_DURATION_WEIGHT', 0.1),
+  };
+  if (!overrides) return defaults;
+  return {
+    fuzzyMin: overrides.fuzzyMin ?? defaults.fuzzyMin,
+    durationToleranceMs: overrides.durationToleranceMs ?? defaults.durationToleranceMs,
+    fuzzyDurationPenaltyMs: overrides.fuzzyDurationPenaltyMs ?? defaults.fuzzyDurationPenaltyMs,
+    fuzzyTitleWeight: overrides.fuzzyTitleWeight ?? defaults.fuzzyTitleWeight,
+    fuzzyArtistWeight: overrides.fuzzyArtistWeight ?? defaults.fuzzyArtistWeight,
+    fuzzyDurationWeight: overrides.fuzzyDurationWeight ?? defaults.fuzzyDurationWeight,
+  };
+}
+
+function envNumber(key: string, fallback: number): number {
+  const raw = process.env[key];
+  if (!raw) return fallback;
+  const parsed = Number(raw);
+  return Number.isFinite(parsed) ? parsed : fallback;
 }
diff --git a/packages/providers/core/test/mbidResolver.test.ts b/packages/providers/core/test/mbidResolver.test.ts
index 1a716d966c3818166279e68810f0424202e46004..87fbcfa5ca27c49b1ae5e2c3652eb4fb30da00c4
--- a/packages/providers/core/test/mbidResolver.test.ts
+++ b/packages/providers/core/test/mbidResolver.test.ts
@@ -1,20 +1,75 @@
-import { describe, it, expect } from 'vitest';
+import fs from 'node:fs';
+import path from 'node:path';
+import { describe, expect, it } from 'vitest';
+import type { MatchResult, ResolveInput } from '../src/match/mbidResolver';
 import { resolveMbid } from '../src/match/mbidResolver';
 
+const FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/fixtures');
+
+interface ResolverFixture extends ResolveInput {
+  name: string;
+  expected: {
+    rule: string;
+    mbid: string;
+    candidateOrder: string[];
+    confidenceAtLeast: number;
+  };
+}
+
+const loadFixture = (name: string): ResolverFixture =>
+  JSON.parse(fs.readFileSync(path.join(FIXTURE_DIR, `${name}.json`), 'utf8')) as ResolverFixture;
+
 describe('resolveMbid', () => {
   it('prefers direct mbid', () => {
     const r = resolveMbid({
       provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
-      catalog: []
+      catalog: [],
     });
+
     expect(r?.rule).toBe('mbid');
+    expect(r?.confidence).toBe(1);
+    expect(r?.candidates).toEqual([]);
   });
 
-  it('matches by isrc', () => {
+  it('maps via explicit ISRC index before heuristics', () => {
     const r = resolveMbid({
       provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
-      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
+      catalog: [
+        { mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', durationMs: 201000 },
+      ],
+      isrcMap: { 'US-ABC-123': 'mapped-mbid-42' },
     });
+
     expect(r?.rule).toBe('isrc');
+    expect(r?.mbid).toBe('mapped-mbid-42');
+  });
+
+  for (const fixtureName of ['live_variation', 'remaster_ladder'] as const) {
+    it(`matches golden fixture: ${fixtureName}`, () => {
+      const fx = loadFixture(fixtureName);
+      const { expected, name: _name, ...input } = fx;
+      const result = resolveMbid(input);
+      expect(result).not.toBeNull();
+      const match = result as MatchResult;
+
+      expect(match.rule).toBe(expected.rule);
+      expect(match.mbid).toBe(expected.mbid);
+      expect(match.confidence).toBeGreaterThanOrEqual(expected.confidenceAtLeast);
+      expect(match.candidates.length).toBeGreaterThanOrEqual(expected.candidateOrder.length);
+
+      const ordered = match.candidates.map(c => c.candidate.mbid);
+      expect(ordered.slice(0, expected.candidateOrder.length)).toEqual(expected.candidateOrder);
+      expect(typeof match.candidates[0]?.confidence).toBe('number');
+    });
+  }
+
+  it('honors fuzzy threshold overrides', () => {
+    const fx = loadFixture('live_variation');
+    const result = resolveMbid({
+      provider: fx.provider,
+      catalog: fx.catalog,
+      thresholds: { fuzzyMin: 0.99 },
+    });
+    expect(result).toBeNull();
   });
 });

tokens used
123,165
**Changes**
- `packages/providers/core/src/match/mbidResolver.ts:1` now exports richer resolver types (`RankedCandidate`, `ProviderTrack`, `ThresholdConfig`) and wires env/override-driven thresholds plus ISRC map support for the heuristic ladder.
- `packages/providers/core/src/match/mbidResolver.ts:82` rewrites `resolveMbid` to enforce MBID â†’ ISRC â†’ exact â†’ fuzzy priority, normalize catalog entries deterministically, and return ranked candidates with per-rule confidence + metadata for auditing.
- `packages/providers/core/src/match/mbidResolver.ts:228` adds descriptor-aware fuzzy scoring (live/remaster bonuses), duration-aware weighting, and shared scoreboards so exact matches surface alongside runner-ups with detailed confidence breakdowns.
- `packages/providers/core/test/mbidResolver.test.ts:22` loads golden fixtures, asserts ranked candidate order/confidence, verifies ISRC map precedence, and proves threshold overrides can suppress fuzzy matches.
- `packages/providers/core/fixtures/live_variation.json:1` and `packages/providers/core/fixtures/remaster_ladder.json:1` capture live/remaster edge cases that drive the new tests.

**Tests**
- `pnpm vitest run packages/providers`

**Git**
- Commit: `feat(providers): add deterministic MBID resolver heuristics`
- Status:
  ```
  ## main...origin/main [ahead 9]
  ?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
  ?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
  ?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log.done
  ?? codex/LOGS/tasklog_06z_track_matching_heuristics_1762481033.log
  ?? codex/TASKS/work_list
  ```
