OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5671-6a0c-78a0-863a-79416880fc2c
--------
user
Implement the functionality described in codex/TASKS/02d_db_indexes_bench.yaml, then verify with any available tests.

thinking
**Preparing to inspect task instructions**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
00_repo_sanity_review.yaml
01a_spec_bootstrap.yaml
02a_prisma_init.yaml
02b_raw_migrations.yaml
02c_prisma_seeds.yaml
02d_db_indexes_bench.yaml
03a_dbpkg_singleton.yaml
03b_db_migration_ci_gate.yaml
03c_token_encryption_at_rest.yaml
04a_api_validation_wiring.yaml
04b_openapi_warning_silencer.yaml
04c_api_docs_ui.yaml
04d_config_feature_flags.yaml
05a_pif_validator.yaml
05b_file_exporters.yaml
05c_importers_file.yaml
06a_provider_interfaces.yaml
06b_spotify_impl.yaml

thinking
**Opening task 02d**
exec
bash -lc 'cat codex/TASKS/02d_db_indexes_bench.yaml' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 02d_db_indexes_bench
title: DB hot-path indexes + EXPLAIN checks
branch: codex/02d_db_indexes_bench
overview: >
  Add pragmatic indexes (FKs, unique, partial) and trigram for fuzzy title/artist search. Include tiny scripts that
  run EXPLAIN (ANALYZE, BUFFERS) on representative queries in CI to catch regressions.
acceptance:
  - migration adds indexes without locking issues (dev)
  - scripts/explain/*.sql exist; CI job runs them against seeded data
artifacts_to_touch:
  - prisma/migrations/2025xxxx_indexes/migration.sql
  - scripts/explain/{playlists.sql, items.sql, fuzzy_search.sql}
  - .github/workflows/ci.yml (add explain step)
steps:
  - Create indexes for playlist lookups, MBID resolution, follow tables
  - Add pg_trgm extension and trigram indexes where needed

thinking
**Inspecting database migrations and structure**
exec
bash -lc 'ls prisma/migrations' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
ls: cannot access 'prisma/migrations': No such file or directory

thinking
**Checking Prisma setup**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Searching for prisma directory**
exec
bash -lc 'find . -maxdepth 2 -type d -name prisma' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Checking for migration setup**
exec
bash -lc "rg \"schema.prisma\" -g'schema.prisma'" in /var/home/rick/Development/playlist-manager exited 1 in 200ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Searching for Prisma usage**
exec
bash -lc "find . -name 'schema.prisma'" in /var/home/rick/Development/playlist-manager succeeded in 307ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
./packages/db/prisma/schema.prisma
./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/.prisma/client/schema.prisma

thinking
**Inspecting Prisma directory**
exec
bash -lc 'ls packages/db' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
node_modules
package.json
prisma
src
test
tsconfig.json

thinking
**Checking prisma migrations directory**
exec
bash -lc 'ls packages/db/prisma' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
migrations
schema.prisma
seed-data
seed.ts

thinking
**Inspecting database migrations**
exec
bash -lc 'ls packages/db/prisma/migrations' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
20251030162157_init
20251030170000_raw_extras
20251105093632_
20251105094423_test2
migration_lock.toml

thinking
**Reviewing existing migrations**
exec
bash -lc 'ls packages/db/prisma/migrations/20251030162157_init' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
migration.sql

thinking
**Opening file**
exec
bash -lc "sed -n '1,160p' packages/db/prisma/migrations/20251030162157_init/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 53ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
-- CreateTable
CREATE TABLE "app_user" (
    "id" SERIAL NOT NULL,
    "email" TEXT,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "app_user_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "account" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "provider" TEXT NOT NULL,
    "provider_user_id" TEXT NOT NULL,
    "access_token" TEXT,
    "refresh_token" TEXT,
    "expires_at" TIMESTAMPTZ,

thinking
**Continuing index inspection**
exec
bash -lc "sed -n '160,320p' packages/db/prisma/migrations/20251030162157_init/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

-- CreateTable
CREATE TABLE "artist_relation" (
    "id" SERIAL NOT NULL,
    "src_artist_id" INTEGER NOT NULL,
    "rel_type" TEXT NOT NULL,
    "dst_artist_id" INTEGER NOT NULL,
    "confidence" DOUBLE PRECISION,
    "updated_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "artist_relation_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "artist_follow" (
    "id" SERIAL NOT NULL,
    "user_id" INTEGER NOT NULL,
    "artist_id" INTEGER NOT NULL,

thinking
**Reviewing migration files**
exec
bash -lc "sed -n '1,160p' packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
-- 1) Partial unique index: only one non-null ISRC per recording
CREATE UNIQUE INDEX IF NOT EXISTS uq_recording_isrc_not_null
ON "recording" ("isrc") WHERE "isrc" IS NOT NULL;

-- 2) Touch-updated_at trigger (generic)
CREATE OR REPLACE FUNCTION touch_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

-- Attach to tables that have updated_at
DO $$
DECLARE
  tbl text;
BEGIN
  FOREACH tbl IN ARRAY ARRAY[
    'playlist','recording','album','artist',

thinking
**Inspecting additional migrations**
exec
bash -lc "sed -n '1,160p' packages/db/prisma/migrations/20251105093632_/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
-- DropIndex
DROP INDEX "idx_recording_album_id";

-- DropIndex
DROP INDEX "idx_recording_artist_ord";

-- DropIndex
DROP INDEX "idx_recording_artist_rec";

thinking
**Noticing a new migration**
exec
bash -lc "sed -n '1,160p' packages/db/prisma/migrations/20251105094423_test2/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/*
  Warnings:

  - Made the column `email` on table `app_user` required. This step will fail if there are existing NULL values in that column.

*/
-- AlterTable
ALTER TABLE "app_user" ADD COLUMN     "name" TEXT,
ALTER COLUMN "email" SET NOT NULL;

thinking
**Reviewing migration requirements and tests**
exec
bash -lc 'ls packages/db/test' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
seed.test.ts

thinking
**Opening file**
exec
bash -lc "sed -n '1,160p' packages/db/test/seed.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { beforeEach, afterAll, expect, test } from 'vitest';
import { prisma } from '../src/client';
import { runSeed } from '../prisma/seed';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,

thinking
**Planning tests and migrations for DB indexes**

I’m thinking through setting up tests before coding, following TDD and ADR-005 specs, focusing on verifying new indexes via migrations and scripts. I want to ensure migration creates indexes (possibly with `CREATE INDEX CONCURRENTLY`) without locking issues, handle `pg_trgm` extension idempotently, place tests under `packages/db/test`, and check CI for running explain scripts on seeded data. There’s a lot to cover around Prisma migration constraints and how to run index creation safely.
exec
bash -lc "sed -n '1,200p' .github/workflows/ci.yml" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
name: CI

on:
  push:
    branches: [ main, develop, development-branch, feature/** ]
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  spec-and-types:
    runs-on: ubuntu-latest
    steps:

thinking
**Adding explain scripts step**
exec
bash -lc 'cat packages/db/package.json' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "@app/db",
  "private": true,
  "type": "module",
  "scripts": {
    "prisma": "prisma",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0"
  },
  "devDependencies": {

thinking
**Checking directory locations for scripts**
exec
bash -lc 'ls scripts' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
check-breaking.mjs
db
dev
schemathesis.mjs
wait

thinking
**Inspecting scripts/db directory**
exec
bash -lc 'ls scripts/db' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
down.ts
up.ts

thinking
**Devising test-driven plan**

I'm mapping out a TDD approach to verify database indexes and extensions, considering challenges with testing migrations and explanations in a potentially limited environment, and planning to write tests first before implementing changes. I'll organize a stepwise plan to cover analysis, test creation, implementation, and verification.
Plan update
  → Design coverage for new DB indexes and EXPLAIN scripts; inspect existing schema and CI.
  • Add failing tests describing required indexes/extension/EXPLAIN script presence.
  • Implement migration, SQL scripts, and CI workflow updates to satisfy tests.
  • Run relevant test suite (or document blockers) and ensure green.

thinking
**Closing initial step**
Plan update
  ✓ Design coverage for new DB indexes and EXPLAIN scripts; inspect existing schema and CI.
  → Add failing tests describing required indexes/extension/EXPLAIN script presence.
  • Implement migration, SQL scripts, and CI workflow updates to satisfy tests.
  • Run relevant test suite (or document blockers) and ensure green.

thinking
**Planning database index tests**
exec
bash -lc "rg \"prisma\\.playlist\" -n" in /var/home/rick/Development/playlist-manager succeeded in 76ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:13:  await prisma.playlistItem.deleteMany();
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:15:  await prisma.playlist.deleteMany();
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:31:  const p = await prisma.playlist.create({ data: { user_id: userId, name: 't' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:33:  const u = await prisma.playlist.update({ where: { id: p.id }, data: { name: 'u' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:38:  const playlist = await prisma.playlist.create({ data: { user_id: userId, name: 'snap' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:39:  const item = await prisma.playlistItem.create({
packages/db/test/seed.test.ts:75:  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
packages/db/test/seed.test.ts:97:  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:13:  await prisma.playlist.deleteMany();
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:23:  const p = await prisma.playlist.create({ data: { user_id: userId, name: 'Smoke' } });
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:24:  const r = await prisma.playlist.findUnique({ where: { id: p.id } });
packages/db/prisma/seed.ts:155:  let playlist = await prisma.playlist.findFirst({
packages/db/prisma/seed.ts:162:    playlist = await prisma.playlist.create({
packages/db/prisma/seed.ts:170:    playlist = await prisma.playlist.update({
packages/db/prisma/seed.ts:183:    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
packages/db/prisma/seed.ts:189:  await prisma.playlistItem.deleteMany({
packages/db/prisma/seed.ts:205:    await prisma.playlistItem.upsert({
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:393:-  const playlist = await prisma.playlist.findFirst({

thinking
**Exploring database query modules**
exec
bash -lc 'ls packages/db/src' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
client.ts
encryption
healthcheck.ts
index.ts

thinking
**Evaluating index additions and fuzzy search**

I’m thinking through which indexes to add or verify for playlist lookups, MBID resolution, and follow tables, balancing existing unique indexes and needed retrieval queries. I’m also considering where to add trigram indexes to support fuzzy search on artist names and recording titles while figuring out the best way to test their creation. Let’s explore fuzzy search mentions next!
exec
bash -lc 'rg "fuzzy" -n' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
openapi.dredd.yaml:481:          matched_fuzzy_pct:
openapi.yaml:598:            matched_fuzzy_pct: { type: number }
packages/providers/core/src/match/mbidResolver.ts:1:export type MatchRule = 'mbid' | 'isrc' | 'exact' | 'fuzzy';
packages/providers/core/src/match/mbidResolver.ts:21:  thresholds?: { fuzzyMin?: number };
packages/providers/core/src/match/mbidResolver.ts:40:  // naive fuzzy: Jaccard over tokens (replace later with proper scoring)
packages/providers/core/src/match/mbidResolver.ts:51:  if (best && best.score >= (input.thresholds?.fuzzyMin ?? 0.6)) {
packages/providers/core/src/match/mbidResolver.ts:52:    return { mbid: best.c.mbid, confidence: best.score, rule: 'fuzzy', candidates: [best.c] };
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:50:  Add pragmatic indexes (FKs, unique, partial) and trigram for fuzzy title/artist search. Include tiny scripts that
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:57:  - scripts/explain/{playlists.sql, items.sql, fuzzy_search.sql}
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:430:**Evaluating index additions and fuzzy search**
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:432:I’m thinking through which indexes to add or verify for playlist lookups, MBID resolution, and follow tables, balancing existing unique indexes and needed retrieval queries. I’m also considering where to add trigram indexes to support fuzzy search on artist names and recording titles while figuring out the best way to test their creation. Let’s explore fuzzy search mentions next!
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:434:bash -lc 'rg "fuzzy" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/02d_db_indexes_bench.yaml:5:  Add pragmatic indexes (FKs, unique, partial) and trigram for fuzzy title/artist search. Include tiny scripts that
codex/TASKS/02d_db_indexes_bench.yaml:12:  - scripts/explain/{playlists.sql, items.sql, fuzzy_search.sql}
codex/TASKS/08d_worker_jobs_migrate.yaml:6:  Produce a report (matched_isrc_pct, matched_fuzzy_pct, unresolved).
packages/contracts/src/api.types.ts:276:                matched_fuzzy_pct?: number;
codex/TASKS/06z_track_matching_heuristics.yaml:7:  (4) fuzzy title+artist with thresholds. Provide unit tests and golden fixtures.
apps/api/src/routes/_mockData.ts:35:    matched_fuzzy_pct: number;

thinking
**Checking previous log file**
exec
bash -lc "sed -n '400,520p' codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:15:  await prisma.playlist.deleteMany();
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:31:  const p = await prisma.playlist.create({ data: { user_id: userId, name: 't' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:33:  const u = await prisma.playlist.update({ where: { id: p.id }, data: { name: 'u' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:38:  const playlist = await prisma.playlist.create({ data: { user_id: userId, name: 'snap' } });
codex/code/codex/02b_raw_migrations/tests/db.raw.sql.test.ts:39:  const item = await prisma.playlistItem.create({
packages/db/test/seed.test.ts:75:  const playlistFirstRun = await prisma.playlist.findFirstOrThrow({
packages/db/test/seed.test.ts:97:  const playlistSecondRun = await prisma.playlist.findFirstOrThrow({
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:13:  await prisma.playlist.deleteMany();
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:23:  const p = await prisma.playlist.create({ data: { user_id: userId, name: 'Smoke' } });
codex/code/codex/02a_prisma_init/tests/db.smoke.test.ts:24:  const r = await prisma.playlist.findUnique({ where: { id: p.id } });
packages/db/prisma/seed.ts:155:  let playlist = await prisma.playlist.findFirst({
packages/db/prisma/seed.ts:162:    playlist = await prisma.playlist.create({
packages/db/prisma/seed.ts:170:    playlist = await prisma.playlist.update({
packages/db/prisma/seed.ts:183:    await prisma.playlistItem.deleteMany({ where: { playlist_id: playlist.id } });
packages/db/prisma/seed.ts:189:  await prisma.playlistItem.deleteMany({
packages/db/prisma/seed.ts:205:    await prisma.playlistItem.upsert({
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:393:-  const playlist = await prisma.playlist.findFirst({


thinking
**Reviewing previous logs for insights**
exec
bash -lc "sed -n '520,760p' codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Planning database index tests**

I’m sketching detailed test ideas to verify the presence of pg_trgm extension and various hot-path indexes on tables like playlist, artist_follow, and recording; I want these tests to follow TDD by existing first and fail before the indexes exist. I'll also verify explain script files for expected content, while thinking through how to handle resets, seeding, and import helpers to keep tests reliable and maintainable.
file update
A /var/home/rick/Development/playlist-manager/packages/db/test/indexes.test.ts
import { afterAll, describe, expect, test } from 'vitest';
import { prisma } from '../src/client';

async function fetchIndexMap(table: string) {
  const rows = await prisma.$queryRaw<
    Array<{ indexname: string; indexdef: string }>
  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
}

afterAll(async () => {
  await prisma.$disconnect();
});

describe('hot-path indexes', () => {
  test('playlist lookups use user scope index', async () => {
    const indexes = await fetchIndexMap('playlist');
    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
  });

  test('playlist items join on recording id without sequential scan', async () => {
    const indexes = await fetchIndexMap('playlist_item');
    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
  });

  test('artist follows resolve by artist efficiently', async () => {
    const indexes = await fetchIndexMap('artist_follow');
    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
  });
});

describe('fuzzy search support', () => {
  test('pg_trgm extension is installed', async () => {
    const [{ exists }] = await prisma.$queryRaw<
      Array<{ exists: boolean }>
    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
    expect(exists).toBe(true);
  });

  test('artist and recording trigram indexes are present', async () => {
    const artistIndexes = await fetchIndexMap('artist');
    const recordingIndexes = await fetchIndexMap('recording');

    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
      /USING gin/i,
    );
  });
});
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
A packages/db/test/indexes.test.ts
file update:
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});

file update:
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Ensuring safe test assertions for index definitions**
file update
A /var/home/rick/Development/playlist-manager/packages/db/test/explain_scripts.test.ts
import { readFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { describe, expect, test } from 'vitest';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const scriptsRoot = resolve(__dirname, '../../scripts/explain');
const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];

describe('EXPLAIN plans', () => {
  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
  });
});
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A packages/db/test/explain_scripts.test.ts
file update:
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});

file update:
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Updating test plan status**
Plan update
  ✓ Design coverage for new DB indexes and EXPLAIN scripts; inspect existing schema and CI.
  ✓ Add failing tests describing required indexes/extension/EXPLAIN script presence.
  → Implement migration, SQL scripts, and CI workflow updates to satisfy tests.
  • Run relevant test suite (or document blockers) and ensure green.
file update:
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Executing comprehensive database migration planning**

I’m outlining how to implement a detailed database migration by adding indexes and trigram extensions with precise timestamped naming to avoid conflicts. I’m carefully considering Postgres transaction behavior, index naming conventions, and which pragmatic indexes—regular, partial, unique, and trigram—to include for optimized querying while aligning with test expectations and existing schema nuances. Next, I’ll create the migration file and directory accordingly.
file update
A /var/home/rick/Development/playlist-manager/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
-- Enable trigram search capability for fuzzy lookups
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Playlists queried by user most frequently; include updated_at for recency sorts
CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
ON "playlist" ("user_id", "updated_at" DESC);

-- Playlist items joined to recordings for normalization pipelines
CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
ON "playlist_item" ("recording_id");

-- Follow lists queried by artist (fan counts, discovery)
CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
ON "artist_follow" ("artist_id");

-- Fuzzy lookup support for artist and track search
CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
ON "artist" USING gin ("name" gin_trgm_ops);

CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
ON "recording" USING gin ("title" gin_trgm_ops);
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});

file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Checking migration and script setup**
exec
bash -lc 'ls scripts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
check-breaking.mjs
db
dev
schemathesis.mjs
wait
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});

Re-connecting... 1/5

thinking
**Preparing explain plan SQL scripts with CI integration**

I'm creating a new directory for SQL explain scripts and planning three queries with EXPLAIN (ANALYZE, BUFFERS) to analyze performance. I'll make sure the CI pipeline seeds the database before running these scripts via psql, and I'm considering details like including echo labels and ensuring necessary extensions and seeded data exist for accurate query plans. Let's explore the seed data closely to verify relevant entries for fuzzy search queries.
exec
bash -lc 'ls packages/db/prisma/seed-data' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
albums.json
artists.json
playlist.json
recordings.json
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Inspecting recordings.json for track titles**
exec
bash -lc 'cat packages/db/prisma/seed-data/recordings.json' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[
  {
    "title": "Roygbiv",
    "durationMs": 155000,
    "mbid": "91c9ad8e-2ddb-4a3c-b061-7e86b0d6a79f",
    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
    "albumTitle": "Music Has the Right to Children",
    "isrc": "GBAYE9800164"
  },
  {
    "title": "Turquoise Hexagon Sun",
    "durationMs": 342000,
    "mbid": "4f6de5b4-11c0-4163-92d0-8e4a04c1c3aa",
    "artistMbid": "a04d5341-d8e1-4c24-bf5b-6fbe77e38e1b",
    "albumTitle": "Music Has the Right to Children",
    "isrc": "GBAYE9800172"
  },
  {
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});


thinking
**Adding new SQL script with directory creation**
file update
A /var/home/rick/Development/playlist-manager/scripts/explain/playlists.sql
\echo 'EXPLAIN playlists by user scope'

EXPLAIN (ANALYZE, BUFFERS)
SELECT id, name, updated_at
FROM playlist
WHERE user_id = (
  SELECT id FROM app_user ORDER BY id LIMIT 1
)
ORDER BY updated_at DESC
LIMIT 10;
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A scripts/explain/playlists.sql
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;

file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Adding items.sql file**
file update
A /var/home/rick/Development/playlist-manager/scripts/explain/items.sql
\echo 'EXPLAIN playlist items join to recordings'

EXPLAIN (ANALYZE, BUFFERS)
SELECT pi.id, pi.position, r.title
FROM playlist_item pi
JOIN recording r ON r.id = pi.recording_id
WHERE pi.playlist_id = (
  SELECT id FROM playlist ORDER BY id LIMIT 1
)
ORDER BY pi.position
LIMIT 20;
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A scripts/explain/items.sql
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;

file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Adding fuzzy_search.sql script**
file update
A /var/home/rick/Development/playlist-manager/scripts/explain/fuzzy_search.sql
\echo 'EXPLAIN fuzzy artist/title lookup'

EXPLAIN (ANALYZE, BUFFERS)
SELECT a.id, a.name
FROM artist a
WHERE a.name % 'Aphex Twin'
ORDER BY similarity(a.name, 'Aphex Twin') DESC
LIMIT 5;

EXPLAIN (ANALYZE, BUFFERS)
SELECT r.id, r.title
FROM recording r
WHERE r.title % 'Roygbiv'
ORDER BY similarity(r.title, 'Roygbiv') DESC
LIMIT 5;
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A scripts/explain/fuzzy_search.sql
file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;

file update:
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Adding database seed and explain steps to CI workflow**

I'm planning to update the db-migrations job in `.github/workflows/ci.yml` by installing the `postgresql-client`, running `prisma db seed` after migrations, then running the health check, followed by executing the SQL scripts in `scripts/explain` to benchmark EXPLAIN plans. I'll carefully insert these new steps in the right order to ensure the database is properly prepared before running the explain queries.
file update
M /var/home/rick/Development/playlist-manager/.github/workflows/ci.yml
@@ -173,2 +173,4 @@
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
@@ -179,2 +181,7 @@
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
@@ -188 +195,11 @@
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M .github/workflows/ci.yml
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;

file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Verifying index creation and test updates**
Plan update
  ✓ Design coverage for new DB indexes and EXPLAIN scripts; inspect existing schema and CI.
  ✓ Add failing tests describing required indexes/extension/EXPLAIN script presence.
  ✓ Implement migration, SQL scripts, and CI workflow updates to satisfy tests.
  → Run relevant test suite (or document blockers) and ensure green.
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Preparing environment and database for tests**
exec
bash -lc 'cat docker-compose.yml' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
version: '3.8'
services:
  db:
    image: postgres:16
    container_name: plmgr-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: playlistmgr
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d playlistmgr"]
      interval: 5s
      timeout: 5s
      retries: 10
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Preparing to start database service**
exec
bash -lc 'docker compose up -d db' in /var/home/rick/Development/playlist-manager exited 125 in 64ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
Error: acquiring runtime init lock: open /run/user/1000/libpod/tmp/alive.lck: open /run/user/1000/libpod/tmp/alive.lck: permission denied
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Attempting tests without DB access**
exec
bash -lc 'DATABASE_URL=postgresql://postgres:postgres@localhost:5432/playlistmgr pnpm --filter @app/db exec prisma migrate deploy' in /var/home/rick/Development/playlist-manager exited 1 in 1.83s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": PostgreSQL database "playlistmgr", schema "public" at "localhost:5432"

Error: P1001: Can't reach database server at `localhost:5432`

Please make sure your database server is running at `localhost:5432`.
undefined
/var/home/rick/Development/playlist-manager/packages/db:
 ERR_PNPM_RECURSIVE_EXEC_FIRST_FAIL  Command failed with exit code 1: prisma migrate deploy
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Attempting test run despite expected failure**
exec
bash -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager succeeded in 11.66s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating missing test runs**
exec
bash -lc 'pnpm --filter @app/db vitest run' in /var/home/rick/Development/playlist-manager succeeded in 1.15s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
None of the selected packages has a "vitest" script
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating Vitest configuration**
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: [
      'packages/**/test/**/*.test.ts',
      'packages/**/tests/**/*.test.ts',
      'apps/**/src/**/__tests__/**/*.test.ts',
      'codex/code/**/tests/**/*.test.ts',
    ],
    testTimeout: 30000,
  },
});
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating test execution issues**
exec
bash -lc 'cat packages/db/src/client.ts' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating test environment and output issues**
exec
bash -lc 'pnpm vitest run --reporter verbose' in /var/home/rick/Development/playlist-manager succeeded in 11.60s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Analyzing potential Vitest execution issues**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Testing with vitest and CI flag**
exec
bash -lc 'CI=1 pnpm vitest run' in /var/home/rick/Development/playlist-manager succeeded in 11.63s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating test output issues**
exec
bash -lc 'pnpm vitest run 2>&1 | cat' in /var/home/rick/Development/playlist-manager succeeded in 11.61s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Investigating vitest output behavior**
exec
bash -lc 'pnpm vitest run packages/db/test/indexes.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 11.58s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Errors [49m[22m[31m⎯⎯⎯⎯⎯⎯[39m
[31m[1m
Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.[22m[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Error [49m[22m[31m⎯⎯⎯⎯⎯⎯⎯[39m
[31m[1mError[22m: [vitest-pool]: Worker forks emitted error.[39m
[90m [2m❯[22m EventEmitter.<anonymous> node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6870:22[22m[39m
[90m [2m❯[22m EventEmitter.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6520:22[22m[39m
[90m [2m❯[22m ChildProcess.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m Process.ChildProcess._handle.onexit node:internal/child_process:[2m293:12[22m[39m

[31m[1mCaused by: Error[22m: Worker exited unexpectedly[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6519:33[22m[39m
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Diagnosing test execution failure**

I'm investigating why the specified test file isn't running with vitest—suspecting missing Prisma Client generation or environment issues causing silent crashes. I plan to check logs closely and try running `prisma generate` before tests to fix possible client initialization errors.
exec
bash -lc 'pnpm --filter @app/db exec prisma generate' in /var/home/rick/Development/playlist-manager succeeded in 1.90s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Rerunning specific test file**
exec
bash -lc 'pnpm vitest run packages/db/test/indexes.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 11.59s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

[1m[46m RUN [49m[22m [36mv4.0.7 [39m[90m/var/home/rick/Development/playlist-manager[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Errors [49m[22m[31m⎯⎯⎯⎯⎯⎯[39m
[31m[1m
Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.[22m[39m

[31m⎯⎯⎯⎯⎯⎯[39m[1m[41m Unhandled Error [49m[22m[31m⎯⎯⎯⎯⎯⎯⎯[39m
[31m[1mError[22m: [vitest-pool]: Worker forks emitted error.[39m
[90m [2m❯[22m EventEmitter.<anonymous> node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6870:22[22m[39m
[90m [2m❯[22m EventEmitter.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6520:22[22m[39m
[90m [2m❯[22m ChildProcess.emit node:events:[2m519:28[22m[39m
[90m [2m❯[22m Process.ChildProcess._handle.onexit node:internal/child_process:[2m293:12[22m[39m

[31m[1mCaused by: Error[22m: Worker exited unexpectedly[39m
[90m [2m❯[22m ChildProcess.emitUnexpectedExit node_modules/.pnpm/vitest@4.0.7_@types+node@24.9.2_tsx@4.20.6/node_modules/vitest/dist/chunks/cli-api.Csks4as1.js:[2m6519:33[22m[39m
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Diagnosing test runner crash**

I'm investigating why Vitest reports "no tests"—likely because the test worker crashes before collecting tests due to runtime errors like missing database connections or module import failures. I’m considering running with verbose reporting and single-thread mode to capture errors clearly and may try importing a minimal PrismaClient instance to confirm if DB unreachability causes the crash. This will help me document the test run blockers and update the plan accordingly.
Plan update
Attempted to run Prisma migrations and Vitest; commands fail because a local PostgreSQL instance is unavailable in this environment (podman permission denied). Documenting this blocker in the final report.
  ✓ Design coverage for new DB indexes and EXPLAIN scripts; inspect existing schema and CI.
  ✓ Add failing tests describing required indexes/extension/EXPLAIN script presence.
  ✓ Implement migration, SQL scripts, and CI workflow updates to satisfy tests.
  ✓ Run relevant test suite (or document blockers) and ensure green.
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Summarizing code changes and file references**
exec
bash -lc 'nl -ba packages/db/test/indexes.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { afterAll, describe, expect, test } from 'vitest';
     2	import { prisma } from '../src/client';
     3	
     4	async function fetchIndexMap(table: string) {
     5	  const rows = await prisma.$queryRaw<
     6	    Array<{ indexname: string; indexdef: string }>
     7	  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
     8	  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
     9	}
    10	
    11	afterAll(async () => {
    12	  await prisma.$disconnect();
    13	});
    14	
    15	describe('hot-path indexes', () => {
    16	  test('playlist lookups use user scope index', async () => {
    17	    const indexes = await fetchIndexMap('playlist');
    18	    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Evaluating test behavior with undefined values**
exec
bash -lc 'nl -ba packages/db/test/explain_scripts.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { readFileSync } from 'node:fs';
     2	import { dirname, resolve } from 'node:path';
     3	import { fileURLToPath } from 'node:url';
     4	import { describe, expect, test } from 'vitest';
     5	
     6	const __filename = fileURLToPath(import.meta.url);
     7	const __dirname = dirname(__filename);
     8	
     9	const scriptsRoot = resolve(__dirname, '../../scripts/explain');
    10	const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
    11	
    12	describe('EXPLAIN plans', () => {
    13	  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
    14	    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
    15	    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
    16	  });
    17	});
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Reviewing migration file lines**
exec
bash -lc 'nl -ba packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	-- Enable trigram search capability for fuzzy lookups
     2	CREATE EXTENSION IF NOT EXISTS pg_trgm;
     3	
     4	-- Playlists queried by user most frequently; include updated_at for recency sorts
     5	CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
     6	ON "playlist" ("user_id", "updated_at" DESC);
     7	
     8	-- Playlist items joined to recordings for normalization pipelines
     9	CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
    10	ON "playlist_item" ("recording_id");
    11	
    12	-- Follow lists queried by artist (fan counts, discovery)
    13	CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
    14	ON "artist_follow" ("artist_id");
    15	
    16	-- Fuzzy lookup support for artist and track search
    17	CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
    18	ON "artist" USING gin ("name" gin_trgm_ops);
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Listing script files for line numbering**
exec
bash -lc 'nl -ba scripts/explain/playlists.sql' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	\echo 'EXPLAIN playlists by user scope'
     2	
     3	EXPLAIN (ANALYZE, BUFFERS)
     4	SELECT id, name, updated_at
     5	FROM playlist
     6	WHERE user_id = (
     7	  SELECT id FROM app_user ORDER BY id LIMIT 1
     8	)
     9	ORDER BY updated_at DESC
    10	LIMIT 10;
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Identifying SQL filename**
exec
bash -lc 'nl -ba scripts/explain/items.sql' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	\echo 'EXPLAIN playlist items join to recordings'
     2	
     3	EXPLAIN (ANALYZE, BUFFERS)
     4	SELECT pi.id, pi.position, r.title
     5	FROM playlist_item pi
     6	JOIN recording r ON r.id = pi.recording_id
     7	WHERE pi.playlist_id = (
     8	  SELECT id FROM playlist ORDER BY id LIMIT 1
     9	)
    10	ORDER BY pi.position
    11	LIMIT 20;
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Reviewing fuzzy_search.sql contents**
exec
bash -lc 'nl -ba scripts/explain/fuzzy_search.sql' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	\echo 'EXPLAIN fuzzy artist/title lookup'
     2	
     3	EXPLAIN (ANALYZE, BUFFERS)
     4	SELECT a.id, a.name
     5	FROM artist a
     6	WHERE a.name % 'Aphex Twin'
     7	ORDER BY similarity(a.name, 'Aphex Twin') DESC
     8	LIMIT 5;
     9	
    10	EXPLAIN (ANALYZE, BUFFERS)
    11	SELECT r.id, r.title
    12	FROM recording r
    13	WHERE r.title % 'Roygbiv'
    14	ORDER BY similarity(r.title, 'Roygbiv') DESC
    15	LIMIT 5;
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Adding relevant CI workflow lines**
exec
bash -lc "nl -ba .github/workflows/ci.yml | sed -n '60,160p'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
    60	    env:
    61	      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/tmm_dev?schema=public
    62	    steps:
    63	      - uses: actions/checkout@v4
    64	      - uses: pnpm/action-setup@v4
    65	      - uses: actions/setup-node@v4
    66	        with:
    67	          node-version: 20
    68	          cache: pnpm
    69	          cache-dependency-path: pnpm-lock.yaml
    70	      - name: Install OpenSSL runtime (Bookworm)
    71	        run: |
    72	          apt-get update
    73	          apt-get install -y openssl libssl3 ca-certificates
    74	      - run: pnpm -w install --frozen-lockfile
    75	      - name: Wait for Postgres
    76	        run: npx wait-on tcp:postgres:5432
    77	      - run: pnpm --filter @app/db exec prisma generate
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Continuing output with new steps**
exec
bash -lc "nl -ba .github/workflows/ci.yml | sed -n '160,260p'" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
   160	          POSTGRES_DB: playlistmgr
   161	        ports: ["5432:5432"]
   162	        options: >-
   163	          --health-cmd="pg_isready -U postgres -d playlistmgr"
   164	          --health-interval=5s --health-timeout=5s --health-retries=10
   165	    steps:
   166	      - uses: actions/checkout@v4
   167	      - uses: pnpm/action-setup@v4
   168	        with: { version: 9 }
   169	      - uses: actions/setup-node@v4
   170	        with:
   171	          node-version: '20'
   172	          cache: 'pnpm'
   173	      - run: pnpm -w install
   174	      - name: Install psql client
   175	        run: sudo apt-get update && sudo apt-get install -y postgresql-client
   176	
   177	      - name: Prisma migrate deploy
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;


thinking
**Summarizing test attempts and next steps**

I'll explain the changes made to indexes, migrations, and CI scripts with exact file references. I’ll also clarify that testing was blocked because the local Postgres instance couldn’t start due to podman permission issues, causing migration and test commands to fail. Then I’ll suggest logical next steps to start Postgres and rerun migrations and tests, ensuring the user has a clear, friendly update on the current state and what to do next.
codex
**Updates**
- Added hot-path coverage tests in `packages/db/test/indexes.test.ts:1` and EXPLAIN script checks in `packages/db/test/explain_scripts.test.ts:1` so required indexes, `pg_trgm`, and plan fixtures are enforced.
- Introduced migration `packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql:1` to enable `pg_trgm` and create playlist, playlist-item, and artist-follow indexes plus trigram GIN support.
- Authored plan probes `scripts/explain/playlists.sql:1`, `scripts/explain/items.sql:1`, and `scripts/explain/fuzzy_search.sql:1`, and wired them into CI with seeding and psql installation in `.github/workflows/ci.yml:174`.

**Testing**
- Blocked: `docker compose up -d db` fails with `podman` permission denial, so `pnpm --filter @app/db exec prisma migrate deploy` cannot reach `localhost:5432`; vitest runs can’t meaningfully execute without a database.

**Next steps**
1. Bring up a local Postgres instance (or adjust container permissions), then rerun `pnpm --filter @app/db exec prisma migrate deploy`.
2. With the database available, execute `pnpm vitest run` to confirm the new tests and migrations pass.
file update:
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 41b374c069f678e4cb39d20636227935620280a5..3cb18ccc3625f39d81cc9b1202b298dbb263da15
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -171,12 +171,19 @@
           node-version: '20'
           cache: 'pnpm'
       - run: pnpm -w install
+      - name: Install psql client
+        run: sudo apt-get update && sudo apt-get install -y postgresql-client
 
       - name: Prisma migrate deploy
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: pnpm -F @app/db prisma migrate deploy
 
+      - name: Seed database
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: pnpm --filter @app/db exec prisma db seed
+
       - name: DB healthcheck
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
@@ -186,3 +193,13 @@
         env:
           DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
         run: node -e "import('pg').then(async m=>{const c=new m.Client({connectionString:process.env.DATABASE_URL});await c.connect();const r=await c.query('SELECT 1');console.log(r.rows[0]);await c.end();})"
+
+      - name: EXPLAIN benchmarks
+        env:
+          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/playlistmgr
+        run: |
+          for script in scripts/explain/*.sql; do
+            echo "::group::${script}"
+            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$script"
+            echo "::endgroup::"
+          done
diff --git a/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
new file mode 100644
index 0000000000000000000000000000000000000000..93fe9d5b71efeea18b37d058106d1d1833558341
--- /dev/null
+++ b/packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql
@@ -0,0 +1,21 @@
+-- Enable trigram search capability for fuzzy lookups
+CREATE EXTENSION IF NOT EXISTS pg_trgm;
+
+-- Playlists queried by user most frequently; include updated_at for recency sorts
+CREATE INDEX IF NOT EXISTS playlist_user_scope_idx
+ON "playlist" ("user_id", "updated_at" DESC);
+
+-- Playlist items joined to recordings for normalization pipelines
+CREATE INDEX IF NOT EXISTS playlist_item_recording_id_idx
+ON "playlist_item" ("recording_id");
+
+-- Follow lists queried by artist (fan counts, discovery)
+CREATE INDEX IF NOT EXISTS artist_follow_artist_id_idx
+ON "artist_follow" ("artist_id");
+
+-- Fuzzy lookup support for artist and track search
+CREATE INDEX IF NOT EXISTS artist_name_trgm_idx
+ON "artist" USING gin ("name" gin_trgm_ops);
+
+CREATE INDEX IF NOT EXISTS recording_title_trgm_idx
+ON "recording" USING gin ("title" gin_trgm_ops);
diff --git a/packages/db/test/explain_scripts.test.ts b/packages/db/test/explain_scripts.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c5eac9e63adaa47617764183536522648733883
--- /dev/null
+++ b/packages/db/test/explain_scripts.test.ts
@@ -0,0 +1,17 @@
+import { readFileSync } from 'node:fs';
+import { dirname, resolve } from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { describe, expect, test } from 'vitest';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = dirname(__filename);
+
+const scriptsRoot = resolve(__dirname, '../../scripts/explain');
+const explainScripts = ['playlists.sql', 'items.sql', 'fuzzy_search.sql'];
+
+describe('EXPLAIN plans', () => {
+  test.each(explainScripts)('%s exists and runs ANALYZE', (script) => {
+    const content = readFileSync(resolve(scriptsRoot, script), 'utf8');
+    expect(content).toMatch(/EXPLAIN\s*\(ANALYZE,\s*BUFFERS\)/i);
+  });
+});
diff --git a/packages/db/test/indexes.test.ts b/packages/db/test/indexes.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11062cb39b8e02ba532c5a8a9390e8f33c0fe44a
--- /dev/null
+++ b/packages/db/test/indexes.test.ts
@@ -0,0 +1,49 @@
+import { afterAll, describe, expect, test } from 'vitest';
+import { prisma } from '../src/client';
+
+async function fetchIndexMap(table: string) {
+  const rows = await prisma.$queryRaw<
+    Array<{ indexname: string; indexdef: string }>
+  >`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${table}`;
+  return new Map(rows.map((row) => [row.indexname, row.indexdef]));
+}
+
+afterAll(async () => {
+  await prisma.$disconnect();
+});
+
+describe('hot-path indexes', () => {
+  test('playlist lookups use user scope index', async () => {
+    const indexes = await fetchIndexMap('playlist');
+    expect(indexes.has('playlist_user_scope_idx')).toBe(true);
+  });
+
+  test('playlist items join on recording id without sequential scan', async () => {
+    const indexes = await fetchIndexMap('playlist_item');
+    expect(indexes.has('playlist_item_recording_id_idx')).toBe(true);
+  });
+
+  test('artist follows resolve by artist efficiently', async () => {
+    const indexes = await fetchIndexMap('artist_follow');
+    expect(indexes.has('artist_follow_artist_id_idx')).toBe(true);
+  });
+});
+
+describe('fuzzy search support', () => {
+  test('pg_trgm extension is installed', async () => {
+    const [{ exists }] = await prisma.$queryRaw<
+      Array<{ exists: boolean }>
+    >`SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm')`;
+    expect(exists).toBe(true);
+  });
+
+  test('artist and recording trigram indexes are present', async () => {
+    const artistIndexes = await fetchIndexMap('artist');
+    const recordingIndexes = await fetchIndexMap('recording');
+
+    expect(artistIndexes.get('artist_name_trgm_idx')).toMatch(/USING gin/i);
+    expect(recordingIndexes.get('recording_title_trgm_idx')).toMatch(
+      /USING gin/i,
+    );
+  });
+});
diff --git a/scripts/explain/fuzzy_search.sql b/scripts/explain/fuzzy_search.sql
new file mode 100644
index 0000000000000000000000000000000000000000..fdb05cfec4666685e1e10410fff44d544b8905ac
--- /dev/null
+++ b/scripts/explain/fuzzy_search.sql
@@ -0,0 +1,15 @@
+\echo 'EXPLAIN fuzzy artist/title lookup'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT a.id, a.name
+FROM artist a
+WHERE a.name % 'Aphex Twin'
+ORDER BY similarity(a.name, 'Aphex Twin') DESC
+LIMIT 5;
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT r.id, r.title
+FROM recording r
+WHERE r.title % 'Roygbiv'
+ORDER BY similarity(r.title, 'Roygbiv') DESC
+LIMIT 5;
diff --git a/scripts/explain/items.sql b/scripts/explain/items.sql
new file mode 100644
index 0000000000000000000000000000000000000000..bc22bb7f0d94b462065e30a681f3c198eca190aa
--- /dev/null
+++ b/scripts/explain/items.sql
@@ -0,0 +1,11 @@
+\echo 'EXPLAIN playlist items join to recordings'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT pi.id, pi.position, r.title
+FROM playlist_item pi
+JOIN recording r ON r.id = pi.recording_id
+WHERE pi.playlist_id = (
+  SELECT id FROM playlist ORDER BY id LIMIT 1
+)
+ORDER BY pi.position
+LIMIT 20;
diff --git a/scripts/explain/playlists.sql b/scripts/explain/playlists.sql
new file mode 100644
index 0000000000000000000000000000000000000000..46b331e40a03e022ac21dcc3878575e29c2fccca
--- /dev/null
+++ b/scripts/explain/playlists.sql
@@ -0,0 +1,10 @@
+\echo 'EXPLAIN playlists by user scope'
+
+EXPLAIN (ANALYZE, BUFFERS)
+SELECT id, name, updated_at
+FROM playlist
+WHERE user_id = (
+  SELECT id FROM app_user ORDER BY id LIMIT 1
+)
+ORDER BY updated_at DESC
+LIMIT 10;

tokens used
149,888
**Updates**
- Added hot-path coverage tests in `packages/db/test/indexes.test.ts:1` and EXPLAIN script checks in `packages/db/test/explain_scripts.test.ts:1` so required indexes, `pg_trgm`, and plan fixtures are enforced.
- Introduced migration `packages/db/prisma/migrations/20251107090000_hot_path_indexes/migration.sql:1` to enable `pg_trgm` and create playlist, playlist-item, and artist-follow indexes plus trigram GIN support.
- Authored plan probes `scripts/explain/playlists.sql:1`, `scripts/explain/items.sql:1`, and `scripts/explain/fuzzy_search.sql:1`, and wired them into CI with seeding and psql installation in `.github/workflows/ci.yml:174`.

**Testing**
- Blocked: `docker compose up -d db` fails with `podman` permission denial, so `pnpm --filter @app/db exec prisma migrate deploy` cannot reach `localhost:5432`; vitest runs can’t meaningfully execute without a database.

**Next steps**
1. Bring up a local Postgres instance (or adjust container permissions), then rerun `pnpm --filter @app/db exec prisma migrate deploy`.
2. With the database available, execute `pnpm vitest run` to confirm the new tests and migrations pass.
