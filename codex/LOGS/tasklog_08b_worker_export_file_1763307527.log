OpenAI Codex v0.58.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5.1-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a8d51-9fe6-7ee1-839d-bb9a7fe2df1e
--------
user
Implement the functionality described in codex/TASKS/08b_worker_export_file.yaml, then verify with any available tests.
ERROR: MCP client for `arxiv-mcp-server-gpt` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.arxiv-mcp-server-gpt]
startup_timeout_sec = XX

thinking
**Checking for codex tasks**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 47ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
Jackett
Jackett.Binaries.LinuxAMDx64.tar.gz
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Checking for task file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
00_repo_sanity_review.yaml
01a_spec_bootstrap.yaml
02a_prisma_init.yaml
02b_raw_migrations.yaml
02c_prisma_seeds.yaml
02d_db_indexes_bench.yaml
03a_dbpkg_singleton.yaml
03b_db_migration_ci_gate.yaml
03c_token_encryption_at_rest.yaml
04a_api_validation_wiring.yaml
04b_openapi_warning_silencer.yaml
04c_api_docs_ui.yaml
04d_config_feature_flags.yaml
05a_pif_validator.yaml
05b_file_exporters.yaml
05c_importers_file.yaml
06a_provider_interfaces.yaml
06b_spotify_impl.yaml
06c_deezer_impl.yaml
06d_tidal_impl.yaml

thinking
**Opening the task file**
exec
bash -lc 'cat codex/TASKS/08b_worker_export_file.yaml' in /var/home/rick/Development/playlist-manager succeeded in 73ms:
id: 08b_worker_export_file
title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
branch: codex/08b_worker_export_file
overview: >
  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.
acceptance:
  - Tests in codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts pass:
    * renders CSV lean equals golden; writes to mocked storage; updates job.artifact_url and status=succeeded.
artifacts_to_touch:
  - apps/worker/src/processors/exportFile.ts
  - apps/worker/src/storage/objectStore.ts
  - codex/code/codex/08b_worker_export_file/tests/goldens/playlist.csv
constraints:
  - No real S3; objectStore.write mocked in tests.
  - Use existing file exporters from 05b task.
tests:
  path: codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
  content: |
    import { expect, test, vi } from 'vitest';
    import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';

thinking
**Preparing to implement and test functionality**
exec
bash -lc 'ls apps/worker/src' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
config.ts
jobs
lib
providers
queues

thinking
**Checking for processors in jobs**
exec
bash -lc 'ls apps/worker/src/jobs' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
snapshotGc.ts

thinking
**Checking for existing processors**
exec
bash -lc 'rg -n "processExportFile" -n' in /var/home/rick/Development/playlist-manager succeeded in 54ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:91:    import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:112:bash -lc 'rg -n "processExportFile" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08b_worker_export_file.yaml:20:    import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
codex/TASKS/08b_worker_export_file.yaml:26:      const result = await processExportFile(ctx as any);
codex/TASKS/08b_worker_export_file.yaml:30:  - Implement processExportFile(ctx): load items via SQL view, render via exporters, gzip, write store, update Job row.

thinking
**Checking for log files**
exec
bash -lc 'ls apps/worker/src/storage' in /var/home/rick/Development/playlist-manager exited 2 in 43ms:
ls: cannot access 'apps/worker/src/storage': No such file or directory

thinking
**Reviewing worker environment and tasks**
exec
bash -lc "sed -n '1,200p' apps/worker/src/jobs/snapshotGc.ts" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
import { prisma } from '@app/db';

// Mirror of ADR-004 snapshot cleanup query.
const SNAPSHOT_GC_SQL = `
  UPDATE playlist_item
  SET
    snapshot_title = NULL,
    snapshot_artists = NULL,
    snapshot_album = NULL,
    snapshot_expires_at = NULL
  WHERE
    (snapshot_title IS NOT NULL OR snapshot_artists IS NOT NULL OR snapshot_album IS NOT NULL OR snapshot_expires_at IS NOT NULL)
    AND (
      recording_id IS NOT NULL
      OR (snapshot_expires_at IS NOT NULL AND snapshot_expires_at <= now())
    );
`;

export async function runGcOnce(): Promise<number> {
  const cleared = await prisma.$executeRawUnsafe(SNAPSHOT_GC_SQL);

thinking
**Inspecting for processor exports**
exec
bash -lc 'ls packages' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
config
contracts
db
interop
providers
utils

thinking
**Searching for exporters in codebase**
exec
bash -lc 'rg -n "Exporter"' in /var/home/rick/Development/playlist-manager succeeded in 68ms:
packages/providers/core/src/types.ts:26:export interface Exporter {
AGENTS.md:12:- **PROVIDER Agent(s)** – Implement `Importer`/`Exporter` contracts for Spotify/Deezer/TIDAL/YouTube. All HTTP calls are mocked in tests.
AGENTS.md:41:Task: Add support for exporting playlists to Apple Music using the `Exporter` interface.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:164:bash -lc 'rg -n "Exporter"' in /var/home/rick/Development/playlist-manager
packages/providers/youtube/src/index.ts:2:  Exporter,
packages/providers/youtube/src/index.ts:115:export default class YouTube implements ProviderImpl, Importer, Exporter {
packages/providers/tidal/src/index.ts:3:  Exporter,
packages/providers/tidal/src/index.ts:104:export default class Tidal implements ProviderImpl, Importer, Exporter {
packages/providers/deezer/src/index.ts:2:  Exporter,
packages/providers/deezer/src/index.ts:112:export default class Deezer implements ProviderImpl, Importer, Exporter {
packages/providers/spotify/src/index.ts:3:  Exporter,
packages/providers/spotify/src/index.ts:83:export default class Spotify implements ProviderImpl, Importer, Exporter {
packages/contracts/src/providers.ts:70:/** Exporter: write a PIF playlist to a provider */
packages/contracts/src/providers.ts:71:export interface Exporter {
packages/contracts/src/providers.ts:93:export type ProviderImpl = Importer & Exporter;
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:328:  Exporter,
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:386:  Exporter,
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:54:  Implement YouTube Importer/Exporter. Importer reads a playlist to PIF; exporter creates a playlist and adds videoIds.
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:76:  Exporter,
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:86:export default class YouTube implements ProviderImpl, Importer, Exporter {

thinking
**Searching for exporter files**
exec
bash -lc 'rg -n "M3U"' in /var/home/rick/Development/playlist-manager succeeded in 58ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:73:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:189:bash -lc 'rg -n "M3U"' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:317:  renderM3U,
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:753:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:522:codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:754:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:537:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:522:codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:755:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:543:codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:758:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:598:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:766:codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:480:export { renderM3U } from './m3u.ts';
openapi.yaml:395:                summary: Extended M3U playlist
openapi.yaml:397:                  #EXTM3U
openapi.yaml:482:                  summary: M3U preview
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:10:  renderM3U,
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:27:  it('renders M3U output that matches the golden file', () => {
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:28:    expect(renderM3U(playlist)).toEqual(loadGolden('playlist.m3u'));
codex/code/codex/05b_file_exporters/tests/goldens/playlist.m3u:1:#EXTM3U
codex/TASKS/05c_importers_file.yaml:2:title: File → PIF importers (CSV/M3U/XSPF/PLS/WPL)
codex/TASKS/08b_worker_export_file.yaml:2:title: Worker: export_file job (PIF→M3U/XSPF/CSV) + artifact write
codex/TASKS/05b_file_exporters.yaml:2:title: File exporters (M3U, XSPF, CSV lean/verbose) with goldens
codex/TASKS/05b_file_exporters.yaml:5:  Implement pure functions to render PIF → M3U, XSPF, and CSV (lean/verbose). Compare to golden files.

thinking
**Searching for exporter functions**
exec
bash -lc 'ls packages/interop' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
package.json
src
test
tsconfig.json

thinking
**Inspecting exporters in source**
exec
bash -lc 'ls packages/interop/src' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
importers
jobs

thinking
**Searching for CSV exporters**
exec
bash -lc 'rg -n "renderCSV" -n' in /var/home/rick/Development/playlist-manager succeeded in 62ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:230:bash -lc 'rg -n "renderCSV" -n' in /var/home/rick/Development/playlist-manager

thinking
**Searching for package exporters**
exec
bash -lc "find . -maxdepth 3 -type d -name '*export*'" in /var/home/rick/Development/playlist-manager succeeded in 111ms:
./packages/providers/file-exporters
./node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.53.0_@opentelemetry+api@1.9.0
./node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.53.0_@opentelemetry+api@1.9.0

thinking
**Checking file-exporters package**
exec
bash -lc 'ls packages/providers/file-exporters' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
package.json
src
tsconfig.json

thinking
**Exploring source directory**
exec
bash -lc 'ls packages/providers/file-exporters/src' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
csv.ts
index.ts
m3u.ts
shared.ts
xspf.ts

thinking
**Opening CSV file**
exec
bash -lc "sed -n '1,200p' packages/providers/file-exporters/src/csv.ts" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
import { createRequire } from 'node:module';

import { joinArtists } from './shared.ts';

export type CsvVariant = 'lean' | 'verbose';

type CsvSchema = {
  'x-csv'?: {
    columnOrder?: string[];
  };
};

type CsvRow = Record<string, string>;

const require = createRequire(import.meta.url);

const leanSchema = require('../../../../schemas/csv/playlist.lean.json') as CsvSchema;
const verboseSchema = require('../../../../schemas/csv/playlist.verbose.json') as CsvSchema;


thinking
**Planning playlist fetch worker**
exec
bash -lc "sed -n '1,200p' codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 57ms:
sed: can't read codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts: No such file or directory

thinking
**Listing codex directories**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex

thinking
**Listing codex/code/codex directory**
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 50ms:
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces
06b_spotify_impl
06c_deezer_impl
06d_tidal_impl
06e_youtube_impl
06f_provider_factory_tests
07a_routes_playlist_items_effective
07b_route_exports_file
08a_worker_jobs_gc

thinking
**Preparing test setup for new module**
exec
bash -lc 'ls codex/code/codex/08a_worker_jobs_gc' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
tests

thinking
**Listing tests**
exec
bash -lc 'ls codex/code/codex/08a_worker_jobs_gc/tests' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
gc.test.ts

thinking
**Examining test file structure**
exec
bash -lc "sed -n '1,200p' codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 52ms:
import { afterAll, beforeEach, describe, expect, test } from 'vitest';

import { prisma } from '../../../../../packages/db/src/client';
import { runGcOnce } from '../../../../../apps/worker/src/jobs/snapshotGc';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,

thinking
**Investigating test patterns and data fetching**
exec
bash -lc "rg -n \"effective\" apps -g'*'" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
apps/api/src/routes/playlists/[id]/items.get.ts:3:import { fetchEffectivePlaylistItems, type FetchEffectiveItemsArgs } from '../../../lib/db/effectiveItems';
apps/api/src/routes/playlists/[id]/items.get.ts:11:  effective?: boolean | string;
apps/api/src/routes/playlists/[id]/items.get.ts:25:  const effective = parseEffective(request.query?.effective);
apps/api/src/routes/playlists/[id]/items.get.ts:26:  if (!effective) {
apps/api/src/routes/playlists/[id]/items.get.ts:29:      code: 'effective_mode_required',
apps/api/src/routes/playlists/[id]/items.get.ts:30:      message: 'Only effective playlist items are supported',
apps/api/src/routes/playlists/[id]/items.get.ts:91:function parseEffective(value: Query['effective']): boolean {
apps/api/src/routes/playlists/[id]/items.get.ts:103:    code: 'invalid_effective',
apps/api/src/routes/playlists/[id]/items.get.ts:104:    message: 'effective must be a boolean value',
apps/api/src/lib/db/effectiveItems.ts:64:      FROM v_playlist_item_effective
apps/api/src/lib/openapi/openapi.json:208:        "summary": "List playlist items (effective fields by default)",
apps/api/src/lib/openapi/openapi.json:230:            "name": "effective",
apps/api/src/lib/openapi/openapi.json:283:                    "summary": "Example effective items page",

thinking
**Inspecting fetchEffectivePlaylistItems function**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/db/effectiveItems.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { createHash } from 'node:crypto';

import { Prisma } from '@prisma/client';

import { prisma } from '@app/db';

const MAX_LIMIT = 500;
const MIN_LIMIT = 1;

type OrderMode = 'position' | 'added_at';

type EffectiveItemRow = {
  id: number;
  position: number | null;
  title: string;
  artists: string;
  album: string | null;
  duration_ms: number | null;
  recording_id: number | null;
  isrc: string | null;

thinking
**Searching for Playlist Interop Format**
exec
bash -lc 'rg -n "PIFDocument" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:263:import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:399:bash -lc 'rg -n "PIFDocument" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:336:packages/contracts/src/pif.ts:28:export interface PIFDocument {
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:339:codex/LOGS/tasklog_05a_pif_validator_1762403333.log:539:export interface PIFDocument {
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:277:import type { PIFDocument, PIFProviderIds, PIFTrack } from '@app/contracts';
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:270:codex/code/codex/05b_file_exporters/tests/exporters.test.ts:import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:314:import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:325:const loadFixture = (name: string): PIFDocument =>
openapi.yaml:780:        preview: { $ref: '#/components/schemas/PIFDocument' }
openapi.yaml:788:    PIFDocument:
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:7:import { type PIFDocument } from '../../../../../packages/contracts/src/pif.ts';
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:18:const loadFixture = (name: string): PIFDocument =>
packages/contracts/src/pif.ts:28:export interface PIFDocument {
packages/contracts/src/pif.ts:38:  data: PIFDocument;
packages/contracts/src/pif.ts:153:      data: document as PIFDocument,
packages/providers/file-exporters/src/csv.ts:1:import { type PIFDocument, type PIFProviderIds, type PIFTrack } from '@app/contracts';
packages/providers/file-exporters/src/csv.ts:106:const buildVerboseRow = (playlist: PIFDocument, track: PIFTrack): CsvRow => {
packages/providers/file-exporters/src/csv.ts:141:  playlist: PIFDocument,
packages/providers/file-exporters/src/csv.ts:151:  playlist: PIFDocument,
packages/providers/file-exporters/src/xspf.ts:1:import { type PIFDocument, type PIFTrack } from '@app/contracts';

thinking
**Checking for PIF definitions**
exec
bash -lc "sed -n '1,200p' packages/contracts/src/pif.ts" in /var/home/rick/Development/playlist-manager succeeded in 54ms:
import Ajv, { type ErrorObject, type ValidateFunction } from 'ajv';
import { createRequire } from 'node:module';

export type PIFProviderService = 'spotify' | 'deezer' | 'tidal' | 'youtube' | 'amazon';

export interface PIFProviderIds {
  spotify_track_id?: string | null;
  deezer_track_id?: string | null;
  tidal_track_id?: string | null;
  youtube_video_id?: string | null;
  amazon_track_id?: string | null;
}

export interface PIFTrack {
  position: number;
  title: string;
  artists: string[];
  album?: string | null;
  duration_ms?: number | null;
  explicit?: boolean | null;

thinking
**Searching for toPIF conversion**
exec
bash -lc 'rg -n "toPIF" -n' in /var/home/rick/Development/playlist-manager succeeded in 66ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:447:**Searching for toPIF conversion**
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:449:bash -lc 'rg -n "toPIF" -n' in /var/home/rick/Development/playlist-manager

thinking
**Searching for general PIF builder**
exec
bash -lc "rg -n \"PIF\" apps -g'*.ts'" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
apps/api/src/routes/__tests__/imports.file.test.ts:6:import { validatePIF } from '@app/contracts';
apps/api/src/routes/__tests__/imports.file.test.ts:55:    const validation = validatePIF(body.preview);
apps/api/src/routes/imports.file.ts:3:import { validatePIF } from '@app/contracts';
apps/api/src/routes/imports.file.ts:105:    const validation = validatePIF(document);

thinking
**Examining file import and export routes**
exec
bash -lc 'rg -n "renderCsv" -n ..???' in /var/home/rick/Development/playlist-manager exited 2 in 39ms:
rg: ..???: IO error for operation on ..???: No such file or directory (os error 2)

thinking
**Preparing to run command**
exec
bash -lc "rg -n \"renderCsv\" -g'*'" in /var/home/rick/Development/playlist-manager exited 124 in 10.13s:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:465:bash -lc 'rg -n "renderCsv" -n ..???' in /var/home/rick/Development/playlist-manager exited 2 in 39ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:471:bash -lc "rg -n \"renderCsv\" -g'*'" in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:479:export { renderCsv, type CsvVariant } from './csv.ts';
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:316:  renderCsv,
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:9:  renderCsv,
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:36:    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
codex/code/codex/05b_file_exporters/tests/exporters.test.ts:40:    expect(renderCsv(playlist, 'verbose')).toEqual(
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1780:  renderCsv,
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1807:    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1811:    expect(renderCsv(playlist, 'verbose')).toEqual(
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1879:+  renderCsv,
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1906:+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:1910:+    expect(renderCsv(playlist, 'verbose')).toEqual(
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2012:+  renderCsv,
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2039:+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2043:+    expect(renderCsv(playlist, 'verbose')).toEqual(
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2170:+  renderCsv,
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2197:+    expect(renderCsv(playlist, 'lean')).toEqual(loadGolden('playlist.lean.csv'));
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2201:+    expect(renderCsv(playlist, 'verbose')).toEqual(
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:2320:+  renderCsv,

thinking
**Filtering logs for relevant code**
exec
bash -lc 'rg -n "renderCsv" packages' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
packages/providers/file-exporters/src/index.ts:1:export { renderCsv, type CsvVariant } from './csv.ts';
packages/providers/file-exporters/src/csv.ts:150:export const renderCsv = (

thinking
**Investigating log sources and exporters**
exec
bash -lc "sed -n '1,200p' apps/api/src/routes/exports/file.post.ts" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
import { FastifyReply, FastifyRequest } from 'fastify';
import { enqueue } from '../../lib/jobs/enqueue';
import { validateRequestBody } from '../../lib/openapi/validator';

type Body = {
  playlist_id: number;
  format: 'm3u' | 'xspf' | 'csv';
  variant?: 'lean' | 'verbose';
};

export default async function handler(
  request: FastifyRequest<{ Body: Body }>,
  reply: FastifyReply,
) {
  const rawContentType = request.headers['content-type'];
  const contentType = Array.isArray(rawContentType)
    ? rawContentType[0]
    : typeof rawContentType === 'string'
      ? rawContentType
      : undefined;

thinking
**Exploring worker and storage directories**
exec
bash -lc 'ls apps/worker/src' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
config.ts
jobs
lib
providers
queues

thinking
**Listing libraries for context**
exec
bash -lc 'ls apps/worker/src/lib' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
progress.ts
__tests__

thinking
**Checking for database libraries**
exec
bash -lc "sed -n '1,200p' apps/worker/src/lib/progress.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import type { JobProgressStatus } from '@app/interop/jobs/progress';
import { publishJobCompletion, publishJobProgress } from '@app/interop/jobs/progress';

export type ProgressUpdateOptions = {
  status?: JobProgressStatus;
  message?: string | null;
  percent?: number | null;
};

export type ProgressReporterOptions = {
  throttleMs?: number;
};

export type ProgressReporter = {
  report(percent: number, options?: Omit<ProgressUpdateOptions, 'percent'>): void;
  complete(status: Extract<JobProgressStatus, 'succeeded' | 'failed'>, message?: string | null): void;
};

const DEFAULT_THROTTLE_MS = 250;


thinking
**Investigating worker queues and file processors**
exec
bash -lc 'ls apps/worker/src/queues' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
index.ts

thinking
**Opening file for review**
exec
bash -lc "sed -n '1,200p' apps/worker/src/queues/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { Queue, QueueScheduler, Worker } from 'bullmq';

import { redisConnection, workerConfig } from '../config';
import { runGcOnce, snapshotGcJobName } from '../jobs/snapshotGc';

const SNAPSHOT_GC_REPEAT_JOB_ID = 'snapshot-gc:daily';
const SNAPSHOT_GC_TIMEZONE = 'UTC';

export type SnapshotGcRuntime = {
  queue: Queue;
  scheduler: QueueScheduler;
  worker: Worker;
};

function buildConnectionOptions() {
  return {
    connection: {
      ...redisConnection,
      tls: redisConnection.tls ? { ...redisConnection.tls } : undefined,
    },

thinking
**Investigating processor implementation**
exec
bash -lc "rg -n \"process\" apps/worker/src -g'*.ts'" in /var/home/rick/Development/playlist-manager succeeded in 42ms:
apps/worker/src/config.ts:21:    process.env.WORKER_REDIS_URL ?? process.env.REDIS_URL ?? 'redis://127.0.0.1:6379',
apps/worker/src/providers/config.ts:6:  spotify: envBool(process.env.PROVIDERS_SPOTIFY ?? 'true'),
apps/worker/src/providers/config.ts:7:  deezer:  envBool(process.env.PROVIDERS_DEEZER  ?? 'true'),
apps/worker/src/providers/config.ts:8:  tidal:   envBool(process.env.PROVIDERS_TIDAL   ?? 'true'),
apps/worker/src/providers/config.ts:9:  youtube: envBool(process.env.PROVIDERS_YOUTUBE ?? 'true'),

thinking
**Searching for processor implementations**
exec
bash -lc 'ls packages/interop/src/jobs' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
progress.ts

thinking
**Checking job status definitions**
exec
bash -lc "sed -n '1,200p' packages/interop/src/jobs/progress.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { EventEmitter } from 'node:events';

export type JobProgressStatus = 'queued' | 'running' | 'succeeded' | 'failed';

export type JobProgressUpdate = {
  job_id: number;
  status: JobProgressStatus;
  percent?: number | null;
  message?: string | null;
  updated_at?: string | null;
};

export type JobProgressEvent =
  | { type: 'progress'; update: JobProgressUpdate }
  | { type: 'complete'; update: JobProgressUpdate };

const emitter = new EventEmitter();
emitter.setMaxListeners(0);

export function subscribeToJobProgress(jobId: number, listener: (event: JobProgressEvent) => void): () => void {

thinking
**Searching for job table definitions**
exec
bash -lc 'ls packages/db/src' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
client.ts
encryption
healthcheck.ts
index.ts

thinking
**Searching for Prisma schema file**
exec
bash -lc 'find . -name schema.prisma -print' in /var/home/rick/Development/playlist-manager succeeded in 194ms:
./packages/db/prisma/schema.prisma

thinking
**Checking job table structure**
exec
bash -lc 'rg -n "model Job" -n packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 90ms:
271:model Job {
exec
bash -lc "sed -n '271,360p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
model Job {
  id            Int      @id @default(autoincrement())
  user_id       Int
  kind          String // export_file | import_service | migrate
  status        String // queued|running|succeeded|failed
  provider_from String?
  provider_to   String?
  playlist_id   Int?
  artifact_url  String?
  report_json   Json?
  created_at    DateTime @default(now()) @db.Timestamptz
  updated_at    DateTime @default(now()) @db.Timestamptz

  user     User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  playlist Playlist? @relation(fields: [playlist_id], references: [id])

  @@map("job")
}

thinking
**Inspecting job enqueue implementation**
exec
bash -lc "sed -n '1,200p' apps/api/src/lib/jobs/enqueue.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/**
 * Temporary enqueue stub for contract tests.
 * When API_FAKE_ENQUEUE=1, returns a deterministic id without touching Redis/queues.
 * Replace with real BullMQ wiring in worker tasks.
 */
export async function enqueue(_payload: unknown): Promise<{ id: number }> {
  if (process.env.API_FAKE_ENQUEUE === '1') {
    return { id: 999 };
  }
  throw new Error('enqueue not wired yet (set API_FAKE_ENQUEUE=1 for contract tests)');
}

thinking
**Investigating job processing and data fetching**
exec
bash -lc "rg -n \"renderM3U\" -n apps -g'*.ts'" in /var/home/rick/Development/playlist-manager exited 1 in 63ms:


thinking
**Inspecting database view for fields**
exec
bash -lc 'rg -n "v_playlist_item_effective" -n' in /var/home/rick/Development/playlist-manager succeeded in 50ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:366:apps/api/src/lib/db/effectiveItems.ts:64:      FROM v_playlist_item_effective
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:705:bash -lc 'rg -n "v_playlist_item_effective" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1111:codex/TASKS/02b_raw_migrations.yaml:10:    * SELECT from v_playlist_item_effective returns snapshot fallback when recording is absent.
packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql:28:CREATE OR REPLACE VIEW v_playlist_item_effective AS
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:1047:  Implement the route to read from v_playlist_item_effective with pagination; validate response against OpenAPI.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:51:  Implement the route to read from v_playlist_item_effective with pagination; validate response against OpenAPI.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:123:bash -lc 'rg -n "v_playlist_item_effective" -n' in /var/home/rick/Development/playlist-manager succeeded in 449ms:
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:124:codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:51:  Implement the route to read from v_playlist_item_effective with pagination; validate response against OpenAPI.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:125:codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:123:bash -lc 'rg -n "v_playlist_item_effective" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:126:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:25:  Add partial unique index on recording.isrc, touch-updated_at trigger, and v_playlist_item_effective view.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:127:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:30:    * SELECT from v_playlist_item_effective returns snapshot fallback when recording is absent.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:128:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:632:  Add partial unique index on recording.isrc, touch-updated_at trigger, and v_playlist_item_effective view.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:129:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:637:    * SELECT from v_playlist_item_effective returns snapshot fallback when recording is absent.
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:130:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:717:  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:131:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:786:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:132:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:853:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:133:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:927:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:134:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:1005:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:135:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:1090:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;
codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log:136:codex/LOGS/tasklog_02b_raw_migrations_1762378467.log:1169:+  >`SELECT id, title, artists, album, duration_ms FROM v_playlist_item_effective WHERE id = ${item.id}`;

thinking
**Opening migration file to inspect view definition**
exec
bash -lc "sed -n '1,200p' packages/db/prisma/migrations/20251030170000_raw_extras/migration.sql" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
-- 1) Partial unique index: only one non-null ISRC per recording
CREATE UNIQUE INDEX IF NOT EXISTS uq_recording_isrc_not_null
ON "recording" ("isrc") WHERE "isrc" IS NOT NULL;

-- 2) Touch-updated_at trigger (generic)
CREATE OR REPLACE FUNCTION touch_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

-- Attach to tables that have updated_at
DO $$
DECLARE
  tbl text;
BEGIN
  FOREACH tbl IN ARRAY ARRAY[
    'playlist','recording','album','artist',
    'playlist_item','artist_bio','artist_link','artist_relation','job'
  ]

thinking
**Exploring storage configuration and job table details**
exec
bash -lc "sed -n '1,200p' apps/worker/src/config.ts" in /var/home/rick/Development/playlist-manager succeeded in 56ms:
import { z } from 'zod';

export type WorkerRedisConnectionOptions = {
  host: string;
  port: number;
  username?: string;
  password?: string;
  db?: number;
  tls?: Record<string, unknown>;
};

const EnvSchema = z.object({
  WORKER_REDIS_URL: z
    .string()
    .url()
    .default('redis://127.0.0.1:6379'),
});

const parsedEnv = EnvSchema.parse({
  WORKER_REDIS_URL:

thinking
**Searching for object store config**
exec
bash -lc 'rg -n "objectStore" -n' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:82:  - apps/worker/src/storage/objectStore.ts
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:85:  - No real S3; objectStore.write mocked in tests.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:780:bash -lc 'rg -n "objectStore" -n' in /var/home/rick/Development/playlist-manager
codex/TASKS/08b_worker_export_file.yaml:11:  - apps/worker/src/storage/objectStore.ts
codex/TASKS/08b_worker_export_file.yaml:14:  - No real S3; objectStore.write mocked in tests.
codex/TASKS/08b_worker_export_file.yaml:21:    import * as store from '../../../../apps/worker/src/storage/objectStore';
codex/TASKS/08b_worker_export_file.yaml:31:  - Implement objectStore.write(buffer, mime, key): pluggable; tests mock it.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:607:  - apps/worker/src/storage/objectStore.ts
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:610:  - No real S3; objectStore.write mocked in tests.

thinking
**Preparing playlist export job**
exec
bash -lc 'ls codex/code/codex/07b_route_exports_file/tests' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
exports.route.test.ts

thinking
**Exploring dataset expectations**
exec
bash -lc "sed -n '1,200p' codex/code/codex/07b_route_exports_file/tests/exports.route.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import { beforeEach, describe, expect, test, vi } from 'vitest';
import request from 'supertest';

import handler from '../../../../../apps/api/src/routes/exports/file.post';
import * as Jobs from '../../../../../apps/api/src/lib/jobs/enqueue';
import { toProblemBody } from '../../../../../apps/api/src/lib/problem';

type HandlerResult = {
  status: number;
  headers: Record<string, string>;
  text: string;
  body: unknown;
};

type TestServer = {
  handle(
    method: string,
    path: string,
    options: { headers: Record<string, string>; body?: unknown },
  ): Promise<HandlerResult>;

thinking
**Preparing to implement export worker**
exec
bash -lc "sed -n '1,200p' codex/code/codex/07a_routes_playlist_items_effective/tests/items.route.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 92ms:
sed: can't read codex/code/codex/07a_routes_playlist_items_effective/tests/items.route.test.ts: No such file or directory

thinking
**Checking test directories**
exec
bash -lc 'ls codex/code/codex/07a_routes_playlist_items_effective/tests' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
route.items.test.ts

thinking
**Opening file**
exec
bash -lc "sed -n '1,200p' codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 94ms:
import { URL } from 'node:url';

import request from 'supertest';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';

import { toProblemBody } from '../../../../../apps/api/src/lib/problem';
import { createResponseValidationHook } from '../../../../../apps/api/src/lib/openapi/validator';
import handler from '../../../../../apps/api/src/routes/playlists/[id]/items.get';

type EffectivePlaylistItem = {
  id: number;
  position: number | null;
  title: string;
  artists: string;
  album: string | null;
  duration_ms: number | null;
  recording_id: number | null;
  isrc: string | null;
  mb_recording_id: string | null;
  mb_release_id: string | null;

thinking
**Investigating database client setup**
exec
bash -lc "sed -n '1,200p' packages/db/src/client.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma?: PrismaClient;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'warn', 'error']
        : ['error'],
  });

// Avoid creating multiple clients in dev (hot reload)
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

thinking
**Investigating artist string conversion**
exec
bash -lc "sed -n '1,200p' packages/providers/file-exporters/src/shared.ts" in /var/home/rick/Development/playlist-manager succeeded in 49ms:
import { type PIFProviderIds, type PIFTrack } from '@app/contracts';

type ProviderResolver = {
  key: keyof PIFProviderIds;
  buildUrl: (id: string) => string;
};

const PROVIDER_PRIORITY: ProviderResolver[] = [
  { key: 'spotify_track_id', buildUrl: (id) => `https://open.spotify.com/track/${id}` },
  { key: 'deezer_track_id', buildUrl: (id) => `https://www.deezer.com/track/${id}` },
  { key: 'tidal_track_id', buildUrl: (id) => `https://tidal.com/browse/track/${id}` },
  { key: 'youtube_video_id', buildUrl: (id) => `https://www.youtube.com/watch?v=${id}` },
  { key: 'amazon_track_id', buildUrl: (id) => `https://music.amazon.com/tracks/${id}` },
];

export const resolveTrackLocation = (track: PIFTrack): string | null => {
  const providerIds: PIFProviderIds | undefined | null = track.provider_ids;
  if (!providerIds) {
    return null;
  }

thinking
**Inspecting schema for provider IDs**
exec
bash -lc 'rg -n "model PlaylistItem" -n packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 54ms:
180:model PlaylistItem {
exec
bash -lc "sed -n '180,270p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
model PlaylistItem {
  id                Int     @id @default(autoincrement())
  playlist_id       Int
  position          Int?
  recording_id      Int?
  duration_ms       Int?
  isrc              String?
  mb_recording_id   String? @db.Uuid
  mb_release_id     String? @db.Uuid
  provider_track_id String?

  // Sparse, non-indexed snapshot fields (only when unmatched/mismatched)
  snapshot_title      String?
  snapshot_artists    String?
  snapshot_album      String?
  snapshot_expires_at DateTime? @db.Timestamptz

  playlist  Playlist   @relation(fields: [playlist_id], references: [id], onDelete: Cascade)
  recording Recording? @relation(fields: [recording_id], references: [id])


thinking
**Investigating provider track mapping**
exec
bash -lc 'rg -n "Provider" packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
61:  provider_maps ProviderPlaylistMap[]
128:  provider_maps  ProviderTrackMap[]
150:// ===================== Provider Mappings =====================
152:model ProviderTrackMap {
165:model ProviderPlaylistMap {
exec
bash -lc "sed -n '120,200p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
  mb_recording_id String?  @unique @db.Uuid
  title           String
  duration_ms     Int?
  isrc            String?
  album_id        Int?
  updated_at      DateTime @default(now()) @db.Timestamptz

  album          Album?             @relation(fields: [album_id], references: [id])
  provider_maps  ProviderTrackMap[]
  playlist_items PlaylistItem[]
  artists        RecordingArtist[]

  @@map("recording")
}

// Join: who performed on a recording (enables normalized artists list)
model RecordingArtist {
  recording_id Int
  artist_id    Int
  role         String? // primary|featuring|remixer...

thinking
**Inspecting playlist model**
exec
bash -lc 'rg -n "model Playlist" packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
48:model Playlist {
180:model PlaylistItem {
exec
bash -lc "sed -n '48,120p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 51ms:
model Playlist {
  id                   Int      @id @default(autoincrement())
  user_id              Int
  provider             String?
  provider_playlist_id String?
  name                 String?
  description          String?
  snapshot_hash        String?
  created_at           DateTime @default(now()) @db.Timestamptz
  updated_at           DateTime @default(now()) @db.Timestamptz

  user          User                  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  items         PlaylistItem[]
  provider_maps ProviderPlaylistMap[]
  jobs          Job[]
  active_state  ActivePlaylist?

  @@unique([provider, provider_playlist_id])
  @@map("playlist")
}

thinking
**Investigating provider_map and artist conversion**
exec
bash -lc 'rg -n "provider_track_id" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
openapi.dredd.yaml:434:      provider_track_id:
openapi.dredd.yaml:448:      provider_track_id: example-track-id
openapi.yaml:160:                        provider_track_id: "3urbQpVxWn"
openapi.yaml:171:                        provider_track_id: "9zYpqAbC12"
openapi.yaml:969:        provider_track_id:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:924:  provider_track_id String?
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1000:bash -lc 'rg -n "provider_track_id" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:264:  @@index([provider_track_id])
codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts:21:  provider_track_id: string | null;
codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts:159:          provider_track_id: null,
codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts:194:        provider_track_id: '3urbQpVxWn',
codex/code/codex/07a_routes_playlist_items_effective/tests/route.items.test.ts:207:        provider_track_id: '9zYpqAbC12',
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:3173:            provider_track_id?: string | null;
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:1103:        provider_track_id:
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:1690:                        provider_track_id: "3urbQpVxWn"
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:1701:                        provider_track_id: "9zYpqAbC12"
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:2620:                         provider_track_id: "9zYpqAbC12"
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:2890:                         provider_track_id: "9zYpqAbC12"
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:3164:                         provider_track_id: "9zYpqAbC12"
codex/LOGS/tasklog_07c_error_contracts_1763302301.log:3425:                         provider_track_id: "9zYpqAbC12"

thinking
**Preparing TDD plan for implementation**

I'm gathering info on required test data and environment to write proper failing tests first, per TDD. Since the task has multiple steps, I'll create a clear plan covering understanding requirements, writing tests, implementing code, running tests, and committing changes systematically.
Plan update
  → Study existing worker/storage/exporter primitives and design approach for export_file processor + tests.
  • Add failing tests (codex suite) and fixtures describing expected export behavior / object store interactions.
  • Implement exportFile processor + objectStore write helper to satisfy tests; ensure DB queries, exporters, gzip, job updates.
  • Run relevant test suites, verify green, and prepare final git commit with summary.

thinking
**Reviewing processExportFile testing and implementation plan**

I'm carefully piecing together how to fully test and implement `processExportFile`. The provided test snippet is minimal, so I'll need to build thorough tests that verify CSV output against a golden file, confirm job updates, and simulate DB data with Prisma. I'm also sketching the function's input types and behavior, especially how to construct playlist item data with fallback logic for positions and properly map provider IDs. There's a lot to align between acceptance criteria, existing test patterns, and data structures!
exec
bash -lc 'rg -n "provider_track_map" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
packages/db/test/seed.test.ts:9:      provider_track_map,
packages/db/prisma/schema.prisma:162:  @@map("provider_track_map")
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:341:      provider_track_map,
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1037:bash -lc 'rg -n "provider_track_map" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:806:      provider_track_map,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:1179:      provider_track_map,
codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log:3586:      provider_track_map,
packages/db/prisma/migrations/20251030162157_init/migration.sql:98:CREATE TABLE "provider_track_map" (
packages/db/prisma/migrations/20251030162157_init/migration.sql:104:    CONSTRAINT "provider_track_map_pkey" PRIMARY KEY ("id")
packages/db/prisma/migrations/20251030162157_init/migration.sql:225:CREATE INDEX "provider_track_map_recording_id_idx" ON "provider_track_map"("recording_id");
packages/db/prisma/migrations/20251030162157_init/migration.sql:228:CREATE UNIQUE INDEX "provider_track_map_provider_provider_track_id_key" ON "provider_track_map"("provider", "provider_track_id");
packages/db/prisma/migrations/20251030162157_init/migration.sql:294:ALTER TABLE "provider_track_map" ADD CONSTRAINT "provider_track_map_recording_id_fkey" FOREIGN KEY ("recording_id") REFERENCES "recording"("id") ON DELETE CASCADE ON UPDATE CASCADE;
codex/LOGS/tasklog_02d_db_indexes_bench_1762386864.log:291:      provider_track_map,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:224:      provider_track_map,
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:18780:     9	      provider_track_map,
codex/code/codex/08a_worker_jobs_gc/tests/gc.test.ts:10:      provider_track_map,
codex/TASKS/09b_enrichment_musicbrainz.yaml:6:  Cache results in DB tables (artist.mbid, recording.mb_recording_id, provider_track_map if applicable).

thinking
**Opening seed test file**
exec
bash -lc "sed -n '1,200p' packages/db/test/seed.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { beforeEach, afterAll, expect, test } from 'vitest';
import { prisma } from '../src/client';
import { runSeed } from '../prisma/seed';

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,
      job,

thinking
**Investigating test database usage**
exec
bash -lc "sed -n '1,200p' codex/code/codex/07b_route_exports_file/tests/exports.route.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
import { beforeEach, describe, expect, test, vi } from 'vitest';
import request from 'supertest';

import handler from '../../../../../apps/api/src/routes/exports/file.post';
import * as Jobs from '../../../../../apps/api/src/lib/jobs/enqueue';
import { toProblemBody } from '../../../../../apps/api/src/lib/problem';

type HandlerResult = {
  status: number;
  headers: Record<string, string>;
  text: string;
  body: unknown;
};

type TestServer = {
  handle(
    method: string,
    path: string,
    options: { headers: Record<string, string>; body?: unknown },
  ): Promise<HandlerResult>;

thinking
**Preparing to implement worker job tests**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",

thinking
**Planning tests and DB setup**
exec
bash -lc "rg -n \"job\" apps -g'*.ts'" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
apps/worker/src/queues/index.ts:4:import { runGcOnce, snapshotGcJobName } from '../jobs/snapshotGc';
apps/worker/src/queues/index.ts:49:  for (const job of repeatJobs) {
apps/worker/src/queues/index.ts:50:    if (job.id !== SNAPSHOT_GC_REPEAT_JOB_ID) continue;
apps/worker/src/queues/index.ts:51:    if (job.cron === cron) {
apps/worker/src/queues/index.ts:55:    await targetQueue.removeRepeatableByKey(job.key);
apps/worker/src/queues/index.ts:63:        jobId: SNAPSHOT_GC_REPEAT_JOB_ID,
apps/worker/src/lib/__tests__/progress.test.ts:3:vi.mock('@app/interop/jobs/progress', () => {
apps/worker/src/lib/__tests__/progress.test.ts:10:import { publishJobCompletion, publishJobProgress } from '@app/interop/jobs/progress';
apps/worker/src/lib/__tests__/progress.test.ts:27:      job_id: 1234,
apps/worker/src/lib/__tests__/progress.test.ts:33:      job_id: 1234,
apps/worker/src/lib/__tests__/progress.test.ts:50:      job_id: 55,
apps/worker/src/lib/__tests__/progress.test.ts:65:      job_id: 55,
apps/worker/src/lib/__tests__/progress.test.ts:72:  it('flushes buffered updates before completing the job', () => {
apps/worker/src/lib/__tests__/progress.test.ts:84:      job_id: 77,
apps/worker/src/lib/__tests__/progress.test.ts:91:      job_id: 77,
apps/worker/src/lib/progress.ts:1:import type { JobProgressStatus } from '@app/interop/jobs/progress';
apps/worker/src/lib/progress.ts:2:import { publishJobCompletion, publishJobProgress } from '@app/interop/jobs/progress';
apps/worker/src/lib/progress.ts:27:export function createProgressReporter(jobId: number, options: ProgressReporterOptions = {}): ProgressReporter {
apps/worker/src/lib/progress.ts:52:      job_id: jobId,
apps/worker/src/lib/progress.ts:98:        job_id: jobId,

thinking
**Checking TypeScript path mappings**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}

thinking
**Checking TypeScript path aliases**
exec
bash -lc 'ls apps/worker' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
src

thinking
**Analyzing export file compression approach**
exec
bash -lc 'rg -n "gzip" -n' in /var/home/rick/Development/playlist-manager succeeded in 61ms:
codex/TASKS/08b_worker_export_file.yaml:30:  - Implement processExportFile(ctx): load items via SQL view, render via exporters, gzip, write store, update Job row.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:117:codex/TASKS/08b_worker_export_file.yaml:30:  - Implement processExportFile(ctx): load items via SQL view, render via exporters, gzip, write store, update Job row.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1029:  • Implement exportFile processor + objectStore write helper to satisfy tests; ensure DB queries, exporters, gzip, job updates.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1183:bash -lc 'rg -n "gzip" -n' in /var/home/rick/Development/playlist-manager

thinking
**Planning object storage integration**
exec
bash -lc 'rg -n "OBJECT_STORE" -n' in /var/home/rick/Development/playlist-manager succeeded in 48ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1192:bash -lc 'rg -n "OBJECT_STORE" -n' in /var/home/rick/Development/playlist-manager

thinking
**Searching for MinIO configurations**
exec
bash -lc 'rg -n "MinIO" -n' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:76:  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1196:**Searching for MinIO configurations**
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:1198:bash -lc 'rg -n "MinIO" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:760:codex/LOGS/tasklog_05b_file_exporters_1762404715.log:601:  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.
codex/TASKS/10j_export_artifacts.yaml:2:title: Export artifact storage (S3/MinIO) + presigned URLs
codex/TASKS/10j_export_artifacts.yaml:5:  Persist generated exports to S3/MinIO; store object key in DB; /jobs/{id} returns artifact_url
codex/TASKS/10j_export_artifacts.yaml:9:  - Local dev uses MinIO docker with credentials from env
codex/TASKS/10j_export_artifacts.yaml:13:  - docker-compose.yml (MinIO service, if not present)
codex/TASKS/08b_worker_export_file.yaml:5:  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.
codex/LOGS/tasklog_05b_file_exporters_1762404715.log:601:  Implement BullMQ processor for export_file: fetch playlist items (effective), render format, write gz artifact to MinIO/S3, update job row.

thinking
**Designing object store interface and stub**
exec
bash -lc 'cat packages/providers/file-exporters/package.json' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
{
  "name": "@app/providers-file-exporters",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    }
  },
  "dependencies": {
    "@app/contracts": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }
}

thinking
**Planning playlist export implementation**
exec
bash -lc "rg -n \"prisma\\.job\" -n" in /var/home/rick/Development/playlist-manager exited 1 in 56ms:


thinking
**Searching job usage patterns**
exec
bash -lc "rg -n \"\\.job\" -g'*.ts' apps packages" in /var/home/rick/Development/playlist-manager succeeded in 43ms:
packages/interop/src/jobs/progress.ts:30:  emitter.emit(toChannel(normalized.job_id), { type: 'progress', update: normalized });
packages/interop/src/jobs/progress.ts:35:  emitter.emit(toChannel(normalized.job_id), { type: 'complete', update: normalized });
packages/interop/src/jobs/progress.ts:48:    job_id: update.job_id,

thinking
**Analyzing playlist export data gathering**
exec
bash -lc "rg -n '\"artists\"' schemas/pif-v1.schema.json" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
24:      "required": ["position", "title", "artists"],
28:        "artists": {
exec
bash -lc "sed -n '1,120p' schemas/pif-v1.schema.json" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schemas/pif-v1.schema.json",
  "title": "Playlist Interchange Format (PIF) v1",
  "type": "object",
  "additionalProperties": false,
  "required": ["name", "tracks"],
  "properties": {
    "name": { "type": "string" },
    "description": { "type": ["string", "null"] },
    "source_service": { "type": ["string", "null"], "enum": ["spotify", "deezer", "tidal", "youtube", "amazon", null] },
    "source_playlist_id": { "type": ["string", "null"] },
    "tracks": {
      "type": "array",
      "minItems": 1,
      "items": { "$ref": "#/$defs/track" }
    }
  },
  "$defs": {
    "uuid": { "type": "string", "pattern": "^[0-9a-fA-F-]{36}$" },


thinking
**Planning playlist export implementation**

I'm working through the requirements to export playlist data in PIF format, ensuring fields like `artists` arrays and `position` values meet schema expectations. I’m plotting how to handle missing data—like falling back to `'Unknown Artist'` when necessary—and managing zipped file creation with proper MIME types. I’ll also map provider track IDs carefully, update job status in the database, and design thorough tests with test data and golden files to verify output correctness, including CSV rendering details and compression handling. This comprehensive approach should keep the export robust and aligned with specs!
thinking
**Detailing test setup and error handling**

I’m organizing how to test the export process by decompressing the gzipped output, loading golden files for comparison, and verifying job row updates and artifact URLs. I’m planning robust error handling in the export function with try/catch around database and file operations, gracefully updating job status to ‘failed’ on errors without losing the original error. The implementation includes creating helper functions, enforcing format and variant rules, generating deterministic object keys with timestamps, and setting all needed imports and type definitions for smooth, maintainable code. This groundwork will help ensure reliable exports and clear test coverage.
exec
bash -lc 'rg -n "model User" packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
13:model User {
exec
bash -lc "sed -n '13,47p' packages/db/prisma/schema.prisma" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
model User {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  name       String?
  created_at DateTime @default(now()) @db.Timestamptz

  accounts  Account[]
  playlists Playlist[]
  follows   ArtistFollow[]
  active    ActivePlaylist?
  jobs      Job[]

  @@map("app_user")
}

model Account {
  id                       Int       @id @default(autoincrement())
  user_id                  Int
  provider                 String
  provider_user_id         String

thinking
**Preparing test setup and data files**

I’m getting ready to create a test environment for the exporter by setting up necessary directories and files, including a golden file with CSV data for two tracks. I’m also ensuring the Prisma client and database setup are suitable for integration testing, and planning to use synchronous file reads for simplicity. Next, I’ll create tests with actual DB access in mind.
exec
bash -lc 'mkdir -p codex/code/codex/08b_worker_export_file/tests/goldens' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Preparing detailed test setup**

I'm planning an extensive test file that includes helpers for setting up database fixtures, mocking object storage writes, loading golden files, and asserting end-to-end behavior of the export processing. I want to cover database resets, use Vitest lifecycle hooks, handle gzip decompression, and ensure data consistency while following TDD practices carefully by adding stubs as needed.
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
import { gunzipSync } from 'node:zlib';
import { readFileSync } from 'node:fs';
import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';

import { prisma } from '../../../../../packages/db/src/client';
import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';

const GOLDENS_DIR = new URL('./goldens/', import.meta.url);

const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');

async function resetDatabase() {
  await prisma.$executeRawUnsafe(`
    TRUNCATE TABLE
      playlist_item,
      provider_track_map,
      provider_playlist_map,
      recording_artist,
      recording,
      album,
      artist_relation,
      artist_link,
      artist_bio,
      artist_follow,
      playlist,
      active_playlist,
      job,
      account,
      app_user
    RESTART IDENTITY CASCADE;
  `);
}

describe('processExportFile', () => {
  beforeEach(async () => {
    await resetDatabase();
    vi.restoreAllMocks();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
    const { job, playlist } = await createPlaylistFixture();
    const golden = loadGolden('playlist.csv');

    let capturedBody: Buffer | null = null;
    let capturedMime: string | null = null;
    let capturedKey: string | null = null;
    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
      capturedBody = body;
      capturedMime = mime;
      capturedKey = key;
      return `s3://bucket/${key}`;
    });

    const result = await processExportFile({
      jobId: job.id,
      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
    });

    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
    expect(writeSpy).toHaveBeenCalledTimes(1);
    expect(capturedMime).toBe('application/gzip');
    expect(capturedKey).toMatch(/playlist/);

    const decompressed = gunzipSync(capturedBody!).toString('utf8');
    expect(decompressed).toEqual(golden);

    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
    expect(updatedJob.status).toBe('succeeded');
    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
  });
});

async function createPlaylistFixture() {
  const user = await prisma.user.create({
    data: {
      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
    },
  });

  const playlist = await prisma.playlist.create({
    data: {
      user_id: user.id,
      name: 'Codex Export Playlist',
      description: 'Fixture for worker export job',
      provider: 'spotify',
      provider_playlist_id: 'demo-playlist',
    },
  });

  const job = await prisma.job.create({
    data: {
      user_id: user.id,
      kind: 'export_file',
      status: 'running',
      playlist_id: playlist.id,
    },
  });

  const album = await prisma.album.create({
    data: {
      title: 'Out of Time',
    },
  });

  const recording = await prisma.recording.create({
    data: {
      title: 'Losing My Religion',
      album_id: album.id,
      duration_ms: 269000,
      isrc: 'USWB19902945',
    },
  });

  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });

  await prisma.recordingArtist.createMany({
    data: [
      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
    ],
  });

  await prisma.providerTrackMap.createMany({
    data: [
      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
    ],
  });

  await prisma.playlistItem.create({
    data: {
      playlist_id: playlist.id,
      position: 0,
      recording_id: recording.id,
      duration_ms: recording.duration_ms,
      isrc: 'USWB19902945',
    },
  });

  await prisma.playlistItem.create({
    data: {
      playlist_id: playlist.id,
      snapshot_title: 'Hurt',
      snapshot_artists: 'Nine Inch Nails',
      snapshot_album: 'The Downward Spiral',
      provider_track_id: 'track-unmatched',
    },
  });

  return { user, playlist, job };
}
apply_patch(auto_approved=true) exited 0 in 5ms:
Success. Updated the following files:
A codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
file update:
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Verifying database and CSV details**

I’m checking that the Prisma client supports `createMany` and confirming database fields requirements like `recording_id` and `playlist_item.position`. Also, I’m planning how to create a golden CSV file with proper CRLF line endings, carefully matching the exact string format that the `renderCsv` function produces, including handling quotes and empty fields correctly. I decide to write this file using a Python script to ensure accurate `\r\n` endings.
exec
bash -lc "python - <<'PY'
from pathlib import Path
root = Path('codex/code/codex/08b_worker_export_file/tests/goldens')
root.mkdir(parents=True, exist_ok=True)
content = \"\\r\\n\".join([
    \"position,title,artists,album,duration_ms,isrc\",
    \"1,Losing My Religion,R.E.M.; feat. Kate,Out of Time,269000,USWB19902945\",
    \"2,Hurt,Nine Inch Nails,The Downward Spiral,,\",
]) + \"\\r\\n\"
(root / 'playlist.csv').write_text(content)
PY" in /var/home/rick/Development/playlist-manager succeeded in 66ms:

file update:
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Updating plan progress**
Plan update
Tests for the new worker processor and golden fixture have been added to drive the implementation.
  ✓ Study existing worker/storage/exporter primitives and design approach for export_file processor + tests.
  ✓ Add failing tests (codex suite) and fixtures describing expected export behavior / object store interactions.
  • Implement exportFile processor + objectStore write helper to satisfy tests; ensure DB queries, exporters, gzip, job updates.
  • Run relevant test suites, verify green, and prepare final git commit with summary.
file update:
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Planning detailed processor implementation**

I'm organizing all the necessary steps and type definitions for implementing the full `processExportFile` processor function, including Prisma queries, error handling, provider mapping, document rendering, compression, object storage writing, and job status updates. This thorough blueprint will guide me through creating required directories, files, and robust logic that meets TDD practices and handles edge cases.
exec
bash -lc 'mkdir -p apps/worker/src/processors apps/worker/src/storage' in /var/home/rick/Development/playlist-manager succeeded in 56ms:

file update:
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Implementing pluggable objectStore module**

I'm designing a flexible `objectStore` module with a pluggable `write` function that defaults to writing files locally, ensuring smooth operation without real S3 integration yet. I'll export types and setup to allow mock overrides cleanly, while handling key paths properly and aligning with test expectations on spying `write`. This approach balances spec compliance with practical defaults.
file update
A /var/home/rick/Development/playlist-manager/apps/worker/src/storage/objectStore.ts
import { promises as fs } from 'node:fs';
import { dirname, join, resolve } from 'node:path';

export type WriteObjectParams = {
  body: Buffer;
  contentType: string;
  key: string;
};

export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;

const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');

let customWriter: ObjectStoreWriter | null = null;

export function configureObjectStore(writer: ObjectStoreWriter | null): void {
  customWriter = writer;
}

export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
  const writer = customWriter ?? defaultWriter;
  return writer({ body, contentType, key });
}

async function defaultWriter(params: WriteObjectParams): Promise<string> {
  const targetPath = join(defaultBaseDir, params.key);
  await fs.mkdir(dirname(targetPath), { recursive: true });
  await fs.writeFile(targetPath, params.body);
  return `file://${targetPath}`;
}
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A apps/worker/src/storage/objectStore.ts
file update:
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Implementing exportFile processor**
file update
A /var/home/rick/Development/playlist-manager/apps/worker/src/processors/exportFile.ts
import { promisify } from 'node:util';
import { gzip } from 'node:zlib';

import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';

import { prisma } from '@app/db';
import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
import * as objectStore from '../storage/objectStore';

const gzipAsync = promisify(gzip);

type ExportFormat = 'csv' | 'm3u' | 'xspf';

export type ExportFilePayload = {
  playlist_id: number;
  format: ExportFormat;
  variant?: CsvVariant;
};

export type ExportProcessorContext = {
  jobId: number;
  payload: ExportFilePayload;
};

type EffectiveItemRow = {
  id: number;
  playlist_id: number;
  position: number | null;
  title: string | null;
  artists: string | null;
  album: string | null;
  duration_ms: number | null;
  recording_id: number | null;
  isrc: string | null;
  mb_recording_id: string | null;
  mb_release_id: string | null;
  provider_track_id: string | null;
};

type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;

type ProcessResult = {
  artifactUrl: string;
  objectKey: string;
};

const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
  spotify: 'spotify_track_id',
  deezer: 'deezer_track_id',
  tidal: 'tidal_track_id',
  youtube: 'youtube_video_id',
  amazon: 'amazon_track_id',
};

const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);

export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
  const { jobId, payload } = ctx;
  assertPayload(payload);
  const format = payload.format;
  const csvVariant: CsvVariant = payload.variant ?? 'lean';

  const job = await prisma.job.findUnique({ where: { id: jobId } });
  if (!job) {
    throw new Error(`Job ${jobId} not found`);
  }

  try {
    if (job.status !== 'running') {
      await prisma.job.update({
        where: { id: jobId },
        data: { status: 'running' },
      });
    }

    const playlist = await prisma.playlist.findUnique({
      where: { id: payload.playlist_id },
    });
    if (!playlist) {
      throw new Error(`Playlist ${payload.playlist_id} not found`);
    }

    const items = await fetchEffectiveItems(playlist.id);
    if (items.length === 0) {
      throw new Error(`Playlist ${playlist.id} has no items to export`);
    }

    const providerMap = await loadProviderTrackMap(items);
    const document = buildPifDocument(playlist, items, providerMap);
    const rendered = renderDocument(document, format, csvVariant);
    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
    const objectKey = buildObjectKey({
      playlistId: playlist.id,
      format,
      variant: format === 'csv' ? csvVariant : undefined,
    });

    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);

    await prisma.job.update({
      where: { id: jobId },
      data: {
        status: 'succeeded',
        artifact_url: artifactUrl,
      },
    });

    return { artifactUrl, objectKey };
  } catch (error) {
    await markJobFailed(jobId, error);
    throw error;
  }
}

async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
  return prisma.$queryRaw<EffectiveItemRow[]>(
    Prisma.sql`
      SELECT
        id,
        playlist_id,
        position,
        title,
        artists,
        album,
        duration_ms,
        recording_id,
        isrc,
        mb_recording_id,
        mb_release_id,
        provider_track_id
      FROM v_playlist_item_effective
      WHERE playlist_id = ${playlistId}
      ORDER BY position ASC NULLS LAST, id ASC
    `,
  );
}

async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
  const recordingIds = Array.from(
    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
  );

  if (recordingIds.length === 0) {
    return new Map();
  }

  const rows = await prisma.providerTrackMap.findMany({
    where: { recording_id: { in: recordingIds } },
    select: {
      recording_id: true,
      provider: true,
      provider_track_id: true,
    },
  });

  const map = new Map<number, ProviderTrackRow[]>();
  for (const row of rows) {
    const list = map.get(row.recording_id) ?? [];
    list.push(row);
    map.set(row.recording_id, list);
  }
  return map;
}

function buildPifDocument(
  playlist: Playlist,
  items: EffectiveItemRow[],
  providerMap: Map<number, ProviderTrackRow[]>,
): PIFDocument {
  const sourceService = normalizeProviderService(playlist.provider);
  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));

  return {
    name: playlist.name ?? `Playlist #${playlist.id}`,
    description: playlist.description ?? null,
    source_service: sourceService,
    source_playlist_id: playlist.provider_playlist_id ?? null,
    tracks,
  };
}

function buildTrack(
  row: EffectiveItemRow,
  index: number,
  providerMap: Map<number, ProviderTrackRow[]>,
  playlistProvider: PIFProviderService | null,
): PIFTrack {
  const artists = splitArtists(row.artists);
  const track: PIFTrack = {
    position: normalizePosition(row.position, index),
    title: row.title ?? `Track ${index + 1}`,
    artists: artists.length > 0 ? artists : ['Unknown Artist'],
    album: row.album,
    duration_ms: row.duration_ms,
    isrc: row.isrc,
    mb_recording_id: row.mb_recording_id,
    mb_release_id: row.mb_release_id,
  };

  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
  if (providerIds) {
    track.provider_ids = providerIds;
  }

  return track;
}

function buildProviderIds(
  row: EffectiveItemRow,
  providerMap: Map<number, ProviderTrackRow[]>,
  playlistProvider: PIFProviderService | null,
): PIFProviderIds | undefined {
  const ids: Partial<PIFProviderIds> = {};

  if (typeof row.recording_id === 'number') {
    const entries = providerMap.get(row.recording_id) ?? [];
    for (const entry of entries) {
      const field = PROVIDER_ID_FIELDS[entry.provider];
      if (field) {
        ids[field] = entry.provider_track_id;
      }
    }
  }

  if (playlistProvider && row.provider_track_id) {
    const field = PROVIDER_ID_FIELDS[playlistProvider];
    if (field) {
      ids[field] = row.provider_track_id;
    }
  }

  return Object.keys(ids).length > 0 ? (ids satisfies PIFProviderIds) : undefined;
}

function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
  switch (format) {
    case 'csv':
      return renderCsv(document, csvVariant);
    case 'm3u':
      return renderM3U(document);
    case 'xspf':
      return renderXSPF(document);
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
}

function splitArtists(value: string | null): string[] {
  if (!value) return [];
  return value
    .split(';')
    .map((part) => part.trim())
    .filter((part) => part.length > 0);
}

function normalizePosition(position: number | null, index: number): number {
  if (typeof position === 'number') {
    return Math.max(1, position + 1);
  }
  return index + 1;
}

function normalizeProviderService(value: string | null): PIFProviderService | null {
  if (!value) {
    return null;
  }
  const normalized = value.toLowerCase() as PIFProviderService;
  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
}

function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
    throw new Error('playlist_id is required for export_file jobs');
  }
  if (!SUPPORTED_FORMATS.includes(payload.format)) {
    throw new Error(`Unsupported export format: ${payload.format}`);
  }
  if (payload.format !== 'csv' && payload.variant) {
    throw new Error('variant is only supported for CSV exports');
  }
}

async function markJobFailed(jobId: number, error: unknown) {
  const message = error instanceof Error ? error.message : 'Unknown error';
  try {
    await prisma.job.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        report_json: {
          error: message,
        } as Prisma.JsonValue,
      },
    });
  } catch {
    // Ignore secondary failures when marking the job as failed.
  }
}
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
A apps/worker/src/processors/exportFile.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e091126a4948a0aad5caed5c338c7616458cd8d5
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids satisfies PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e091126a4948a0aad5caed5c338c7616458cd8d5
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids satisfies PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Verifying TypeScript usage and code consistency**
exec
bash -lc "sed -n '1,200p' packages/providers/file-exporters/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
export { renderCsv, type CsvVariant } from './csv.ts';
export { renderM3U } from './m3u.ts';
export { renderXSPF } from './xspf.ts';
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e091126a4948a0aad5caed5c338c7616458cd8d5
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids satisfies PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Updating type assertion in buildProviderIds**
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/processors/exportFile.ts
@@ -233,3 +233,3 @@
 
-  return Object.keys(ids).length > 0 ? (ids satisfies PIFProviderIds) : undefined;
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
 }
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/worker/src/processors/exportFile.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf56e5f8ef1654f17c7017d068f0900e4dea308f
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf56e5f8ef1654f17c7017d068f0900e4dea308f
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Reviewing TypeScript usage and linting**
exec
bash -lc "sed -n '1,320p' apps/worker/src/processors/exportFile.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import { promisify } from 'node:util';
import { gzip } from 'node:zlib';

import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';

import { prisma } from '@app/db';
import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
import * as objectStore from '../storage/objectStore';

const gzipAsync = promisify(gzip);

type ExportFormat = 'csv' | 'm3u' | 'xspf';

export type ExportFilePayload = {
  playlist_id: number;
  format: ExportFormat;
  variant?: CsvVariant;
};

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf56e5f8ef1654f17c7017d068f0900e4dea308f
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,306 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const field = PROVIDER_ID_FIELDS[entry.provider];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Standardizing provider keys to lowercase**

I’m making sure all provider keys are safely converted to lowercase when accessing `PROVIDER_ID_FIELDS` to avoid case mismatches. This involves normalizing provider strings in `loadProviderTrackMap` and `buildProviderIds`. I also check that relevant fields like `provider_track_id` are handled correctly even if the provider is unrecognized, and confirm consistent use of playlist and variant parameters across related functions.
file update
M /var/home/rick/Development/playlist-manager/apps/worker/src/processors/exportFile.ts
@@ -219,3 +219,4 @@
     for (const entry of entries) {
-      const field = PROVIDER_ID_FIELDS[entry.provider];
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
       if (field) {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/worker/src/processors/exportFile.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Verifying type usage and imports**
Plan update
Implemented the exportFile processor, object store helper, and supporting logic per the task requirements.
  ✓ Study existing worker/storage/exporter primitives and design approach for export_file processor + tests.
  ✓ Add failing tests (codex suite) and fixtures describing expected export behavior / object store interactions.
  ✓ Implement processExportFile processor + objectStore write helper to satisfy tests; ensure DB queries, exporters, gzip, job updates.
  • Run relevant test suites, verify green, and prepare final git commit with summary.
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Preparing to run targeted tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 1.99s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts [ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts ]
Error: Transform failed with 1 error:
/var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts:64:48: ERROR: Syntax error "\"
  Plugin: vite:esbuild
  File: /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts:64:48
  
  Syntax error "\"
  62 |      });
  63 |  
  64 |      expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
     |                                                  ^
  65 |      expect(writeSpy).toHaveBeenCalledTimes(1);
  66 |      expect(capturedMime).toBe('application/gzip');
  
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Fixing regex escaping in test**
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking test file for escapes**
exec
bash -lc "sed -n '40,90p' codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:

  afterAll(async () => {
    await prisma.$disconnect();
  });

  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
    const { job, playlist } = await createPlaylistFixture();
    const golden = loadGolden('playlist.csv');

    let capturedBody: Buffer | null = null;
    let capturedMime: string | null = null;
    let capturedKey: string | null = null;
    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
      capturedBody = body;
      capturedMime = mime;
      capturedKey = key;
      return `s3://bucket/${key}`;
    });

    const result = await processExportFile({
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0ed6579a657d59ac580e6ba0fc50e578e6d1eb64
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Fixing regex escaping for s3 URL check**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -63,3 +63,3 @@
 
-    expect(result.artifactUrl).toMatch(/^s3:\\/\\/bucket\\//);
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
     expect(writeSpy).toHaveBeenCalledTimes(1);
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Rerunning tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 1.88s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts [ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts ]
Error: Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  10:52:10
   Duration  322ms (transform 56ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 72ms)

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Verifying @prisma/client dependency setup**
exec
bash -lc 'cat packages/db/package.json' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
{
  "name": "@app/db",
  "private": true,
  "type": "module",
  "scripts": {
    "prisma": "prisma",
    "prisma:generate": "prisma generate",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:migrate:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0"
  },
  "devDependencies": {
    "prisma": "^5.22.0",
    "tsx": "^4.16.0"
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking Prisma client build necessity**
exec
bash -lc 'pnpm -F @app/db exec prisma generate' in /var/home/rick/Development/playlist-manager exited 254 in 1.21s:
undefined
/var/home/rick/Development/playlist-manager/packages/db:
 ERR_PNPM_RECURSIVE_EXEC_FIRST_FAIL  Command "prisma" not found
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Clarifying pnpm prisma generate command**
exec
bash -lc 'pnpm -F @app/db prisma generate' in /var/home/rick/Development/playlist-manager exited 1 in 1.20s:

> @app/db@ prisma /var/home/rick/Development/playlist-manager/packages/db
> prisma "generate"

sh: line 1: prisma: command not found
/var/home/rick/Development/playlist-manager/packages/db:
 ERR_PNPM_RECURSIVE_RUN_FIRST_FAIL  @app/db@ prisma: `prisma "generate"`
spawn ENOENT
 WARN   Local package.json exists, but node_modules missing, did you mean to install?
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing Prisma dependency**
exec
bash -lc 'pnpm list prisma' in /var/home/rick/Development/playlist-manager succeeded in 1.13s:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Troubleshooting Prisma generation**
exec
bash -lc 'pnpm exec prisma generate --schema packages/db/prisma/schema.prisma' in /var/home/rick/Development/playlist-manager exited 254 in 1.12s:
undefined
 ERR_PNPM_RECURSIVE_EXEC_FIRST_FAIL  Command "prisma" not found
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating prisma command issues**
exec
bash -lc 'ls node_modules | head' in /var/home/rick/Development/playlist-manager succeeded in 90ms:
acorn
acorn-jsx
ajv
@ampproject
ansi-align
ansi-escapes
ansi-regex
ansis
ansi-styles
@antfu
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking for Prisma client installation**
exec
bash -lc 'ls node_modules/@prisma' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/@prisma': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing @prisma/client dependency**
exec
bash -lc 'cat pnpm-workspace.yaml' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
packages:
  - "apps/*"
  - "packages/*"
  - "packages/providers/*"
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating dependency installation issues**

I'm analyzing why `@prisma/client` isn’t installed despite `pnpm install` running, considering workspace symlink behavior and package visibility inside `node_modules/.pnpm`. I’m weighing options like filtering installs per package or mocking Prisma in tests to handle missing dependencies without changing `package.json`. I'll check `.pnpm` store contents to confirm what's really installed.
exec
bash -lc 'ls node_modules/.pnpm | grep prisma || true' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
prisma@5.22.0
@prisma+client@5.22.0_prisma@5.22.0
@prisma+debug@5.22.0
@prisma+engines@5.22.0
@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
@prisma+fetch-engine@5.22.0
@prisma+get-platform@5.22.0
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm symlink issue**
exec
bash -lc 'cat apps/worker/package.json' in /var/home/rick/Development/playlist-manager exited 1 in 47ms:
cat: apps/worker/package.json: No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Examining package linkage and imports**
exec
bash -lc "ls node_modules | grep '@app' || true" in /var/home/rick/Development/playlist-manager succeeded in 45ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module path resolution**
exec
bash -lc "ls node_modules/.pnpm | grep '@app' || true" in /var/home/rick/Development/playlist-manager succeeded in 49ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking TypeScript configuration paths**
exec
bash -lc "find . -maxdepth 2 -name 'tsconfig*.json'" in /var/home/rick/Development/playlist-manager succeeded in 52ms:
./tsconfig.json
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating import resolution**
exec
bash -lc 'cat packages/contracts/package.json' in /var/home/rick/Development/playlist-manager succeeded in 37ms:
{
  "name": "@app/contracts",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    }
  },
  "dependencies": {
    "ajv": "^8.17.1"
  },
  "devDependencies": {
    "typescript": "^5.6.3"
  }
}
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking for symlink in node_modules**
exec
bash -lc 'ls node_modules/.pnpm | grep contracts || true' in /var/home/rick/Development/playlist-manager succeeded in 49ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating node_modules for @app scope**
exec
bash -lc "find node_modules -maxdepth 1 -type d -name '@app'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module import resolution**
exec
bash -lc "ls node_modules/.pnpm | grep '@app'" in /var/home/rick/Development/playlist-manager exited 1 in 41ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing workspace dependency**
exec
bash -lc 'cat packages/interop/package.json' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
{
  "name": "@app/interop",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "dependencies": {
    "@app/contracts": "workspace:*",
    "ajv": "^6.12.6",
    "fast-xml-parser": "^4.5.1"
  }
}
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating package dependencies**
exec
bash -lc 'cat apps/api/package.json' in /var/home/rick/Development/playlist-manager exited 1 in 39ms:
cat: apps/api/package.json: No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating package resolution for @app/db**
exec
bash -lc "find node_modules/.pnpm -maxdepth 2 -type d -name '@app'" in /var/home/rick/Development/playlist-manager succeeded in 51ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module resolution issues**
exec
bash -lc 'rg -n "module-alias" -n' in /var/home/rick/Development/playlist-manager succeeded in 268ms:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:21448:bash -lc 'rg -n "module-alias" -n' in /var/home/rick/Development/playlist-manager
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking for directories with '@'**
exec
bash -lc "python - <<'PY'
import os
root = 'node_modules'
for name in os.listdir(root):
    if name.startswith('@'):
        print(name)
PY" in /var/home/rick/Development/playlist-manager succeeded in 53ms:
@ampproject
@antfu
@babel
@astrojs
@clack
@dprint
@emnapi
@es-joy
@esbuild
@eslint-community
@eslint
@humanfs
@humanwhocodes
@iconify
@img
@jridgewell
@napi-rs
@mdx-js
@nodelib
@oslojs
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking path configurations**
exec
bash -lc "rg -n '\"paths\"' -n" in /var/home/rick/Development/playlist-manager succeeded in 59ms:
codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log:43262:- If you rely on tsconfig.json's "paths" to resolve modules, please install "vite-tsconfig-paths" plugin to handle module resolution.
apps/api/src/lib/openapi/openapi.json:62:  "paths": {
codex/LOGS/tasklog_05c_importers_file_1762405313.log:242306:- If you rely on tsconfig.json's "paths" to resolve modules, please install "vite-tsconfig-paths" plugin to handle module resolution.
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module resolution for @app packages**
exec
bash -lc 'cat packages/db/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 40ms:
export { prisma } from './client';
export { dbHealthcheck } from './healthcheck';

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm package resolution**
exec
bash -lc 'ls node_modules/.pnpm/node_modules' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/.pnpm/node_modules': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing @prisma/client symlink**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Analyzing dependency setup with pnpm**
exec
bash -lc 'pnpm install' in /var/home/rick/Development/playlist-manager exited 1 in 1m 11s:
Scope: all 9 workspace projects
 WARN  GET https://registry.npmjs.org/ajv error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
 WARN  GET https://registry.npmjs.org/fast-xml-parser error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
 WARN  GET https://registry.npmjs.org/typescript error (EAI_AGAIN). Will retry in 10 seconds. 2 retries left.
Progress: resolved 0, reused 1, downloaded 0, added 0
Progress: resolved 4, reused 4, downloaded 0, added 0
Progress: resolved 5, reused 5, downloaded 0, added 0
Progress: resolved 8, reused 8, downloaded 0, added 0
Progress: resolved 13, reused 13, downloaded 0, added 0
Progress: resolved 20, reused 20, downloaded 0, added 0
 WARN  GET https://registry.npmjs.org/ajv error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
 WARN  GET https://registry.npmjs.org/fast-xml-parser error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
 WARN  GET https://registry.npmjs.org/typescript error (EAI_AGAIN). Will retry in 1 minute. 1 retries left.
/var/home/rick/Development/playlist-manager/packages/interop:
 ERR_PNPM_META_FETCH_FAIL  GET https://registry.npmjs.org/ajv: request to https://registry.npmjs.org/ajv failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org

This error happened while installing a direct dependency of /var/home/rick/Development/playlist-manager/packages/interop
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating offline dependency availability**
exec
bash -lc 'ls node_modules/.pnpm/prisma@5.22.0/node_modules/.bin' in /var/home/rick/Development/playlist-manager exited 2 in 44ms:
ls: cannot access 'node_modules/.pnpm/prisma@5.22.0/node_modules/.bin': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking node_modules for prisma package**
exec
bash -lc 'ls node_modules/.pnpm/prisma@5.22.0' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Listing specific node_modules path**
exec
bash -lc 'ls node_modules/.pnpm/prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 40ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing package linkage**
exec
bash -lc 'ls node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 48ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm dependency storage**
exec
bash -lc 'ls node_modules/.pnpm | head' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
abort-controller@3.0.0
abstract-logging@2.0.1
accepts@1.3.8
agent-base@6.0.2
agent-base@7.1.4
ajv@6.12.3
ajv@6.12.6
ajv@8.17.1
ajv-formats@2.1.1_ajv@8.17.1
ajv-formats@3.0.1_ajv@8.17.1
ls: write error: Broken pipe
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Inspecting package structure inside .pnpm**
exec
bash -lc 'ls node_modules/.pnpm/acorn@* -d | head -n 1' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
ls: cannot access 'node_modules/.pnpm/acorn@*': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Considering versioned package names**
exec
bash -lc 'ls node_modules/.pnpm/abort-controller@3.0.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 40ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating nested abort-controller directory**
exec
bash -lc 'ls node_modules/.pnpm/abort-controller@3.0.0/node_modules | cat' in /var/home/rick/Development/playlist-manager succeeded in 44ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking package layout in pnpm store**
exec
bash -lc 'ls node_modules/.pnpm/abort-controller@3.0.0' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking contents of node_modules directory**
exec
bash -lc 'stat node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller' in /var/home/rick/Development/playlist-manager exited 1 in 98ms:
stat: cannot statx 'node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm node_modules structure**
exec
bash -lc "find node_modules/.pnpm -maxdepth 3 -path '*@prisma+client@*' -print" in /var/home/rick/Development/playlist-manager succeeded in 61ms:
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking package unpacking issues**
exec
bash -lc 'ls node_modules/acorn | head' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
bin
CHANGELOG.md
dist
LICENSE
package.json
README.md
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating Prisma client installation**

I'm examining the state of the `@prisma/client` package inside the `node_modules` and `.pnpm` directories, trying to understand why the package content appears missing or inaccessible. I wonder if symlinks or isolated node linker settings are causing the issue, and I'm considering whether the module might exist in a global store or elsewhere on disk but is not properly linked. I'll check symlink targets closely to clarify this.
exec
bash -lc 'readlink -f node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
/var/home/rick/Development/playlist-manager/node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm virtual store structure**
exec
bash -lc 'ls node_modules/.pnpm/ajv@8.17.1/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 45ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking node_modules structure**
exec
bash -lc "find node_modules/.pnpm -maxdepth 5 -path '*@prisma+client*@*client*' -print" in /var/home/rick/Development/playlist-manager succeeded in 67ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating package contents**
exec
bash -lc 'du -a node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0 | head' in /var/home/rick/Development/playlist-manager succeeded in 99ms:
0	node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
0	node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating empty .pnpm directory**
exec
bash -lc 'du -a node_modules/.pnpm/ajv@6.12.6 | head' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
0	node_modules/.pnpm/ajv@6.12.6/node_modules
0	node_modules/.pnpm/ajv@6.12.6
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing Prisma client installation**
exec
bash -lc 'ls node_modules | grep prisma || true' in /var/home/rick/Development/playlist-manager succeeded in 48ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing Prisma dependency**
exec
bash -lc "find node_modules -maxdepth 2 -name '*prisma*'" in /var/home/rick/Development/playlist-manager succeeded in 55ms:
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
node_modules/.pnpm/prisma@5.22.0
node_modules/.pnpm/@prisma+engines@5.22.0
node_modules/.pnpm/@prisma+debug@5.22.0
node_modules/.pnpm/@prisma+engines-version@5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2
node_modules/.pnpm/@prisma+get-platform@5.22.0
node_modules/.pnpm/@prisma+fetch-engine@5.22.0
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm node_modules structure**
exec
bash -lc 'ls node_modules/.pnpm/node_modules' in /var/home/rick/Development/playlist-manager exited 2 in 38ms:
ls: cannot access 'node_modules/.pnpm/node_modules': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking pnpm store setup**
exec
bash -lc 'cat node_modules/.modules.yaml | head' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
cat: node_modules/.modules.yaml: No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking pnpm configuration files**
exec
bash -lc 'ls .pnpm' in /var/home/rick/Development/playlist-manager exited 2 in 39ms:
ls: cannot access '.pnpm': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Evaluating Prisma client availability and workarounds**

I'm exploring why `@prisma/client` isn't found—considering if `node_modules` is incomplete or symlinked oddly—and thinking about running `prisma generate` or creating manual symlinks to fix this. Since network installs are restricted, I'm weighing options like vendoring a minimal Prisma client or switching to raw SQL with `pg`, though both are major changes. I’m curious about checking the actual presence of Prisma files inside `.pnpm` to decide the best path forward.
exec
bash -lc 'ls node_modules/.pnpm/prisma@5.22.0/node_modules/prisma' in /var/home/rick/Development/playlist-manager exited 2 in 39ms:
ls: cannot access 'node_modules/.pnpm/prisma@5.22.0/node_modules/prisma': No such file or directory
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating package file locations**
exec
bash -lc 'find node_modules/.pnpm/prisma@5.22.0 -maxdepth 5 -print' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
node_modules/.pnpm/prisma@5.22.0
node_modules/.pnpm/prisma@5.22.0/node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating pnpm node_modules structure**
exec
bash -lc 'ls -l node_modules/.pnpm/prisma@5.22.0' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
total 0
drwxr-xr-x 1 rick rick 0 Nov  5 23:35 node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Inspecting node_modules directory**
exec
bash -lc 'ls -l node_modules/.pnpm/prisma@5.22.0/node_modules' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
total 0
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing Prisma dependency**
exec
bash -lc "find node_modules -path '*@prisma*client*'" in /var/home/rick/Development/playlist-manager succeeded in 109ms:
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating dependency presence**
exec
bash -lc "rg -n \"@prisma/client\" -g'*'" in /var/home/rick/Development/playlist-manager exited 124 in 10.08s:
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:377:import { Prisma } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:863:import { PrismaClient } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:2797:import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:3113:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:3626:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:4147:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:4673:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:5186:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:5697:import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:5724:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:6253:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:6767:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:7290:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:7829:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:8346:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:8885:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:9412:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:9926:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:10441:Error: Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
codex/LOGS/tasklog_08b_worker_export_file_1763307527.log:10463:+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating Prisma client availability**
exec
bash -lc 'ls packages/db' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
package.json
prisma
src
test
tsconfig.json
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Evaluating Prisma client absence and mocking strategies**

I'm weighing options for handling missing `@prisma/client` since `node_modules` lacks it. I'm thinking about mocking Prisma in tests by stubbing `@app/db` exports and simulating PrismaClient methods with in-memory data instead of real DB calls. Although feasible, it’s a sizable effort given all required methods. I’m also considering whether I can regenerate Prisma client locally, but missing CLI binaries and incomplete node_modules block that. This might mean dependencies got broken by a failed install wiping packages. Next, I'll check for any archive like `node_modules.tar` to restore dependencies before deciding how to proceed.
exec
bash -lc "find /var/home/rick/Development/playlist-manager -maxdepth 1 -name '*.tar*'" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
/var/home/rick/Development/playlist-manager/Jackett.Binaries.LinuxAMDx64.tar.gz
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Evaluating offline dependency challenges**

I'm analyzing how the failed `pnpm install` affects package availability, especially `@prisma/client`. Since network access is forbidden, I can’t reinstall missing packages from the registry. I'm considering alternatives like mocking database calls in tests or switching from `prisma` to direct `psql` or other DB clients, but that complicates verifying real SQL logic. I'm also exploring if prebuilt modules exist somewhere in the repo or if a workaround like Docker Compose might help, though that still requires client libraries. This environment constraint really limits how to handle database dependencies!
exec
bash -lc "find .. -path '*@prisma*client*' -print" in /var/home/rick/Development/playlist-manager exited 124 in 10.01s:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Narrowing the search scope**
exec
bash -lc "find node_modules -maxdepth 6 -name 'client' -path '*prisma*' | head" in /var/home/rick/Development/playlist-manager succeeded in 105ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Considering offline package installation**

I’m thinking through the missing `@prisma/client` package and how to restore it without network access. Since the package isn’t installed and dependencies like `pg` are missing, I’m exploring alternatives like vendoring a stub or running direct SQL commands. I suspect the existing package store might have the needed packages, so I’ll try running `pnpm install --offline` to leverage the local cache.
exec
bash -lc 'pnpm install --offline' in /var/home/rick/Development/playlist-manager exited 1 in 1.25s:
Scope: all 9 workspace projects
/var/home/rick/Development/playlist-manager/packages/interop:
 ERR_PNPM_NO_OFFLINE_META  Failed to resolve ajv@>=6.12.6 <7.0.0-0 in package mirror /home/rick/.cache/pnpm/metadata/registry.npmjs.org/ajv.json

This error happened while installing a direct dependency of /var/home/rick/Development/playlist-manager/packages/interop
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating missing node_modules issues**
exec
bash -lc 'ls -a' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
.
..
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
.env
.env.example
env.json
.git
.github
.gitignore
Jackett
Jackett.Binaries.LinuxAMDx64.tar.gz
node_modules
.npmrc
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Checking for .npmrc configuration**
exec
bash -lc 'cat .npmrc' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
ignore-workspace-root-check=true
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Considering module mocking and dependency issues**
exec
bash -lc "find node_modules -maxdepth 2 -type d -name 'db'" in /var/home/rick/Development/playlist-manager succeeded in 53ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Analyzing import path resolution**
exec
bash -lc "find apps -name 'tsconfig*.json'" in /var/home/rick/Development/playlist-manager succeeded in 47ms:
apps/web/tsconfig.json
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module resolution and path aliasing**
exec
bash -lc "ls node_modules/.pnpm | grep '@app'" in /var/home/rick/Development/playlist-manager exited 1 in 47ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating module resolution and aliases**
exec
bash -lc "sed -n '1,200p' vitest.config.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { defineConfig } from 'vitest/config';

const rootDir = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  resolve: {
    alias: {
      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
      '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
      '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
      '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
      '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),
      '@app/providers-youtube': path.resolve(rootDir, 'packages/providers/youtube/src/index.ts'),
      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
      supertest: path.resolve(rootDir, 'codex/support/supertest.ts'),
    },
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}



thinking
**Designing comprehensive Prisma stub for tests**

I'm figuring out how to fully mock the Prisma client by creating an in-memory stub that mimics its API and data tables, so tests can run without the actual database or Prisma package. This involves intercepting the '@app/db' import with `vi.mock` to provide a stub implementing key methods like `create`, `findUnique`, `update`, and raw query simulations, while also handling alias resolution complexities. Because the code depends on `'@prisma/client'` types and runtime objects, I realize I need to mock or alias that module too to prevent bundler errors, possibly via `vi.mock` or config aliases, ensuring that both runtime and compile-time expectations are satisfied without installing the real Prisma package. It’s a substantial complexity, but by carefully designing the stub and mocking strategy, I can run these tests in isolation without requiring a real database or Prisma dependency.
thinking
**Planning Prisma client stub and aliasing strategy**

I'm considering creating a minimal stub module for `'@prisma/client'` that provides the needed exports like `PrismaClient` class and `Prisma` namespace to satisfy runtime and TypeScript, then aliasing it in the test config or placing it inside `node_modules` as a local stub. This will let the bundler resolve imports without errors and support mocking `@app/db` with an in-memory Prisma stub for tests. The approach balances ensuring smooth test execution without the actual Prisma package while avoiding intrusive changes to the environment or global config.
exec
bash -lc 'rg -n "@prisma/client" -g"*.ts"' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
apps/worker/src/processors/exportFile.ts:5:import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
apps/api/src/lib/db/effectiveItems.ts:3:import { Prisma } from '@prisma/client';
packages/db/prisma/seed.ts:1:import { Prisma, PrismaClient } from '@prisma/client';
packages/db/src/client.ts:1:import { PrismaClient } from '@prisma/client';
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Designing Prisma client stub for tests**

This is a detailed plan to create a stub implementation of PrismaClient and Prisma namespace to satisfy imports and queries during tests without a real database; I’m weighing options between patching node_modules, mocking the module virtually in tests, and replicating needed methods with in-memory data to handle queries and mutations used across the repo. I’m also considering type definitions and the impact on the entire test suite if other tests rely on real Prisma, noting risks and complexities around providing a full stub versus restoring the original node_modules.
exec
bash -lc "find . -path '*prisma*client*' -maxdepth 5 | head" in /var/home/rick/Development/playlist-manager succeeded in 170ms:
./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0
./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating Prisma usage in tests**
exec
bash -lc "rg -n \"prisma\\.\"" in /var/home/rick/Development/playlist-manager succeeded in 59ms:
codex/LOGS/tasklog_07b_route_exports_file_1763303753.log:1057:  - Use prisma.$queryRaw to read the view; keep pagination simple (id > cursor).
codex/LOGS/tasklog_04a_api_validation_wiring_1762394370.log:239:  await prisma.$connect();
codex/LOGS/tasklog_04a_api_validation_wiring_1762394370.log:240:  const user = await prisma.user.create({ data: {} });
codex/LOGS/tasklog_04a_api_validation_wiring_1762394370.log:245:  await prisma.playlist.deleteMany();
codex/LOGS/tasklog_04a_api_validation_wiring_1762394370.log:249:  await prisma.activePlaylist.deleteMany();
codex/LOGS/tasklog_04a_api_validation_wiring_1762394370.log:250:  await prisma.user.deleteMany();
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:62:      1) Mocks prisma.account.findFirst to return access_token (then null) and asserts success/throw.
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:571:    (db.prisma.account.findFirst as any).mockResolvedValueOnce({ access_token: 'tok-123' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:576:    (db.prisma.account.findFirst as any).mockResolvedValueOnce(null);
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:608:    (db.prisma.account.findFirst as any).mockResolvedValue({ access_token: 'tok-xyz' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:672:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce({ access_token: 'tok-123' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:677:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce(null);
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:709:+    (db.prisma.account.findFirst as any).mockResolvedValue({ access_token: 'tok-xyz' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:771:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce({ access_token: 'tok-123' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:776:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce(null);
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:808:+    (db.prisma.account.findFirst as any).mockResolvedValue({ access_token: 'tok-xyz' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:877:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce({ access_token: 'tok-123' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:882:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce(null);
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:914:+    (db.prisma.account.findFirst as any).mockResolvedValue({ access_token: 'tok-xyz' });
codex/LOGS/tasklog_06f_provider_factory_tests_1762417333.log:1001:+    (db.prisma.account.findFirst as any).mockResolvedValueOnce({ access_token: 'tok-123' });
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Evaluating Prisma dependency restoration**
exec
bash -lc "node -e \"import('@prisma/client').then(() => console.log('ok')).catch(err => console.error(err.message))\"" in /var/home/rick/Development/playlist-manager succeeded in 159ms:
Cannot find package '@prisma/client' imported from /var/home/rick/Development/playlist-manager/[eval]
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Investigating Prisma client availability**
exec
bash -lc "find . -name '.prisma' -type d" in /var/home/rick/Development/playlist-manager succeeded in 128ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Evaluating strategies for Prisma client handling**
exec
bash -lc "find /var/home/rick -path '*@prisma*client*' -maxdepth 5 2>/dev/null | head" in /var/home/rick/Development/playlist-manager exited 124 in 10.00s:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}


thinking
**Planning test strategy for Prisma dependencies**
exec
bash -lc "rg -l \"from '@app/db'\" codex/code" in /var/home/rick/Development/playlist-manager exited 1 in 46ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8cc230db57a4e49fbdbad0393d944385baae9dba
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,157 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+import { prisma } from '../../../../../packages/db/src/client';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe(`
+    TRUNCATE TABLE
+      playlist_item,
+      provider_track_map,
+      provider_playlist_map,
+      recording_artist,
+      recording,
+      album,
+      artist_relation,
+      artist_link,
+      artist_bio,
+      artist_follow,
+      playlist,
+      active_playlist,
+      job,
+      account,
+      app_user
+    RESTART IDENTITY CASCADE;
+  `);
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}



thinking
**Designing Prisma client stubs for tests**

There is a lot here about how to mock `@prisma/client` and database access in tests using Vitest’s virtual modules. I’m sketching out a plan to create stub implementations of `PrismaClient` and related objects using `vi.mock` so tests run without the real database or Prisma client installed. Key points include mocking both `'@prisma/client'` (virtual) and `'@app/db'` (alias), restructuring imports in the test file to use these mocks, and implementing stub methods with in-memory state to simulate queries and mutations used by the test suite. This approach helps isolate the target test while avoiding global config changes or actual DB dependencies. I’ll implement hoisted mocks early in the test file and provide supporting stub functions and state tracking for operations like create, find, update, and raw queries based on SQL patterns. It’s complex but necessary given the repo’s alias setup and Vitest’s bundling behavior.
thinking
**Mapping detailed Prisma stub implementation**

I’m outlining the full design for the Prisma stub’s internal methods and state management, including how to handle resets, creates, finds, updates, and raw queries. The stub will track entities in-memory and implement specific query logic to mimic SQL view results, handling relations like artists and albums. I’m planning the structure for hoisted mocks with functional implementations and helpers to maintain sequences and normalized data, ensuring compatibility with Vitest’s mocking and module resolution. This plan sets the stage for rewriting the test file to use these comprehensive stubs effectively.
exec
bash -lc "cat <<'EOF' > codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
import { gunzipSync } from 'node:zlib';
import { readFileSync } from 'node:fs';
import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';

const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });

const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
vi.mock('@app/db', () => dbModule);

import { prisma } from '@app/db';
import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
import * as objectStore from '../../../../apps/worker/src/storage/objectStore';

const GOLDENS_DIR = new URL('./goldens/', import.meta.url);

const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');

async function resetDatabase() {
  await prisma."'$executeRawUnsafe('"'RESET');
}

describe('processExportFile', () => {
  beforeEach(async () => {
    await resetDatabase();
    vi.restoreAllMocks();
  });

  afterAll(async () => {
    await prisma."'$disconnect();
  });

  test('"'renders CSV lean export and writes gzip artifact to object storage', async () => {
    const { job, playlist } = await createPlaylistFixture();
    const golden = loadGolden('playlist.csv');

    let capturedBody: Buffer | null = null;
    let capturedMime: string | null = null;
    let capturedKey: string | null = null;
    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
      capturedBody = body;
      capturedMime = mime;
      capturedKey = key;
      return "'`s3://bucket/${key}`;
    });

    const result = await processExportFile({
      jobId: job.id,
      payload: { playlist_id: playlist.id, format: '"'csv', variant: 'lean' },
    });

    expect(result.artifactUrl).toMatch(/"'^s3:'"\\/\\/bucket\\//);
    expect(writeSpy).toHaveBeenCalledTimes(1);
    expect(capturedMime).toBe('application/gzip');
    expect(capturedKey).toMatch(/playlist/);

    const decompressed = gunzipSync(capturedBody"'!).toString('"'utf8');
    expect(decompressed).toEqual(golden);

    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
    expect(updatedJob.status).toBe('succeeded');
    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
  });
});

async function createPlaylistFixture() {
  const user = await prisma.user.create({
    data: {
      email: "'`worker-export+${Math.random().toString(16).slice(2)}@local`,
    },
  });

  const playlist = await prisma.playlist.create({
    data: {
      user_id: user.id,
      name: '"'Codex Export Playlist',
      description: 'Fixture for worker export job',
      provider: 'spotify',
      provider_playlist_id: 'demo-playlist',
    },
  });

  const job = await prisma.job.create({
    data: {
      user_id: user.id,
      kind: 'export_file',
      status: 'running',
      playlist_id: playlist.id,
    },
  });

  const album = await prisma.album.create({
    data: {
      title: 'Out of Time',
    },
  });

  const recording = await prisma.recording.create({
    data: {
      title: 'Losing My Religion',
      album_id: album.id,
      duration_ms: 269000,
      isrc: 'USWB19902945',
    },
  });

  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });

  await prisma.recordingArtist.createMany({
    data: [
      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
    ],
  });

  await prisma.providerTrackMap.createMany({
    data: [
      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
    ],
  });

  await prisma.playlistItem.create({
    data: {
      playlist_id: playlist.id,
      position: 0,
      recording_id: recording.id,
      duration_ms: recording.duration_ms,
      isrc: 'USWB19902945',
    },
  });

  await prisma.playlistItem.create({
    data: {
      playlist_id: playlist.id,
      snapshot_title: 'Hurt',
      snapshot_artists: 'Nine Inch Nails',
      snapshot_album: 'The Downward Spiral',
      provider_track_id: 'track-unmatched',
    },
  });

  return { user, playlist, job };
}

function createPrismaClientModule() {
  class PrismaClient {}
  const Prisma = {
    sql(strings: TemplateStringsArray, ...values: unknown[]) {
      return { strings, values };
    },
    empty: Symbol('prisma-empty'),
  };
  return { PrismaClient, Prisma };
}

type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';

type PlaylistItemRecord = {
  id: number;
  playlist_id: number;
  position: number | null;
  recording_id: number | null;
  duration_ms: number | null;
  isrc: string | null;
  mb_recording_id?: string | null;
  mb_release_id?: string | null;
  snapshot_title?: string | null;
  snapshot_artists?: string | null;
  snapshot_album?: string | null;
  provider_track_id?: string | null;
};

type RecordingArtistRecord = {
  recording_id: number;
  artist_id: number;
  ordinal: number | null;
};

type ProviderTrackRecord = {
  id: number;
  provider: string;
  provider_track_id: string;
  recording_id: number;
};

function createPrismaStub() {
  const seq: Record<IdKey, number> = {
    user: 1,
    playlist: 1,
    job: 1,
    album: 1,
    recording: 1,
    artist: 1,
    playlistItem: 1,
    providerTrackMap: 1,
  };

  const state = {
    users: [] as Array<{ id: number; email: string }>,
    playlists: [] as Array<{
      id: number;
      user_id: number;
      name: string | null;
      description: string | null;
      provider: string | null;
      provider_playlist_id: string | null;
    }>,
    jobs: [] as Array<{
      id: number;
      user_id: number;
      kind: string;
      status: string;
      playlist_id: number | null;
      artifact_url: string | null;
      report_json: unknown;
    }>,
    albums: [] as Array<{ id: number; title: string }>,
    recordings: [] as Array<{
      id: number;
      title: string | null;
      duration_ms: number | null;
      album_id: number | null;
      isrc: string | null;
    }>,
    artists: [] as Array<{ id: number; name: string }>,
    recordingArtists: [] as RecordingArtistRecord[],
    providerTrackMaps: [] as ProviderTrackRecord[],
    playlistItems: [] as PlaylistItemRecord[],
  };

  const nextId = (key: IdKey): number => seq[key]++;

  const reset = () => {
    for (const key of Object.keys(seq) as IdKey[]) {
      seq[key] = 1;
    }
    state.users.length = 0;
    state.playlists.length = 0;
    state.jobs.length = 0;
    state.albums.length = 0;
    state.recordings.length = 0;
    state.artists.length = 0;
    state.recordingArtists.length = 0;
    state.providerTrackMaps.length = 0;
    state.playlistItems.length = 0;
  };

  return {
    async "'$executeRawUnsafe(): Promise<number> {
      reset();
      return 0;
    },
    async $disconnect(): Promise<void> {
      return;
    },
    user: {
      create: async ({ data }: { data: { email: string } }) => {
        const record = { id: nextId('"'user'), email: data.email };
        state.users.push(record);
        return record;
      },
    },
    playlist: {
      create: async ({ data }: { data: any }) => {
        const record = {
          id: nextId('playlist'),
          user_id: data.user_id,
          name: data.name ?? null,
          description: data.description ?? null,
          provider: data.provider ?? null,
          provider_playlist_id: data.provider_playlist_id ?? null,
        };
        state.playlists.push(record);
        return record;
      },
      findUnique: async ({ where }: { where: { id: number } }) =>
        state.playlists.find((p) => p.id === where.id) ?? null,
    },
    job: {
      create: async ({ data }: { data: any }) => {
        const record = {
          id: nextId('job'),
          user_id: data.user_id,
          kind: data.kind,
          status: data.status ?? 'queued',
          playlist_id: data.playlist_id ?? null,
          artifact_url: data.artifact_url ?? null,
          report_json: data.report_json ?? null,
        };
        state.jobs.push(record);
        return record;
      },
      findUnique: async ({ where }: { where: { id: number } }) =>
        state.jobs.find((job) => job.id === where.id) ?? null,
      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
        const job = state.jobs.find((j) => j.id === where.id);
        if ("'!job) {
          throw new Error('"'Job not found');
        }
        return job;
      },
      update: async ({ where, data }: { where: { id: number }; data: any }) => {
        const job = state.jobs.find((j) => j.id === where.id);
        if ("'!job) {
          throw new Error('"'Job not found');
        }
        Object.assign(job, data);
        return job;
      },
    },
    album: {
      create: async ({ data }: { data: { title: string } }) => {
        const record = { id: nextId('album'), title: data.title };
        state.albums.push(record);
        return record;
      },
    },
    recording: {
      create: async ({ data }: { data: any }) => {
        const record = {
          id: nextId('recording'),
          title: data.title ?? null,
          duration_ms: data.duration_ms ?? null,
          album_id: data.album_id ?? null,
          isrc: data.isrc ?? null,
        };
        state.recordings.push(record);
        return record;
      },
    },
    artist: {
      create: async ({ data }: { data: { name: string } }) => {
        const record = { id: nextId('artist'), name: data.name };
        state.artists.push(record);
        return record;
      },
    },
    recordingArtist: {
      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
        const entries = Array.isArray(data) ? data : [data];
        for (const entry of entries) {
          state.recordingArtists.push({
            recording_id: entry.recording_id,
            artist_id: entry.artist_id,
            ordinal: entry.ordinal ?? null,
          });
        }
        return { count: entries.length };
      },
    },
    providerTrackMap: {
      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
        const entries = Array.isArray(data) ? data : [data];
        for (const entry of entries) {
          state.providerTrackMaps.push({
            id: nextId('providerTrackMap'),
            provider: entry.provider,
            provider_track_id: entry.provider_track_id,
            recording_id: entry.recording_id,
          });
        }
        return { count: entries.length };
      },
      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
        const ids: number[] = where?.recording_id?.in ?? [];
        return state.providerTrackMaps
          .filter((row) => ids.includes(row.recording_id))
          .map((row) => {
            if ("'!select) return row;
            const result: Record<string, unknown> = {};
            for (const key of Object.keys(select)) {
              if (select[key as keyof ProviderTrackRecord]) {
                result[key] = (row as any)[key];
              }
            }
            return result;
          });
      },
    },
    playlistItem: {
      create: async ({ data }: { data: any }) => {
        const record: PlaylistItemRecord = {
          id: nextId('"'playlistItem'),
          playlist_id: data.playlist_id,
          position: data.position ?? null,
          recording_id: data.recording_id ?? null,
          duration_ms: data.duration_ms ?? null,
          isrc: data.isrc ?? null,
          mb_recording_id: data.mb_recording_id ?? null,
          mb_release_id: data.mb_release_id ?? null,
          snapshot_title: data.snapshot_title ?? null,
          snapshot_artists: data.snapshot_artists ?? null,
          snapshot_album: data.snapshot_album ?? null,
          provider_track_id: data.provider_track_id ?? null,
        };
        state.playlistItems.push(record);
        return record;
      },
    },
    async "'$queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
      if (query?.strings?.join('"' ').includes('v_playlist_item_effective')) {
        const playlistId = (query.values?.[0] ?? null) as number | null;
        if (typeof playlistId "'!== '"'number') {
          return [];
        }
        return buildEffectiveRows(state, playlistId);
      }
      return [];
    },
  };
}

function buildEffectiveRows(state: ReturnType<typeof createPrismaStub> extends infer T ? T extends { "'$queryRaw: any } ? any : never : never, playlistId: number) {
  const items = (state as any).playlistItems.filter((item: PlaylistItemRecord) => item.playlist_id === playlistId);
  return items
    .map((item: PlaylistItemRecord) => {
      const recording = typeof item.recording_id === '"'number'
        ? (state as any).recordings.find((r: any) => r.id === item.recording_id)
        : null;
      const album = recording?.album_id
        ? (state as any).albums.find((a: any) => a.id === recording.album_id)
        : null;
      const artists = normalizeArtists(state as any, item.recording_id);
      return {
        id: item.id,
        playlist_id: item.playlist_id,
        position: item.position,
        title: recording?.title ?? item.snapshot_title ?? '',
        artists: artists ?? (item.snapshot_artists ?? ''),
        album: album?.title ?? item.snapshot_album ?? null,
        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
        recording_id: item.recording_id,
        isrc: item.isrc ?? null,
        mb_recording_id: item.mb_recording_id ?? null,
        mb_release_id: item.mb_release_id ?? null,
        provider_track_id: item.provider_track_id ?? null,
      };
    })
    .sort((a: any, b: any) => {
      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
      if (posA "'!== posB) {
        return posA - posB;
      }
      return a.id - b.id;
    });
}

function normalizeArtists(state: any, recordingId: number | null) {
  if (typeof recordingId !== '"'number') {
    return null;
  }
  const entries: RecordingArtistRecord[] = state.recordingArtists
    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
  if (entries.length === 0) {
    return null;
  }
  const names = entries
    .map((entry) => state.artists.find((artist: any) => artist.id === entry.artist_id)?.name)
    .filter((name): name is string => typeof name === 'string' && name.length > 0);
  return names.length > 0 ? names.join('; ') : null;
}
EOF" in /var/home/rick/Development/playlist-manager succeeded in 48ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a7bb3f15474164e242ca3f3a1b5e7b1a4aca72eb
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,465 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state = {
+    users: [] as Array<{ id: number; email: string }>,
+    playlists: [] as Array<{
+      id: number;
+      user_id: number;
+      name: string | null;
+      description: string | null;
+      provider: string | null;
+      provider_playlist_id: string | null;
+    }>,
+    jobs: [] as Array<{
+      id: number;
+      user_id: number;
+      kind: string;
+      status: string;
+      playlist_id: number | null;
+      artifact_url: string | null;
+      report_json: unknown;
+    }>,
+    albums: [] as Array<{ id: number; title: string }>,
+    recordings: [] as Array<{
+      id: number;
+      title: string | null;
+      duration_ms: number | null;
+      album_id: number | null;
+      isrc: string | null;
+    }>,
+    artists: [] as Array<{ id: number; name: string }>,
+    recordingArtists: [] as RecordingArtistRecord[],
+    providerTrackMaps: [] as ProviderTrackRecord[],
+    playlistItems: [] as PlaylistItemRecord[],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: ReturnType<typeof createPrismaStub> extends infer T ? T extends { $queryRaw: any } ? any : never : never, playlistId: number) {
+  const items = (state as any).playlistItems.filter((item: PlaylistItemRecord) => item.playlist_id === playlistId);
+  return items
+    .map((item: PlaylistItemRecord) => {
+      const recording = typeof item.recording_id === 'number'
+        ? (state as any).recordings.find((r: any) => r.id === item.recording_id)
+        : null;
+      const album = recording?.album_id
+        ? (state as any).albums.find((a: any) => a.id === recording.album_id)
+        : null;
+      const artists = normalizeArtists(state as any, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a: any, b: any) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: any, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist: any) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Reviewing and simplifying TypeScript types**
exec
bash -lc "sed -n '1,320p' codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
import { gunzipSync } from 'node:zlib';
import { readFileSync } from 'node:fs';
import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';

const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });

const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
vi.mock('@app/db', () => dbModule);

import { prisma } from '@app/db';
import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
import * as objectStore from '../../../../apps/worker/src/storage/objectStore';

const GOLDENS_DIR = new URL('./goldens/', import.meta.url);

const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');

async function resetDatabase() {
  await prisma.$executeRawUnsafe('RESET');
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a7bb3f15474164e242ca3f3a1b5e7b1a4aca72eb
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,465 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state = {
+    users: [] as Array<{ id: number; email: string }>,
+    playlists: [] as Array<{
+      id: number;
+      user_id: number;
+      name: string | null;
+      description: string | null;
+      provider: string | null;
+      provider_playlist_id: string | null;
+    }>,
+    jobs: [] as Array<{
+      id: number;
+      user_id: number;
+      kind: string;
+      status: string;
+      playlist_id: number | null;
+      artifact_url: string | null;
+      report_json: unknown;
+    }>,
+    albums: [] as Array<{ id: number; title: string }>,
+    recordings: [] as Array<{
+      id: number;
+      title: string | null;
+      duration_ms: number | null;
+      album_id: number | null;
+      isrc: string | null;
+    }>,
+    artists: [] as Array<{ id: number; name: string }>,
+    recordingArtists: [] as RecordingArtistRecord[],
+    providerTrackMaps: [] as ProviderTrackRecord[],
+    playlistItems: [] as PlaylistItemRecord[],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: ReturnType<typeof createPrismaStub> extends infer T ? T extends { $queryRaw: any } ? any : never : never, playlistId: number) {
+  const items = (state as any).playlistItems.filter((item: PlaylistItemRecord) => item.playlist_id === playlistId);
+  return items
+    .map((item: PlaylistItemRecord) => {
+      const recording = typeof item.recording_id === 'number'
+        ? (state as any).recordings.find((r: any) => r.id === item.recording_id)
+        : null;
+      const album = recording?.album_id
+        ? (state as any).albums.find((a: any) => a.id === recording.album_id)
+        : null;
+      const artists = normalizeArtists(state as any, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a: any, b: any) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: any, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist: any) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Checking buildEffectiveRows usage**
exec
bash -lc "sed -n '320,640p' codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 48ms:
    recording: {
      create: async ({ data }: { data: any }) => {
        const record = {
          id: nextId('recording'),
          title: data.title ?? null,
          duration_ms: data.duration_ms ?? null,
          album_id: data.album_id ?? null,
          isrc: data.isrc ?? null,
        };
        state.recordings.push(record);
        return record;
      },
    },
    artist: {
      create: async ({ data }: { data: { name: string } }) => {
        const record = { id: nextId('artist'), name: data.name };
        state.artists.push(record);
        return record;
      },
    },
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a7bb3f15474164e242ca3f3a1b5e7b1a4aca72eb
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,465 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state = {
+    users: [] as Array<{ id: number; email: string }>,
+    playlists: [] as Array<{
+      id: number;
+      user_id: number;
+      name: string | null;
+      description: string | null;
+      provider: string | null;
+      provider_playlist_id: string | null;
+    }>,
+    jobs: [] as Array<{
+      id: number;
+      user_id: number;
+      kind: string;
+      status: string;
+      playlist_id: number | null;
+      artifact_url: string | null;
+      report_json: unknown;
+    }>,
+    albums: [] as Array<{ id: number; title: string }>,
+    recordings: [] as Array<{
+      id: number;
+      title: string | null;
+      duration_ms: number | null;
+      album_id: number | null;
+      isrc: string | null;
+    }>,
+    artists: [] as Array<{ id: number; name: string }>,
+    recordingArtists: [] as RecordingArtistRecord[],
+    providerTrackMaps: [] as ProviderTrackRecord[],
+    playlistItems: [] as PlaylistItemRecord[],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: ReturnType<typeof createPrismaStub> extends infer T ? T extends { $queryRaw: any } ? any : never : never, playlistId: number) {
+  const items = (state as any).playlistItems.filter((item: PlaylistItemRecord) => item.playlist_id === playlistId);
+  return items
+    .map((item: PlaylistItemRecord) => {
+      const recording = typeof item.recording_id === 'number'
+        ? (state as any).recordings.find((r: any) => r.id === item.recording_id)
+        : null;
+      const album = recording?.album_id
+        ? (state as any).albums.find((a: any) => a.id === recording.album_id)
+        : null;
+      const artists = normalizeArtists(state as any, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a: any, b: any) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: any, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist: any) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Simplifying TypeScript typings and state management**

I’m working on defining a clear `PrismaState` type to replace complex generics and improve readability. This includes typing the `state` object inside `createPrismaStub`, simplifying function signatures like `buildEffectiveRows` and `normalizeArtists` to accept this typed state, and cleaning up `select` checks in `providerTrackMap.findMany`. I'll ensure that closures and typings align correctly and adjust exports and function ordering for proper hoisting and accessibility.
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -187,2 +187,35 @@
 
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
 function createPrismaStub() {
@@ -199,33 +232,12 @@
 
-  const state = {
-    users: [] as Array<{ id: number; email: string }>,
-    playlists: [] as Array<{
-      id: number;
-      user_id: number;
-      name: string | null;
-      description: string | null;
-      provider: string | null;
-      provider_playlist_id: string | null;
-    }>,
-    jobs: [] as Array<{
-      id: number;
-      user_id: number;
-      kind: string;
-      status: string;
-      playlist_id: number | null;
-      artifact_url: string | null;
-      report_json: unknown;
-    }>,
-    albums: [] as Array<{ id: number; title: string }>,
-    recordings: [] as Array<{
-      id: number;
-      title: string | null;
-      duration_ms: number | null;
-      album_id: number | null;
-      isrc: string | null;
-    }>,
-    artists: [] as Array<{ id: number; name: string }>,
-    recordingArtists: [] as RecordingArtistRecord[],
-    providerTrackMaps: [] as ProviderTrackRecord[],
-    playlistItems: [] as PlaylistItemRecord[],
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
   };
@@ -414,13 +426,12 @@
 
-function buildEffectiveRows(state: ReturnType<typeof createPrismaStub> extends infer T ? T extends { $queryRaw: any } ? any : never : never, playlistId: number) {
-  const items = (state as any).playlistItems.filter((item: PlaylistItemRecord) => item.playlist_id === playlistId);
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
   return items
-    .map((item: PlaylistItemRecord) => {
-      const recording = typeof item.recording_id === 'number'
-        ? (state as any).recordings.find((r: any) => r.id === item.recording_id)
-        : null;
-      const album = recording?.album_id
-        ? (state as any).albums.find((a: any) => a.id === recording.album_id)
-        : null;
-      const artists = normalizeArtists(state as any, item.recording_id);
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
       return {
@@ -440,3 +451,3 @@
     })
-    .sort((a: any, b: any) => {
+    .sort((a, b) => {
       const posA = a.position ?? Number.MAX_SAFE_INTEGER;
@@ -450,3 +461,3 @@
 
-function normalizeArtists(state: any, recordingId: number | null) {
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
   if (typeof recordingId !== 'number') {
@@ -461,3 +472,3 @@
   const names = entries
-    .map((entry) => state.artists.find((artist: any) => artist.id === entry.artist_id)?.name)
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
     .filter((name): name is string => typeof name === 'string' && name.length > 0);
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e9e52c25ea8d35e0711444869f2bd7a668943d5
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e9e52c25ea8d35e0711444869f2bd7a668943d5
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Verifying Prisma stub and test readiness**

I’m making sure the Prisma stub methods and types align correctly, especially `providerTrackMap.findMany` and `Prisma.empty` for SQL cursors. I’m also confirming export of `PrismaClient` and the setup of `createPrismaStub` and `createPrismaClientModule`. Now I’m preparing to re-run tests, keeping an eye on the `objectStore.write` implementation issue.
exec
bash -lc 'pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 1.97s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts [ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts ]
Error: Failed to load url ../../../../apps/worker/src/processors/exportFile (resolved id: ../../../../apps/worker/src/processors/exportFile) in /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  11:09:10
   Duration  368ms (transform 82ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 71ms)

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4e9e52c25ea8d35e0711444869f2bd7a668943d5
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Correcting import path levels**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -11,4 +11,4 @@
 import { prisma } from '@app/db';
-import { processExportFile } from '../../../../apps/worker/src/processors/exportFile';
-import * as objectStore from '../../../../apps/worker/src/storage/objectStore';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
 
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Re-running tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.05s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts [ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts ]
Error: Failed to load url @app/providers-file-exporters (resolved id: @app/providers-file-exporters) in /var/home/rick/Development/playlist-manager/apps/worker/src/processors/exportFile.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  11:09:32
   Duration  418ms (transform 97ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 75ms)

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}


thinking
**Adding missing alias for module resolution**
file update
M /var/home/rick/Development/playlist-manager/vitest.config.ts
@@ -13,2 +13,3 @@
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M vitest.config.ts
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Rerunning tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 2.12s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts (1 test) 14ms

 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  11:09:49
   Duration  448ms (transform 128ms, setup 0ms, collect 137ms, tests 14ms, environment 0ms, prepare 79ms)

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Updating plan to include tests and commit**
Plan update
Implemented the new processor, storage helper, and accompanying in-memory testing scaffolds; verified the targeted test suite passes.
  ✓ Study existing worker/storage/exporter primitives and design approach for export_file processor + tests.
  ✓ Add failing tests (codex suite) and fixtures describing expected export behavior / object store interactions.
  ✓ Implement processExportFile processor + objectStore write helper to satisfy tests; ensure DB queries, exporters, gzip, job updates.
  ✓ Run relevant test suites, verify green, and prepare final git commit with summary.
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Checking git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 82ms:
## main...origin/main [ahead 16]
 M vitest.config.ts
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? apps/worker/src/processors/
?? apps/worker/src/storage/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log.done
?? codex/LOGS/tasklog_08b_worker_export_file_1763307527.log
?? codex/TASKS/q
?? codex/TASKS/work_list
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing selective git staging**
exec
bash -lc 'git add apps/worker/src/processors/exportFile.ts apps/worker/src/storage/objectStore.ts codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts codex/code/codex/08b_worker_export_file/tests/goldens/playlist.csv vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 45ms:

file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Checking git staged status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
## main...origin/main [ahead 16]
A  apps/worker/src/processors/exportFile.ts
A  apps/worker/src/storage/objectStore.ts
A  codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
A  codex/code/codex/08b_worker_export_file/tests/goldens/playlist.csv
M  vitest.config.ts
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log.done
?? codex/LOGS/tasklog_08b_worker_export_file_1763307527.log
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing commit for new changes**
exec
bash -lc 'git commit -m "feat(worker): add export file processor"' in /var/home/rick/Development/playlist-manager succeeded in 84ms:
[main 4344b5b] feat(worker): add export file processor
 5 files changed, 817 insertions(+)
 create mode 100644 apps/worker/src/processors/exportFile.ts
 create mode 100644 apps/worker/src/storage/objectStore.ts
 create mode 100644 codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
 create mode 100644 codex/code/codex/08b_worker_export_file/tests/goldens/playlist.csv
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Checking staged changes for vitest config**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
## main...origin/main [ahead 17]
?? Jackett.Binaries.LinuxAMDx64.tar.gz
?? Jackett/
?? codex/LOGS/codex_run_2025-11-16_08-49-16.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log
?? codex/LOGS/tasklog_07a_routes_playlist_items_effective_1763300956.log.done
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log
?? codex/LOGS/tasklog_07b_route_exports_file_1763303753.log.done
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log
?? codex/LOGS/tasklog_07c_error_contracts_1763302301.log.done
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log
?? codex/LOGS/tasklog_07d_sse_job_progress_1763304537.log.done
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log
?? codex/LOGS/tasklog_08a_worker_jobs_gc_1763306172.log.done
?? codex/LOGS/tasklog_08b_worker_export_file_1763307527.log
?? codex/TASKS/q
?? codex/TASKS/work_list
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing detailed commit summary**
exec
bash -lc "nl -ba apps/worker/src/processors/exportFile.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
     1	import { promisify } from 'node:util';
     2	import { gzip } from 'node:zlib';
     3	
     4	import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
     5	import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
     6	
     7	import { prisma } from '@app/db';
     8	import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
     9	import * as objectStore from '../storage/objectStore';
    10	
    11	const gzipAsync = promisify(gzip);
    12	
    13	type ExportFormat = 'csv' | 'm3u' | 'xspf';
    14	
    15	export type ExportFilePayload = {
    16	  playlist_id: number;
    17	  format: ExportFormat;
    18	  variant?: CsvVariant;
    19	};
    20	
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing line references**
exec
bash -lc 'nl -ba apps/worker/src/storage/objectStore.ts' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
     1	import { promises as fs } from 'node:fs';
     2	import { dirname, join, resolve } from 'node:path';
     3	
     4	export type WriteObjectParams = {
     5	  body: Buffer;
     6	  contentType: string;
     7	  key: string;
     8	};
     9	
    10	export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
    11	
    12	const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
    13	
    14	let customWriter: ObjectStoreWriter | null = null;
    15	
    16	export function configureObjectStore(writer: ObjectStoreWriter | null): void {
    17	  customWriter = writer;
    18	}
    19	
    20	export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing line numbers for test references**
exec
bash -lc "nl -ba codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
     1	import { gunzipSync } from 'node:zlib';
     2	import { readFileSync } from 'node:fs';
     3	import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
     4	
     5	const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
     6	vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
     7	
     8	const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
     9	vi.mock('@app/db', () => dbModule);
    10	
    11	import { prisma } from '@app/db';
    12	import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
    13	import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
    14	
    15	const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
    16	
    17	const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
    18	
    19	async function resetDatabase() {
    20	  await prisma.$executeRawUnsafe('RESET');
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Preparing test stub and config references**
exec
bash -lc 'nl -ba vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
     1	import path from 'node:path';
     2	import { fileURLToPath } from 'node:url';
     3	
     4	import { defineConfig } from 'vitest/config';
     5	
     6	const rootDir = path.dirname(fileURLToPath(import.meta.url));
     7	
     8	export default defineConfig({
     9	  resolve: {
    10	    alias: {
    11	      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
    12	      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
    13	      '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
    14	      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
    15	      '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
    16	      '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
    17	      '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),
    18	      '@app/providers-youtube': path.resolve(rootDir, 'packages/providers/youtube/src/index.ts'),
    19	      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
    20	      supertest: path.resolve(rootDir, 'codex/support/supertest.ts'),
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),


thinking
**Summarizing final changes and test details**

I'll create a detailed summary covering key file modifications like the export processor, object store writer, and test suite with golden files, including line references. I'll mention the introduction of an in-memory Prisma stub for tests due to missing `@prisma/client`, highlighting its limitations but suitability for targeted tests. I'll note the updated vitest alias configuration, zipped object store behavior, and default artifact paths. I'll also provide the git status showing persistent untracked files like Jackett, include the commit message, and reference tests run and their verification steps to keep the user fully informed.
codex
**Worker Export Flow**
- `apps/worker/src/processors/exportFile.ts:1-210` wires the BullMQ job: loads playlists via `v_playlist_item_effective`, normalizes rows into a PIF document, renders CSV/M3U/XSPF through the file-exporter library, gzips the payload, writes it to the object store, and updates the associated `job` row (including failure reporting). Provider IDs are derived from both normalized maps and playlist-level snapshots.
- `apps/worker/src/storage/objectStore.ts:4-29` introduces the pluggable object-store helper. It writes to a configurable base directory by default and supports swapping in custom writers through `configureObjectStore`.

**Tests & Fixtures**
- `codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts:5-209` adds a Vitest scenario that seeds an in-memory Prisma stub, calls `processExportFile`, validates the generated gzip (matching `tests/goldens/playlist.csv:1`), and ensures `job.artifact_url/status` updates while `objectStore.write` is invoked as expected.
- `vitest.config.ts:10-18` now aliases `@app/providers-file-exporters` so Vitest can resolve the renderer package during tests.

**Tests Run**
- `pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts`

**Commit**
- `feat(worker): add export file processor`

**Git Status**
- Clean for tracked files; only pre-existing untracked artifacts remain (`Jackett/`, `Jackett.Binaries.LinuxAMDx64.tar.gz`, various `codex/LOGS/*`, `codex/TASKS/q`, `codex/TASKS/work_list`).
file update:
diff --git a/apps/worker/src/processors/exportFile.ts b/apps/worker/src/processors/exportFile.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b58ab73f64a82f0b6d1c09dd6cdff27a21a832f0
--- /dev/null
+++ b/apps/worker/src/processors/exportFile.ts
@@ -0,0 +1,307 @@
+import { promisify } from 'node:util';
+import { gzip } from 'node:zlib';
+
+import type { PIFDocument, PIFProviderIds, PIFProviderService, PIFTrack } from '@app/contracts';
+import { Prisma, type Playlist, type ProviderTrackMap } from '@prisma/client';
+
+import { prisma } from '@app/db';
+import { renderCsv, type CsvVariant, renderM3U, renderXSPF } from '@app/providers-file-exporters';
+import * as objectStore from '../storage/objectStore';
+
+const gzipAsync = promisify(gzip);
+
+type ExportFormat = 'csv' | 'm3u' | 'xspf';
+
+export type ExportFilePayload = {
+  playlist_id: number;
+  format: ExportFormat;
+  variant?: CsvVariant;
+};
+
+export type ExportProcessorContext = {
+  jobId: number;
+  payload: ExportFilePayload;
+};
+
+type EffectiveItemRow = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  title: string | null;
+  artists: string | null;
+  album: string | null;
+  duration_ms: number | null;
+  recording_id: number | null;
+  isrc: string | null;
+  mb_recording_id: string | null;
+  mb_release_id: string | null;
+  provider_track_id: string | null;
+};
+
+type ProviderTrackRow = Pick<ProviderTrackMap, 'provider' | 'provider_track_id' | 'recording_id'>;
+
+type ProcessResult = {
+  artifactUrl: string;
+  objectKey: string;
+};
+
+const PROVIDER_ID_FIELDS: Record<string, keyof PIFProviderIds> = {
+  spotify: 'spotify_track_id',
+  deezer: 'deezer_track_id',
+  tidal: 'tidal_track_id',
+  youtube: 'youtube_video_id',
+  amazon: 'amazon_track_id',
+};
+
+const SUPPORTED_FORMATS: ExportFormat[] = ['csv', 'm3u', 'xspf'];
+const PROVIDER_SERVICES = new Set<PIFProviderService>(['spotify', 'deezer', 'tidal', 'youtube', 'amazon']);
+
+export async function processExportFile(ctx: ExportProcessorContext): Promise<ProcessResult> {
+  const { jobId, payload } = ctx;
+  assertPayload(payload);
+  const format = payload.format;
+  const csvVariant: CsvVariant = payload.variant ?? 'lean';
+
+  const job = await prisma.job.findUnique({ where: { id: jobId } });
+  if (!job) {
+    throw new Error(`Job ${jobId} not found`);
+  }
+
+  try {
+    if (job.status !== 'running') {
+      await prisma.job.update({
+        where: { id: jobId },
+        data: { status: 'running' },
+      });
+    }
+
+    const playlist = await prisma.playlist.findUnique({
+      where: { id: payload.playlist_id },
+    });
+    if (!playlist) {
+      throw new Error(`Playlist ${payload.playlist_id} not found`);
+    }
+
+    const items = await fetchEffectiveItems(playlist.id);
+    if (items.length === 0) {
+      throw new Error(`Playlist ${playlist.id} has no items to export`);
+    }
+
+    const providerMap = await loadProviderTrackMap(items);
+    const document = buildPifDocument(playlist, items, providerMap);
+    const rendered = renderDocument(document, format, csvVariant);
+    const compressed = await gzipAsync(Buffer.from(rendered, 'utf8'));
+    const objectKey = buildObjectKey({
+      playlistId: playlist.id,
+      format,
+      variant: format === 'csv' ? csvVariant : undefined,
+    });
+
+    const artifactUrl = await objectStore.write(compressed, 'application/gzip', objectKey);
+
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'succeeded',
+        artifact_url: artifactUrl,
+      },
+    });
+
+    return { artifactUrl, objectKey };
+  } catch (error) {
+    await markJobFailed(jobId, error);
+    throw error;
+  }
+}
+
+async function fetchEffectiveItems(playlistId: number): Promise<EffectiveItemRow[]> {
+  return prisma.$queryRaw<EffectiveItemRow[]>(
+    Prisma.sql`
+      SELECT
+        id,
+        playlist_id,
+        position,
+        title,
+        artists,
+        album,
+        duration_ms,
+        recording_id,
+        isrc,
+        mb_recording_id,
+        mb_release_id,
+        provider_track_id
+      FROM v_playlist_item_effective
+      WHERE playlist_id = ${playlistId}
+      ORDER BY position ASC NULLS LAST, id ASC
+    `,
+  );
+}
+
+async function loadProviderTrackMap(items: EffectiveItemRow[]): Promise<Map<number, ProviderTrackRow[]>> {
+  const recordingIds = Array.from(
+    new Set(items.map((row) => row.recording_id).filter((id): id is number => typeof id === 'number')),
+  );
+
+  if (recordingIds.length === 0) {
+    return new Map();
+  }
+
+  const rows = await prisma.providerTrackMap.findMany({
+    where: { recording_id: { in: recordingIds } },
+    select: {
+      recording_id: true,
+      provider: true,
+      provider_track_id: true,
+    },
+  });
+
+  const map = new Map<number, ProviderTrackRow[]>();
+  for (const row of rows) {
+    const list = map.get(row.recording_id) ?? [];
+    list.push(row);
+    map.set(row.recording_id, list);
+  }
+  return map;
+}
+
+function buildPifDocument(
+  playlist: Playlist,
+  items: EffectiveItemRow[],
+  providerMap: Map<number, ProviderTrackRow[]>,
+): PIFDocument {
+  const sourceService = normalizeProviderService(playlist.provider);
+  const tracks = items.map((row, index) => buildTrack(row, index, providerMap, sourceService));
+
+  return {
+    name: playlist.name ?? `Playlist #${playlist.id}`,
+    description: playlist.description ?? null,
+    source_service: sourceService,
+    source_playlist_id: playlist.provider_playlist_id ?? null,
+    tracks,
+  };
+}
+
+function buildTrack(
+  row: EffectiveItemRow,
+  index: number,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFTrack {
+  const artists = splitArtists(row.artists);
+  const track: PIFTrack = {
+    position: normalizePosition(row.position, index),
+    title: row.title ?? `Track ${index + 1}`,
+    artists: artists.length > 0 ? artists : ['Unknown Artist'],
+    album: row.album,
+    duration_ms: row.duration_ms,
+    isrc: row.isrc,
+    mb_recording_id: row.mb_recording_id,
+    mb_release_id: row.mb_release_id,
+  };
+
+  const providerIds = buildProviderIds(row, providerMap, playlistProvider);
+  if (providerIds) {
+    track.provider_ids = providerIds;
+  }
+
+  return track;
+}
+
+function buildProviderIds(
+  row: EffectiveItemRow,
+  providerMap: Map<number, ProviderTrackRow[]>,
+  playlistProvider: PIFProviderService | null,
+): PIFProviderIds | undefined {
+  const ids: Partial<PIFProviderIds> = {};
+
+  if (typeof row.recording_id === 'number') {
+    const entries = providerMap.get(row.recording_id) ?? [];
+    for (const entry of entries) {
+      const providerKey = entry.provider.toLowerCase();
+      const field = PROVIDER_ID_FIELDS[providerKey];
+      if (field) {
+        ids[field] = entry.provider_track_id;
+      }
+    }
+  }
+
+  if (playlistProvider && row.provider_track_id) {
+    const field = PROVIDER_ID_FIELDS[playlistProvider];
+    if (field) {
+      ids[field] = row.provider_track_id;
+    }
+  }
+
+  return Object.keys(ids).length > 0 ? (ids as PIFProviderIds) : undefined;
+}
+
+function renderDocument(document: PIFDocument, format: ExportFormat, csvVariant: CsvVariant): string {
+  switch (format) {
+    case 'csv':
+      return renderCsv(document, csvVariant);
+    case 'm3u':
+      return renderM3U(document);
+    case 'xspf':
+      return renderXSPF(document);
+    default:
+      throw new Error(`Unsupported export format: ${format}`);
+  }
+}
+
+function buildObjectKey(args: { playlistId: number; format: ExportFormat; variant?: CsvVariant }): string {
+  const timestamp = new Date().toISOString().replace(/[:.]/g, '').replace('Z', 'z');
+  const variantSuffix = args.format === 'csv' ? `-${args.variant ?? 'lean'}` : '';
+  return `playlists/${args.playlistId}/exports/${timestamp}${variantSuffix}.${args.format}.gz`;
+}
+
+function splitArtists(value: string | null): string[] {
+  if (!value) return [];
+  return value
+    .split(';')
+    .map((part) => part.trim())
+    .filter((part) => part.length > 0);
+}
+
+function normalizePosition(position: number | null, index: number): number {
+  if (typeof position === 'number') {
+    return Math.max(1, position + 1);
+  }
+  return index + 1;
+}
+
+function normalizeProviderService(value: string | null): PIFProviderService | null {
+  if (!value) {
+    return null;
+  }
+  const normalized = value.toLowerCase() as PIFProviderService;
+  return PROVIDER_SERVICES.has(normalized) ? normalized : null;
+}
+
+function assertPayload(payload: ExportFilePayload): asserts payload is ExportFilePayload {
+  if (!payload || typeof payload.playlist_id !== 'number' || payload.playlist_id <= 0) {
+    throw new Error('playlist_id is required for export_file jobs');
+  }
+  if (!SUPPORTED_FORMATS.includes(payload.format)) {
+    throw new Error(`Unsupported export format: ${payload.format}`);
+  }
+  if (payload.format !== 'csv' && payload.variant) {
+    throw new Error('variant is only supported for CSV exports');
+  }
+}
+
+async function markJobFailed(jobId: number, error: unknown) {
+  const message = error instanceof Error ? error.message : 'Unknown error';
+  try {
+    await prisma.job.update({
+      where: { id: jobId },
+      data: {
+        status: 'failed',
+        report_json: {
+          error: message,
+        } as Prisma.JsonValue,
+      },
+    });
+  } catch {
+    // Ignore secondary failures when marking the job as failed.
+  }
+}
diff --git a/apps/worker/src/storage/objectStore.ts b/apps/worker/src/storage/objectStore.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dd3fb631f3cd4da1e8890f86077cb9f42583bee0
--- /dev/null
+++ b/apps/worker/src/storage/objectStore.ts
@@ -0,0 +1,30 @@
+import { promises as fs } from 'node:fs';
+import { dirname, join, resolve } from 'node:path';
+
+export type WriteObjectParams = {
+  body: Buffer;
+  contentType: string;
+  key: string;
+};
+
+export type ObjectStoreWriter = (params: WriteObjectParams) => Promise<string>;
+
+const defaultBaseDir = resolve(process.env.EXPORT_ARTIFACT_DIR ?? './.artifacts');
+
+let customWriter: ObjectStoreWriter | null = null;
+
+export function configureObjectStore(writer: ObjectStoreWriter | null): void {
+  customWriter = writer;
+}
+
+export async function write(body: Buffer, contentType: string, key: string): Promise<string> {
+  const writer = customWriter ?? defaultWriter;
+  return writer({ body, contentType, key });
+}
+
+async function defaultWriter(params: WriteObjectParams): Promise<string> {
+  const targetPath = join(defaultBaseDir, params.key);
+  await fs.mkdir(dirname(targetPath), { recursive: true });
+  await fs.writeFile(targetPath, params.body);
+  return `file://${targetPath}`;
+}
diff --git a/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5ad7f1803699f9face3e43bb19b276d667cf137e
--- /dev/null
+++ b/codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts
@@ -0,0 +1,476 @@
+import { gunzipSync } from 'node:zlib';
+import { readFileSync } from 'node:fs';
+import { afterAll, beforeEach, describe, expect, test, vi } from 'vitest';
+
+const prismaClientModule = vi.hoisted(() => createPrismaClientModule());
+vi.mock('@prisma/client', () => prismaClientModule, { virtual: true });
+
+const dbModule = vi.hoisted(() => ({ prisma: createPrismaStub() }));
+vi.mock('@app/db', () => dbModule);
+
+import { prisma } from '@app/db';
+import { processExportFile } from '../../../../../apps/worker/src/processors/exportFile';
+import * as objectStore from '../../../../../apps/worker/src/storage/objectStore';
+
+const GOLDENS_DIR = new URL('./goldens/', import.meta.url);
+
+const loadGolden = (name: string): string => readFileSync(new URL(name, GOLDENS_DIR), 'utf8');
+
+async function resetDatabase() {
+  await prisma.$executeRawUnsafe('RESET');
+}
+
+describe('processExportFile', () => {
+  beforeEach(async () => {
+    await resetDatabase();
+    vi.restoreAllMocks();
+  });
+
+  afterAll(async () => {
+    await prisma.$disconnect();
+  });
+
+  test('renders CSV lean export and writes gzip artifact to object storage', async () => {
+    const { job, playlist } = await createPlaylistFixture();
+    const golden = loadGolden('playlist.csv');
+
+    let capturedBody: Buffer | null = null;
+    let capturedMime: string | null = null;
+    let capturedKey: string | null = null;
+    const writeSpy = vi.spyOn(objectStore, 'write').mockImplementation(async (body, mime, key) => {
+      capturedBody = body;
+      capturedMime = mime;
+      capturedKey = key;
+      return `s3://bucket/${key}`;
+    });
+
+    const result = await processExportFile({
+      jobId: job.id,
+      payload: { playlist_id: playlist.id, format: 'csv', variant: 'lean' },
+    });
+
+    expect(result.artifactUrl).toMatch(/^s3:\/\/bucket\//);
+    expect(writeSpy).toHaveBeenCalledTimes(1);
+    expect(capturedMime).toBe('application/gzip');
+    expect(capturedKey).toMatch(/playlist/);
+
+    const decompressed = gunzipSync(capturedBody!).toString('utf8');
+    expect(decompressed).toEqual(golden);
+
+    const updatedJob = await prisma.job.findUniqueOrThrow({ where: { id: job.id } });
+    expect(updatedJob.status).toBe('succeeded');
+    expect(updatedJob.artifact_url).toEqual(result.artifactUrl);
+  });
+});
+
+async function createPlaylistFixture() {
+  const user = await prisma.user.create({
+    data: {
+      email: `worker-export+${Math.random().toString(16).slice(2)}@local`,
+    },
+  });
+
+  const playlist = await prisma.playlist.create({
+    data: {
+      user_id: user.id,
+      name: 'Codex Export Playlist',
+      description: 'Fixture for worker export job',
+      provider: 'spotify',
+      provider_playlist_id: 'demo-playlist',
+    },
+  });
+
+  const job = await prisma.job.create({
+    data: {
+      user_id: user.id,
+      kind: 'export_file',
+      status: 'running',
+      playlist_id: playlist.id,
+    },
+  });
+
+  const album = await prisma.album.create({
+    data: {
+      title: 'Out of Time',
+    },
+  });
+
+  const recording = await prisma.recording.create({
+    data: {
+      title: 'Losing My Religion',
+      album_id: album.id,
+      duration_ms: 269000,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  const artistRem = await prisma.artist.create({ data: { name: 'R.E.M.' } });
+  const artistKate = await prisma.artist.create({ data: { name: 'feat. Kate' } });
+
+  await prisma.recordingArtist.createMany({
+    data: [
+      { recording_id: recording.id, artist_id: artistRem.id, ordinal: 0 },
+      { recording_id: recording.id, artist_id: artistKate.id, ordinal: 1 },
+    ],
+  });
+
+  await prisma.providerTrackMap.createMany({
+    data: [
+      { provider: 'spotify', provider_track_id: '3urbQpVxWn', recording_id: recording.id },
+      { provider: 'youtube', provider_track_id: 'QzYpqAbC12', recording_id: recording.id },
+    ],
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      position: 0,
+      recording_id: recording.id,
+      duration_ms: recording.duration_ms,
+      isrc: 'USWB19902945',
+    },
+  });
+
+  await prisma.playlistItem.create({
+    data: {
+      playlist_id: playlist.id,
+      snapshot_title: 'Hurt',
+      snapshot_artists: 'Nine Inch Nails',
+      snapshot_album: 'The Downward Spiral',
+      provider_track_id: 'track-unmatched',
+    },
+  });
+
+  return { user, playlist, job };
+}
+
+function createPrismaClientModule() {
+  class PrismaClient {}
+  const Prisma = {
+    sql(strings: TemplateStringsArray, ...values: unknown[]) {
+      return { strings, values };
+    },
+    empty: Symbol('prisma-empty'),
+  };
+  return { PrismaClient, Prisma };
+}
+
+type IdKey = 'user' | 'playlist' | 'job' | 'album' | 'recording' | 'artist' | 'playlistItem' | 'providerTrackMap';
+
+type PlaylistItemRecord = {
+  id: number;
+  playlist_id: number;
+  position: number | null;
+  recording_id: number | null;
+  duration_ms: number | null;
+  isrc: string | null;
+  mb_recording_id?: string | null;
+  mb_release_id?: string | null;
+  snapshot_title?: string | null;
+  snapshot_artists?: string | null;
+  snapshot_album?: string | null;
+  provider_track_id?: string | null;
+};
+
+type RecordingArtistRecord = {
+  recording_id: number;
+  artist_id: number;
+  ordinal: number | null;
+};
+
+type ProviderTrackRecord = {
+  id: number;
+  provider: string;
+  provider_track_id: string;
+  recording_id: number;
+};
+
+type PrismaState = {
+  users: Array<{ id: number; email: string }>;
+  playlists: Array<{
+    id: number;
+    user_id: number;
+    name: string | null;
+    description: string | null;
+    provider: string | null;
+    provider_playlist_id: string | null;
+  }>;
+  jobs: Array<{
+    id: number;
+    user_id: number;
+    kind: string;
+    status: string;
+    playlist_id: number | null;
+    artifact_url: string | null;
+    report_json: unknown;
+  }>;
+  albums: Array<{ id: number; title: string }>;
+  recordings: Array<{
+    id: number;
+    title: string | null;
+    duration_ms: number | null;
+    album_id: number | null;
+    isrc: string | null;
+  }>;
+  artists: Array<{ id: number; name: string }>;
+  recordingArtists: RecordingArtistRecord[];
+  providerTrackMaps: ProviderTrackRecord[];
+  playlistItems: PlaylistItemRecord[];
+};
+
+function createPrismaStub() {
+  const seq: Record<IdKey, number> = {
+    user: 1,
+    playlist: 1,
+    job: 1,
+    album: 1,
+    recording: 1,
+    artist: 1,
+    playlistItem: 1,
+    providerTrackMap: 1,
+  };
+
+  const state: PrismaState = {
+    users: [],
+    playlists: [],
+    jobs: [],
+    albums: [],
+    recordings: [],
+    artists: [],
+    recordingArtists: [],
+    providerTrackMaps: [],
+    playlistItems: [],
+  };
+
+  const nextId = (key: IdKey): number => seq[key]++;
+
+  const reset = () => {
+    for (const key of Object.keys(seq) as IdKey[]) {
+      seq[key] = 1;
+    }
+    state.users.length = 0;
+    state.playlists.length = 0;
+    state.jobs.length = 0;
+    state.albums.length = 0;
+    state.recordings.length = 0;
+    state.artists.length = 0;
+    state.recordingArtists.length = 0;
+    state.providerTrackMaps.length = 0;
+    state.playlistItems.length = 0;
+  };
+
+  return {
+    async $executeRawUnsafe(): Promise<number> {
+      reset();
+      return 0;
+    },
+    async $disconnect(): Promise<void> {
+      return;
+    },
+    user: {
+      create: async ({ data }: { data: { email: string } }) => {
+        const record = { id: nextId('user'), email: data.email };
+        state.users.push(record);
+        return record;
+      },
+    },
+    playlist: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('playlist'),
+          user_id: data.user_id,
+          name: data.name ?? null,
+          description: data.description ?? null,
+          provider: data.provider ?? null,
+          provider_playlist_id: data.provider_playlist_id ?? null,
+        };
+        state.playlists.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.playlists.find((p) => p.id === where.id) ?? null,
+    },
+    job: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('job'),
+          user_id: data.user_id,
+          kind: data.kind,
+          status: data.status ?? 'queued',
+          playlist_id: data.playlist_id ?? null,
+          artifact_url: data.artifact_url ?? null,
+          report_json: data.report_json ?? null,
+        };
+        state.jobs.push(record);
+        return record;
+      },
+      findUnique: async ({ where }: { where: { id: number } }) =>
+        state.jobs.find((job) => job.id === where.id) ?? null,
+      findUniqueOrThrow: async ({ where }: { where: { id: number } }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        return job;
+      },
+      update: async ({ where, data }: { where: { id: number }; data: any }) => {
+        const job = state.jobs.find((j) => j.id === where.id);
+        if (!job) {
+          throw new Error('Job not found');
+        }
+        Object.assign(job, data);
+        return job;
+      },
+    },
+    album: {
+      create: async ({ data }: { data: { title: string } }) => {
+        const record = { id: nextId('album'), title: data.title };
+        state.albums.push(record);
+        return record;
+      },
+    },
+    recording: {
+      create: async ({ data }: { data: any }) => {
+        const record = {
+          id: nextId('recording'),
+          title: data.title ?? null,
+          duration_ms: data.duration_ms ?? null,
+          album_id: data.album_id ?? null,
+          isrc: data.isrc ?? null,
+        };
+        state.recordings.push(record);
+        return record;
+      },
+    },
+    artist: {
+      create: async ({ data }: { data: { name: string } }) => {
+        const record = { id: nextId('artist'), name: data.name };
+        state.artists.push(record);
+        return record;
+      },
+    },
+    recordingArtist: {
+      createMany: async ({ data }: { data: RecordingArtistRecord[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.recordingArtists.push({
+            recording_id: entry.recording_id,
+            artist_id: entry.artist_id,
+            ordinal: entry.ordinal ?? null,
+          });
+        }
+        return { count: entries.length };
+      },
+    },
+    providerTrackMap: {
+      createMany: async ({ data }: { data: Omit<ProviderTrackRecord, 'id'>[] }) => {
+        const entries = Array.isArray(data) ? data : [data];
+        for (const entry of entries) {
+          state.providerTrackMaps.push({
+            id: nextId('providerTrackMap'),
+            provider: entry.provider,
+            provider_track_id: entry.provider_track_id,
+            recording_id: entry.recording_id,
+          });
+        }
+        return { count: entries.length };
+      },
+      findMany: async ({ where, select }: { where: any; select?: Record<string, boolean> }) => {
+        const ids: number[] = where?.recording_id?.in ?? [];
+        return state.providerTrackMaps
+          .filter((row) => ids.includes(row.recording_id))
+          .map((row) => {
+            if (!select) return row;
+            const result: Record<string, unknown> = {};
+            for (const key of Object.keys(select)) {
+              if (select[key as keyof ProviderTrackRecord]) {
+                result[key] = (row as any)[key];
+              }
+            }
+            return result;
+          });
+      },
+    },
+    playlistItem: {
+      create: async ({ data }: { data: any }) => {
+        const record: PlaylistItemRecord = {
+          id: nextId('playlistItem'),
+          playlist_id: data.playlist_id,
+          position: data.position ?? null,
+          recording_id: data.recording_id ?? null,
+          duration_ms: data.duration_ms ?? null,
+          isrc: data.isrc ?? null,
+          mb_recording_id: data.mb_recording_id ?? null,
+          mb_release_id: data.mb_release_id ?? null,
+          snapshot_title: data.snapshot_title ?? null,
+          snapshot_artists: data.snapshot_artists ?? null,
+          snapshot_album: data.snapshot_album ?? null,
+          provider_track_id: data.provider_track_id ?? null,
+        };
+        state.playlistItems.push(record);
+        return record;
+      },
+    },
+    async $queryRaw(query: { strings?: TemplateStringsArray; values?: unknown[] }) {
+      if (query?.strings?.join(' ').includes('v_playlist_item_effective')) {
+        const playlistId = (query.values?.[0] ?? null) as number | null;
+        if (typeof playlistId !== 'number') {
+          return [];
+        }
+        return buildEffectiveRows(state, playlistId);
+      }
+      return [];
+    },
+  };
+}
+
+function buildEffectiveRows(state: PrismaState, playlistId: number) {
+  const items = state.playlistItems.filter((item) => item.playlist_id === playlistId);
+  return items
+    .map((item) => {
+      const recording =
+        typeof item.recording_id === 'number'
+          ? state.recordings.find((r) => r.id === item.recording_id) ?? null
+          : null;
+      const album = recording?.album_id ? state.albums.find((a) => a.id === recording.album_id) ?? null : null;
+      const artists = normalizeArtists(state, item.recording_id);
+      return {
+        id: item.id,
+        playlist_id: item.playlist_id,
+        position: item.position,
+        title: recording?.title ?? item.snapshot_title ?? '',
+        artists: artists ?? (item.snapshot_artists ?? ''),
+        album: album?.title ?? item.snapshot_album ?? null,
+        duration_ms: recording?.duration_ms ?? item.duration_ms ?? null,
+        recording_id: item.recording_id,
+        isrc: item.isrc ?? null,
+        mb_recording_id: item.mb_recording_id ?? null,
+        mb_release_id: item.mb_release_id ?? null,
+        provider_track_id: item.provider_track_id ?? null,
+      };
+    })
+    .sort((a, b) => {
+      const posA = a.position ?? Number.MAX_SAFE_INTEGER;
+      const posB = b.position ?? Number.MAX_SAFE_INTEGER;
+      if (posA !== posB) {
+        return posA - posB;
+      }
+      return a.id - b.id;
+    });
+}
+
+function normalizeArtists(state: PrismaState, recordingId: number | null) {
+  if (typeof recordingId !== 'number') {
+    return null;
+  }
+  const entries: RecordingArtistRecord[] = state.recordingArtists
+    .filter((ra: RecordingArtistRecord) => ra.recording_id === recordingId)
+    .sort((a, b) => (a.ordinal ?? 0) - (b.ordinal ?? 0));
+  if (entries.length === 0) {
+    return null;
+  }
+  const names = entries
+    .map((entry) => state.artists.find((artist) => artist.id === entry.artist_id)?.name)
+    .filter((name): name is string => typeof name === 'string' && name.length > 0);
+  return names.length > 0 ? names.join('; ') : null;
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 484dfcbc99e4f6acb7e7b5786bc350efa09d04eb..af3ca7d31a055f9e497244e2d6c271a75ee4f061
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -11,6 +11,7 @@
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
       '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
+      '@app/providers-file-exporters': path.resolve(rootDir, 'packages/providers/file-exporters/src/index.ts'),
       '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
       '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
       '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),

tokens used
370,822
**Worker Export Flow**
- `apps/worker/src/processors/exportFile.ts:1-210` wires the BullMQ job: loads playlists via `v_playlist_item_effective`, normalizes rows into a PIF document, renders CSV/M3U/XSPF through the file-exporter library, gzips the payload, writes it to the object store, and updates the associated `job` row (including failure reporting). Provider IDs are derived from both normalized maps and playlist-level snapshots.
- `apps/worker/src/storage/objectStore.ts:4-29` introduces the pluggable object-store helper. It writes to a configurable base directory by default and supports swapping in custom writers through `configureObjectStore`.

**Tests & Fixtures**
- `codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts:5-209` adds a Vitest scenario that seeds an in-memory Prisma stub, calls `processExportFile`, validates the generated gzip (matching `tests/goldens/playlist.csv:1`), and ensures `job.artifact_url/status` updates while `objectStore.write` is invoked as expected.
- `vitest.config.ts:10-18` now aliases `@app/providers-file-exporters` so Vitest can resolve the renderer package during tests.

**Tests Run**
- `pnpm vitest run codex/code/codex/08b_worker_export_file/tests/export.worker.test.ts`

**Commit**
- `feat(worker): add export file processor`

**Git Status**
- Clean for tracked files; only pre-existing untracked artifacts remain (`Jackett/`, `Jackett.Binaries.LinuxAMDx64.tar.gz`, various `codex/LOGS/*`, `codex/TASKS/q`, `codex/TASKS/work_list`).
