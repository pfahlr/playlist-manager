OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5822-039e-7751-9ed7-2e6ba1dd8a74
--------
user
Implement the functionality described in codex/TASKS/06b_spotify_impl.yaml, then verify with any available tests.

thinking
**Preparing to read task file**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 149ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas

thinking
**Ignoring missing broot error and viewing task file**
exec
bash -lc 'cat codex/TASKS/06b_spotify_impl.yaml' in /var/home/rick/Development/playlist-manager succeeded in 101ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 06b_spotify_impl
title: Spotify importer/exporter (mocked HTTP) to/from PIF
branch: codex/06b_spotify_impl
overview: >
  Implement Spotify Importer/Exporter with network mocked via nock. Focus on: read playlist â†’ PIF, write PIF â†’ created playlist.
acceptance:
  - Tests in codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts pass:
    * importer maps items (with ISRC when available) into PIF.
    * exporter creates a playlist and adds tracks in batches.
artifacts_to_touch:
  - packages/providers/spotify/src/index.ts
  - packages/providers/spotify/src/spotify.client.ts
  - fixtures under codex/code/codex/06b_spotify_impl/tests/fixtures/*
constraints:
  - No real tokens; use nock fixtures resembling Spotify Web API responses.
steps:
  - Build tiny client wrapper; implement read/write using endpoints for playlists & tracks.
  - Map external_ids.isrc â†’ track.isrc; fallback to title/artist/duration.

thinking
**Planning test-driven development approach**
exec
bash -lc 'ls packages/providers/spotify/src' in /var/home/rick/Development/playlist-manager succeeded in 150ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
index.ts

thinking
**Checking index.ts content**
exec
bash -lc 'cat packages/providers/spotify/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class Spotify implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'spotify';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');

thinking
**Preparing implementation and locating tests**
exec
bash -lc 'ls codex/code/codex/06b_spotify_impl/tests' in /var/home/rick/Development/playlist-manager exited 2 in 87ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
ls: cannot access 'codex/code/codex/06b_spotify_impl/tests': No such file or directory

thinking
**Checking codex/code directory**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 127ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Checking nested codex directories**
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces

thinking
**Investigating test folder structure**
exec
bash -lc 'ls codex/code/codex/06a_provider_interfaces/tests' in /var/home/rick/Development/playlist-manager succeeded in 52ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
types.compile.test.ts

thinking
**Searching for 06b tests**
exec
bash -lc 'rg "06b" -n' in /var/home/rick/Development/playlist-manager succeeded in 8.59s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:13:Implement the functionality described in codex/TASKS/06b_spotify_impl.yaml, then verify with any available tests.
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:43:bash -lc 'cat codex/TASKS/06b_spotify_impl.yaml' in /var/home/rick/Development/playlist-manager succeeded in 101ms:
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:46:id: 06b_spotify_impl
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:48:branch: codex/06b_spotify_impl
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:52:  - Tests in codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts pass:
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:58:  - fixtures under codex/code/codex/06b_spotify_impl/tests/fixtures/*
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:101:bash -lc 'ls codex/code/codex/06b_spotify_impl/tests' in /var/home/rick/Development/playlist-manager exited 2 in 87ms:
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:104:ls: cannot access 'codex/code/codex/06b_spotify_impl/tests': No such file or directory
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:137:**Searching for 06b tests**
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:139:bash -lc 'rg "06b" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_02c_prisma_seeds_1762378977.log:38:06b_spotify_impl.yaml
codex/LOGS/codex_run_2025-11-06_02-37-26.log:7:Tasks: 06a_provider_interfaces 06b_spotify_impl 06c_deezer_impl 06d_tidal_impl 06e_youtube_impl 06f_provider_factory_tests 06g_provider_cache_backoff 06h_provider_fixture_harness 06z_track_matching_heuristics
codex/LOGS/codex_run_2025-11-06_02-37-26.log:13:ðŸŸ¡ Executing task: 06b_spotify_impl
codex/TASKS/work_list:2:06b_spotify_impl.yaml
codex/TASKS/00_repo_sanity_review.yaml:61:      * Next recommended tasks (e.g., 06a provider interfaces, 06b spotify impl TDD)
codex/TASKS/CODEX_TODO.md:33:- â˜ 06b_spotify_impl.yaml
codex/TASKS/CODEX_TODO.md:87:3. **Providers**: 06a â†’ 06g â†’ 06h â†’ 06z â†’ 06f â†’ 06b  
codex/TASKS/06b_spotify_impl.yaml:1:id: 06b_spotify_impl

thinking
**Planning test creation and TDD approach**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",

thinking
**Checking test setup and configuration**
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 78ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { defineConfig } from 'vitest/config';

const rootDir = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  resolve: {
    alias: {
      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
    },
  },
  test: {
    include: [
      'packages/**/test/**/*.test.ts',
      'packages/**/tests/**/*.test.ts',

thinking
**Preparing to add tests and inspect dependencies**
exec
bash -lc 'ls packages/contracts/src' in /var/home/rick/Development/playlist-manager succeeded in 66ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
api.types.ts
constants.ts
index.ts
pif.ts
providers.ts

thinking
**Checking key TypeScript files**
exec
bash -lc 'cat packages/contracts/src/providers.ts' in /var/home/rick/Development/playlist-manager succeeded in 83ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// packages/contracts/src/providers.ts

/** Canonical provider IDs used across the app & OpenAPI spec */
export type ProviderName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

/** Minimal PIF v1 types (keep in sync with /schemas/pif-v1.schema.json) */
export interface PIF {
  name: string;
  description?: string | null;
  source_service?: ProviderName | 'amazon' | null;
  source_playlist_id?: string | null;
  tracks: PIFTrack[];
}

export interface PIFTrack {
  position: number;                // 1-based
  title: string;
  artists: string[];               // primary first; features after

thinking
**Checking interop package for utilities**
exec
bash -lc 'ls packages/interop/src' in /var/home/rick/Development/playlist-manager succeeded in 110ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
importers

thinking
**Checking importers directory**
exec
bash -lc 'ls packages/interop/src/importers' in /var/home/rick/Development/playlist-manager succeeded in 69ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
common.ts
csv.ts
m3u.ts
pls.ts
wpl.ts
xspf.ts

thinking
**Checking common.ts for helpers**
exec
bash -lc 'cat packages/interop/src/importers/common.ts' in /var/home/rick/Development/playlist-manager succeeded in 67ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { URL } from 'node:url';

import type { PIFDocument, PIFProviderIds, PIFTrack } from '@app/contracts';

export const DEFAULT_PLAYLIST_NAME = 'Imported playlist';

export type FileImportErrorCode = 'invalid_playlist_file';

export class FileImportError extends Error {
  readonly code: FileImportErrorCode;
  readonly details?: unknown;

  constructor(message: string, details?: unknown) {
    super(message);
    this.name = 'FileImportError';
    this.code = 'invalid_playlist_file';
    this.details = details;
  }

thinking
**Checking type definitions in pif.ts**
exec
bash -lc 'cat packages/contracts/src/pif.ts' in /var/home/rick/Development/playlist-manager succeeded in 62ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import Ajv, { type ErrorObject, type ValidateFunction } from 'ajv';
import { createRequire } from 'node:module';

export type PIFProviderService = 'spotify' | 'deezer' | 'tidal' | 'youtube' | 'amazon';

export interface PIFProviderIds {
  spotify_track_id?: string | null;
  deezer_track_id?: string | null;
  tidal_track_id?: string | null;
  youtube_video_id?: string | null;
  amazon_track_id?: string | null;
}

export interface PIFTrack {
  position: number;
  title: string;
  artists: string[];
  album?: string | null;

thinking
**Inspecting existing provider tests**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 94ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
core
deezer
file-exporters
spotify
tidal
youtube

thinking
**Exploring provider packages**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager succeeded in 61ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
http
index.ts
match
types.ts

thinking
**Checking HTTP-related code**
exec
bash -lc 'ls packages/providers/core/src/http' in /var/home/rick/Development/playlist-manager succeeded in 61ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
client.ts

thinking
**Opening environment**
exec
bash -lc 'cat packages/providers/core/src/http/client.ts' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export type HttpMethod = 'GET'|'POST'|'PUT'|'PATCH'|'DELETE';

export interface HttpClientOptions {
  baseUrl: string;
  headers?: Record<string, string>;
  getAuthHeader?: () => Promise<string | undefined>;
  retries?: number;
  retryBaseMs?: number;
}

function sleep(ms: number) { return new Promise((r) => setTimeout(r, ms)); }

export class HttpClient {
  constructor(private opts: HttpClientOptions) {}

  async request<T>(method: HttpMethod, url: string, init?: RequestInit): Promise<T> {
    const { retries = 3, retryBaseMs = 300 } = this.opts;
    let attempt = 0;

thinking
**Reviewing fetch usage and testing strategy**
exec
bash -lc "rg \"from 'nock'\" -n" in /var/home/rick/Development/playlist-manager succeeded in 51ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:379:bash -lc "rg \"from 'nock'\" -n" in /var/home/rick/Development/playlist-manager
codex/TASKS/09b_enrichment_musicbrainz.yaml:20:    import nock from 'nock';
codex/TASKS/06e_youtube_impl.yaml:21:    import nock from 'nock';
codex/TASKS/06d_tidal_impl.yaml:19:    import nock from 'nock';
codex/TASKS/06c_deezer_impl.yaml:22:    import nock from 'nock';

thinking
**Verifying nock usage and exports**
exec
bash -lc 'cat packages/contracts/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export * from './pif';
export * from './providers';

thinking
**Inspecting spotify provider structure**
exec
bash -lc 'ls packages/providers/deezer/src' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
index.ts

thinking
**Checking provider core utilities**
exec
bash -lc 'cat packages/providers/core/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export * from './types';

thinking
**Verifying type usage**
exec
bash -lc 'cat packages/providers/core/src/types.ts' in /var/home/rick/Development/playlist-manager succeeded in 50ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export type ProviderName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

export interface NormalizedTrack {
  mbid?: string | null;
  isrc?: string | null;
  title: string;
  primaryArtist: string;
  album?: string | null;
  durationMs?: number | null;
  providerId?: string; // e.g., Spotify track ID
}

export interface NormalizedPlaylist {
  id: string;           // provider playlist id
  title: string;
  description?: string | null;
  itemsCount?: number;
}

thinking
**Planning Spotify importer/exporter tests**

I'm focusing on implementing the Spotify importer/exporter that maps Spotify API responses to the PIF format. To do that, I need to understand the expected Spotify data structure and PIF specs. I'll design tests in `spotify.impl.test.ts` with fixtures mimicking Spotify playlist and track responses. The tests should verify correct mapping, handling track identifiers like ISRC, paging through results, and implementing backoff logic for rate limiting during batch adds. I'll also look into existing backoff utilities in `packages/providers/core` to see if I can reuse them. This way I can cover both correctness and robustness for the importer/exporter.
exec
bash -lc 'rg "backoff" -n packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
packages/providers/core/src/http/client.ts:34:        const backoff = retryAfter > 0 ? retryAfter * 1000 : retryBaseMs * Math.pow(2, attempt) + Math.random() * 100;
packages/providers/core/src/http/client.ts:36:        await sleep(backoff);

thinking
**Drafting multi-step implementation plan**

Iâ€™m considering using the existing HttpClientâ€™s built-in backoff for handling 429 errors but wondering if custom logic is expected per acceptance criteria. Iâ€™ll inspect the Spotify provider code to implement both importer and exporter with the new SpotifyClient and create a multi-step plan focused on test-driven developmentâ€”starting with analyzing requirements and writing tests, then implementing code, running tests, and finally preparing a commit.
Plan update
  â†’ Analyze task requirements and inspect existing Spotify provider structure
  â€¢ Create failing Vitest coverage for Spotify importer/exporter with mocked HTTP fixtures
  â€¢ Implement Spotify client and provider to satisfy tests
  â€¢ Run full test suite and finalize changes with commit

thinking
**Preparing to design tests with nock**

Iâ€™m planning to create tests for the Spotify implementation using nock, targeting expected behaviors and placing them in a new tests directory. I'll first explore the necessary interfaces and similar existing code to align on the constructor design and overall test structure before implementation.
exec
bash -lc 'ls packages/providers/file-exporters/src' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
csv.ts
index.ts
m3u.ts
shared.ts
xspf.ts

thinking
**Opening index file**
exec
bash -lc 'cat packages/providers/file-exporters/src/index.ts' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export { renderCsv, type CsvVariant } from './csv.ts';
export { renderM3U } from './m3u.ts';
export { renderXSPF } from './xspf.ts';

thinking
**Planning Spotify importer/exporter tests**

Iâ€™m outlining tests to verify Spotify importer maps items into PIF with ISRC and exporter creates playlists with batch track adds that handle 429 rate limits via backoff retries. Iâ€™ll design a SpotifyClient class wrapping HTTP calls, matching real API endpoints for playlist reading and writing, while mocking via nock. I also want tests that fake timers to confirm retry delays on 429 responses. Next, Iâ€™ll check existing code and contracts to align types and structures before coding.
exec
bash -lc 'cat codex/code/codex/06a_provider_interfaces/tests/types.compile.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { expect, test } from 'vitest';

import type { Exporter, Importer } from '../../../../../packages/contracts/src/providers.ts';
import Spotify from '../../../../../packages/providers/spotify/src/index.ts';

test('spotify implements importer/exporter contract', () => {
  const provider: Importer & Exporter = new Spotify();
  expect(provider).toBeInstanceOf(Spotify);
});

thinking
**Designing Spotify client and tests**

Iâ€™m mapping out how to build a flexible Spotify class with optional auth to keep existing tests working while supporting new functionality. Iâ€™m outlining how the client will manage playlist read/write operations, handle pagination, map Spotify data to PIF format, and implement retry logic for 429 errors. Iâ€™m also thinking through adding test fixtures and dependencies like nock for HTTP mocking. Lots to coordinate between TDD, constructor design, API interactions, and batching logic!
exec
bash -lc 'rg "nock" package.json -n' in /var/home/rick/Development/playlist-manager exited 1 in 63ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Updating plan after test prep**
Plan update
  âœ“ Analyze task requirements and inspect existing Spotify provider structure
  â†’ Create failing Vitest coverage for Spotify importer/exporter with mocked HTTP fixtures
  â€¢ Implement Spotify client and provider to satisfy tests
  â€¢ Run full test suite and finalize changes with commit

thinking
**Designing and planning Spotify tests**

Iâ€™m mapping out detailed test structures for Spotify importer and exporter, setting up fixtures for playlist data and user info, and planning to handle rate limits with fake timers. Iâ€™m figuring out directory setup, mocking HTTP calls with nock, and ensuring the tests verify paginated playlist reading and track batching with backoff on 429 responses. Letâ€™s build solid, realistic tests!
exec
bash -lc 'mkdir -p codex/code/codex/06b_spotify_impl/tests/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 91ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Preparing fixture JSON files**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
{
  "id": "test-playlist",
  "name": "Focus Flow",
  "description": "Deep work background music.",
  "tracks": {
    "limit": 1,
    "offset": 0,
    "total": 2,
    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
    "items": [
      {
        "added_at": "2024-01-01T12:00:00Z",
        "track": {
          "id": "track-001",
          "name": "Deep Dive",
          "duration_ms": 231000,
          "explicit": false,
          "external_ids": {
            "isrc": "USRC12400001"
          },
          "artists": [
            { "name": "Aurora Lane" }
          ],
          "album": {
            "name": "Ocean Patterns",
            "release_date": "2023-09-01"
          }
        }
      }
    ]
  }
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}


thinking
**Adding second page**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
{
  "limit": 1,
  "offset": 1,
  "total": 2,
  "next": null,
  "items": [
    {
      "added_at": "2024-01-01T12:03:00Z",
      "track": {
        "id": "track-002",
        "name": "Shallow Breath",
        "duration_ms": 198500,
        "explicit": true,
        "external_ids": {},
        "artists": [
          { "name": "Aurora Lane" },
          { "name": "Synthline" }
        ],
        "album": {
          "name": "Ocean Patterns",
          "release_date": "2023"
        }
      }
    }
  ]
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}


thinking
**Adding profile.json file**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
{
  "id": "user-123",
  "display_name": "Productive Listener"
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}


thinking
**Adding JSON response file**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
{
  "id": "fresh-playlist-42",
  "snapshot_id": "snapshot-001"
}
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}


thinking
**Adding tracks response fixture**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
{
  "snapshot_id": "snapshot-002"
}
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}


thinking
**Designing Spotify provider tests**

I'm planning tests for Spotify playlist reading and writing, using `nock` to mock API calls and `vitest` for testing. I'll ensure queries match expected parameters while allowing some flexibility, handle pagination, and simulate 429 retry logic with fake timers. I'll also manage fixtures and cleanup carefully to keep tests reliable and isolated.
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import nock from 'nock';
import path from 'node:path';
import { readFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import Spotify from '../../../../../packages/providers/spotify/src/index.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const loadFixture = (name: string) =>
  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));

describe('Spotify provider integration', () => {
  const baseUrl = 'https://api.spotify.com';

  beforeEach(() => {
    nock.disableNetConnect();
  });

  afterEach(() => {
    nock.cleanAll();
    nock.enableNetConnect();
    vi.useRealTimers();
  });

  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
    const playlistId = 'test-playlist';
    const playlist = loadFixture('playlist-metadata.json');
    const pageTwo = loadFixture('playlist-tracks-page-2.json');

    const playlistScope = nock(baseUrl)
      .get(`/v1/playlists/${playlistId}`)
      .query(true)
      .reply(200, playlist);

    const trackPageScope = nock(baseUrl)
      .get(`/v1/playlists/${playlistId}/tracks`)
      .query((qs) => qs.offset === '1' && qs.limit === '1')
      .reply(200, pageTwo);

    const provider = new Spotify({ auth: { token: 'test-token' } });

    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });

    expect(result).toEqual({
      name: 'Focus Flow',
      description: 'Deep work background music.',
      source_service: 'spotify',
      source_playlist_id: playlistId,
      tracks: [
        {
          position: 1,
          title: 'Deep Dive',
          artists: ['Aurora Lane'],
          album: 'Ocean Patterns',
          duration_ms: 231000,
          explicit: false,
          release_date: '2023-09-01',
          isrc: 'USRC12400001',
          mb_recording_id: null,
          mb_release_id: null,
          provider_ids: {
            spotify_track_id: 'track-001',
          },
        },
        {
          position: 2,
          title: 'Shallow Breath',
          artists: ['Aurora Lane', 'Synthline'],
          album: 'Ocean Patterns',
          duration_ms: 198500,
          explicit: true,
          release_date: '2023',
          isrc: null,
          mb_recording_id: null,
          mb_release_id: null,
          provider_ids: {
            spotify_track_id: 'track-002',
          },
        },
      ],
    });

    expect(playlistScope.isDone()).toBe(true);
    expect(trackPageScope.isDone()).toBe(true);
  });

  test('writePlaylist batches adds and retries on rate limits', async () => {
    vi.useFakeTimers();

    const profile = loadFixture('profile.json');
    const created = loadFixture('create-playlist-response.json');
    const addSuccess = loadFixture('add-tracks-success.json');

    const scope = nock(baseUrl)
      .get('/v1/me')
      .reply(200, profile)
      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
      .reply(201, created);

    const addTracksScope = nock(baseUrl)
      .post('/v1/playlists/fresh-playlist-42/tracks', {
        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
      })
      .reply(
        429,
        { error: { status: 429, message: 'Rate limited' } },
        { 'Retry-After': '1' },
      )
      .post('/v1/playlists/fresh-playlist-42/tracks', {
        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
      })
      .reply(201, addSuccess)
      .post('/v1/playlists/fresh-playlist-42/tracks', {
        uris: ['spotify:track:track-003'],
      })
      .reply(201, addSuccess);

    const provider = new Spotify({ auth: { token: 'test-token' } });

    const pif: PIF = {
      name: 'Focus Flow',
      description: 'Deep work background music.',
      source_service: 'spotify',
      source_playlist_id: 'test-playlist',
      tracks: [
        {
          position: 1,
          title: 'Deep Dive',
          artists: ['Aurora Lane'],
          album: 'Ocean Patterns',
          duration_ms: 231000,
          explicit: false,
          release_date: '2023-09-01',
          isrc: 'USRC12400001',
          provider_ids: { spotify_track_id: 'track-001' },
        },
        {
          position: 2,
          title: 'Shallow Breath',
          artists: ['Aurora Lane', 'Synthline'],
          album: 'Ocean Patterns',
          duration_ms: 198500,
          explicit: true,
          release_date: '2023',
          isrc: null,
          provider_ids: { spotify_track_id: 'track-002' },
        },
        {
          position: 3,
          title: 'Edge of Night',
          artists: ['Aurora Lane'],
          album: 'Ocean Patterns',
          duration_ms: 204000,
          explicit: false,
          release_date: '2023',
          isrc: null,
          provider_ids: { spotify_track_id: 'track-003' },
        },
      ],
    };

    const pending = provider.writePlaylist(pif, {
      batch: { batchSize: 2 },
    });

    await vi.advanceTimersByTimeAsync(1000);
    const result = await pending;

    expect(result).toEqual({
      destId: 'fresh-playlist-42',
      report: {
        attempted: 3,
        added: 3,
        failed: 0,
      },
    });

    expect(scope.isDone()).toBe(true);
    expect(addTracksScope.isDone()).toBe(true);
  });
});
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
A codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f605fa215e91bf1a225931c937ddf0be5d4118ee
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,184 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toEqual({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          mb_recording_id: null,
+          mb_release_id: null,
+          provider_ids: {
+            spotify_track_id: 'track-001',
+          },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          mb_recording_id: null,
+          mb_release_id: null,
+          provider_ids: {
+            spotify_track_id: 'track-002',
+          },
+        },
+      ],
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f605fa215e91bf1a225931c937ddf0be5d4118ee
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,184 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toEqual({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          mb_recording_id: null,
+          mb_release_id: null,
+          provider_ids: {
+            spotify_track_id: 'track-001',
+          },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          mb_recording_id: null,
+          mb_release_id: null,
+          provider_ids: {
+            spotify_track_id: 'track-002',
+          },
+        },
+      ],
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});


thinking
**Improving test expectations for optional fields**

I'm reworking tests to use `toMatchObject` so they don't fail if optional fields like `mb_recording_id` are missing or `undefined`, while still ensuring core structure and track counts match exactly. This feels like a good balance to robustly validate importer results without requiring every optional key.
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -46,3 +46,3 @@
 
-    expect(result).toEqual({
+    expect(result).toMatchObject({
       name: 'Focus Flow',
@@ -51,35 +51,26 @@
       source_playlist_id: playlistId,
-      tracks: [
-        {
-          position: 1,
-          title: 'Deep Dive',
-          artists: ['Aurora Lane'],
-          album: 'Ocean Patterns',
-          duration_ms: 231000,
-          explicit: false,
-          release_date: '2023-09-01',
-          isrc: 'USRC12400001',
-          mb_recording_id: null,
-          mb_release_id: null,
-          provider_ids: {
-            spotify_track_id: 'track-001',
-          },
-        },
-        {
-          position: 2,
-          title: 'Shallow Breath',
-          artists: ['Aurora Lane', 'Synthline'],
-          album: 'Ocean Patterns',
-          duration_ms: 198500,
-          explicit: true,
-          release_date: '2023',
-          isrc: null,
-          mb_recording_id: null,
-          mb_release_id: null,
-          provider_ids: {
-            spotify_track_id: 'track-002',
-          },
-        },
-      ],
     });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
 
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});


thinking
**Preparing tests and updating dependencies**

I'm making sure the tests cover calling `result.tracks` properly, checking the playlist tracks endpoint with the right paging parameters, and confirming no network connections interfere by using `nock`. Since the tests rely on `nock`, I'll update `package.json` to add it as a dev dependency in the correct alphabetical spot, ensuring the test setup is complete before running them.
file update
M /var/home/rick/Development/playlist-manager/package.json
@@ -37,2 +37,3 @@
     "dredd": "^14.0.0",
+    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M package.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..bc687264373471b2712e6cbf1c8f2ab1497ffe8b
--- a/package.json
+++ b/package.json
@@ -35,6 +35,7 @@
     "@stoplight/prism-cli": "^5.7.0",
     "concurrently": "^9.0.1",
     "dredd": "^14.0.0",
+    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
     "tsx": "^4.16.0",
     "vitest": "^4.0.7",

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..bc687264373471b2712e6cbf1c8f2ab1497ffe8b
--- a/package.json
+++ b/package.json
@@ -35,6 +35,7 @@
     "@stoplight/prism-cli": "^5.7.0",
     "concurrently": "^9.0.1",
     "dredd": "^14.0.0",
+    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
     "tsx": "^4.16.0",
     "vitest": "^4.0.7",


thinking
**Verifying presence of new dependencies locally**
exec
bash -lc "test -d node_modules/nock && echo 'yes' || echo 'no'" in /var/home/rick/Development/playlist-manager succeeded in 59ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
no
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..bc687264373471b2712e6cbf1c8f2ab1497ffe8b
--- a/package.json
+++ b/package.json
@@ -35,6 +35,7 @@
     "@stoplight/prism-cli": "^5.7.0",
     "concurrently": "^9.0.1",
     "dredd": "^14.0.0",
+    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
     "tsx": "^4.16.0",
     "vitest": "^4.0.7",


thinking
**Assessing nock dependency challenges for testing**

I'm trying to figure out how to handle using `nock` for network mocking in tests since the environment restricts network access and installing new packages isn't possible. Iâ€™m considering if `nock` could already be in the lockfile or node_modules, or if I need to find workarounds like stubbing fetch directly to mimic `nock` without adding dependencies, all while aligning with the userâ€™s acceptance criteria.
exec
bash -lc 'rg "nock" pnpm-lock.yaml' in /var/home/rick/Development/playlist-manager exited 1 in 46ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..bc687264373471b2712e6cbf1c8f2ab1497ffe8b
--- a/package.json
+++ b/package.json
@@ -35,6 +35,7 @@
     "@stoplight/prism-cli": "^5.7.0",
     "concurrently": "^9.0.1",
     "dredd": "^14.0.0",
+    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
     "tsx": "^4.16.0",
     "vitest": "^4.0.7",



thinking
**Devising a minimal nock stub**

I'm weighing how to handle test dependencies on the `nock` library without being able to install it officially. Since tests import `nock` heavily and acceptance mandates its use, I'm considering creating a minimal internal stub that implements key `nock` features like `disableNetConnect`, request interception, and reply handling by patching `global.fetch`. Using module aliasing in the test config to redirect `nock` imports to this stub could satisfy requirements while avoiding dependency issues. Iâ€™m sketching a structure involving `Scope` and `Interceptor` classes to mimic `nock`â€™s chaining and matching behavior, supporting core methods and matching against fetch requests for effective test mocking. This approach balances complexity and compliance with test expectations.
thinking
**Detailing nock stub structure and integration**

Iâ€™m outlining precisely how the minimal nock stub will parse base URLs, intercept fetch calls by matching method, path, query, and body, and respond with crafted Response objects. I plan to maintain global interceptor state, patch and restore global fetch to enable and disable net connect, and ensure interceptors track consumption for completeness checks. To integrate smoothly, Iâ€™m considering adding a `vitest.config.ts` alias so test imports of `'nock'` resolve to this stub, avoiding dependency installs while preserving test expectations and workflow integrity. This detailed plan should let me implement a functional minimal nock mock compatible with the existing tests.
file update
M /var/home/rick/Development/playlist-manager/package.json
@@ -37,3 +37,2 @@
     "dredd": "^14.0.0",
-    "nock": "^13.5.1",
     "openapi-typescript": "^7.10.1",
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M package.json
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});


thinking
**Setting up test stubs and alias**
file update
M /var/home/rick/Development/playlist-manager/vitest.config.ts
@@ -12,2 +12,3 @@
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M vitest.config.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Designing nock stub implementation**

I'm outlining a TypeScript stub for `nock` with a `Scope` class managing `Interceptor`s that match requests and provide responses. I'll track global interceptors, patch `fetch` on `disableNetConnect`, restore on `enableNetConnect`, and handle request matching including base URL paths. This plan covers realistic behavior expected in tests, including lazy interceptor registration on `reply` and clean-up via `cleanAll`. I'll implement it all in `codex/support/nock.ts`.
file update
A /var/home/rick/Development/playlist-manager/codex/support/nock.ts
type QueryMatcher = (query: Record<string, string>) => boolean;
type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;

interface ReplyConfig {
  status: number;
  body?: unknown;
  headers?: Record<string, string>;
}

const normalizePath = (basePath: string, path: string): string => {
  const normalized = path.startsWith('/') ? path : `/${path}`;
  if (!basePath || basePath === '/') {
    return normalized;
  }
  return `${basePath.replace(/\/$/, '')}${normalized}`;
};

const parseQuery = (url: URL): Record<string, string> => {
  const result: Record<string, string> = {};
  for (const [key, value] of url.searchParams.entries()) {
    result[key] = value;
  }
  return result;
};

const deepEqual = (a: unknown, b: unknown): boolean => {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((value, index) => deepEqual(value, b[index]));
  }

  if (a && b && typeof a === 'object') {
    const keysA = Object.keys(a as Record<string, unknown>);
    const keysB = Object.keys(b as Record<string, unknown>);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) =>
      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
        (a as Record<string, unknown>)[key],
        (b as Record<string, unknown>)[key],
      ),
    );
  }

  return false;
};

const parseBody = (body: BodyInit | null | undefined): unknown => {
  if (body === null || body === undefined) return undefined;
  if (typeof body === 'string') {
    try {
      return JSON.parse(body);
    } catch {
      return body;
    }
  }
  if (body instanceof URLSearchParams) {
    return Object.fromEntries(body.entries());
  }
  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
    try {
      const decoder = new TextDecoder();
      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
    } catch {
      return undefined;
    }
  }
  return body;
};

const toQueryMatcher = (matcher: unknown): QueryMatcher => {
  if (typeof matcher === 'function') {
    return matcher as QueryMatcher;
  }
  if (matcher === true) {
    return () => true;
  }
  if (matcher && typeof matcher === 'object') {
    const expected = Object.entries(matcher as Record<string, string | number>)
      .reduce<Record<string, string>>((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {});

    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
  }
  return () => true;
};

const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
  if (!matcher) return undefined;
  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
  return (body) => deepEqual(body, matcher as Record<string, unknown>);
};

let originalFetch: typeof globalThis.fetch | undefined;
let fetchPatched = false;

const installFetchMock = (handler: typeof fetch) => {
  if (fetchPatched) return;
  originalFetch = globalThis.fetch;
  globalThis.fetch = handler;
  fetchPatched = true;
};

const restoreFetch = () => {
  if (fetchPatched && originalFetch) {
    globalThis.fetch = originalFetch;
  }
  fetchPatched = false;
};

const respond = ({ status, body, headers }: ReplyConfig): Response => {
  const init: ResponseInit = { status, headers };
  if (body === undefined) {
    return new Response(null, init);
  }

  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
    const hdrs = new Headers(headers);
    if (!hdrs.has('content-type')) {
      hdrs.set('content-type', 'application/json');
    }
    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
  }

  return new Response(String(body), init);
};

const activeInterceptors: Interceptor[] = [];

class Interceptor {
  private queryMatcher: QueryMatcher = () => true;
  private bodyMatcher?: (body: unknown) => boolean;
  private replyConfig?: ReplyConfig;
  private consumed = false;

  constructor(
    private readonly scope: Scope,
    private readonly method: string,
    private readonly path: string,
    bodyMatcher: BodyMatcher,
  ) {
    this.bodyMatcher = toBodyMatcher(bodyMatcher);
  }

  query(matcher: unknown): this {
    this.queryMatcher = toQueryMatcher(matcher);
    return this;
  }

  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
    this.replyConfig = { status, body, headers };
    if (!activeInterceptors.includes(this)) {
      activeInterceptors.push(this);
    }
    installFetchMock(mockedFetch);
    return this.scope;
  }

  markConsumed() {
    this.consumed = true;
  }

  isConsumed(): boolean {
    return this.consumed;
  }

  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
    if (method.toUpperCase() !== this.method) return false;
    if (url.origin !== this.scope.origin) return false;
    if (url.pathname !== this.path) return false;
    if (!this.queryMatcher(parseQuery(url))) return false;

    if (this.bodyMatcher) {
      return this.bodyMatcher(parseBody(body));
    }

    return true;
  }

  createResponse(): Response {
    if (!this.replyConfig) {
      throw new Error('Reply not configured for interceptor');
    }
    this.markConsumed();
    return respond(this.replyConfig);
  }
}

class Scope {
  readonly origin: string;
  private readonly interceptors: Set<Interceptor> = new Set();
  private readonly basePath: string;

  constructor(baseUrl: string) {
    const parsed = new URL(baseUrl);
    this.origin = parsed.origin;
    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
  }

  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
    this.interceptors.add(interceptor);
    return interceptor;
  }

  get(path: string): Interceptor {
    return this.register('GET', path);
  }

  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
    return this.register('POST', path, bodyMatcher);
  }

  isDone(): boolean {
    for (const interceptor of this.interceptors) {
      if (!interceptor.isConsumed()) {
        return false;
      }
    }
    return true;
  }

  reset() {
    this.interceptors.clear();
  }
}

const scopes = new Set<Scope>();

const mockedFetch: typeof fetch = async (input, init) => {
  const requestUrl = (() => {
    if (typeof input === 'string') return new URL(input);
    if (input instanceof URL) return input;
    if (input && typeof input === 'object' && 'url' in input) {
      return new URL((input as Request).url);
    }
    throw new Error('Unsupported fetch input for nock mock');
  })();

  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
  const body = init?.body ?? (input instanceof Request ? input.body : undefined);

  for (let index = 0; index < activeInterceptors.length; index += 1) {
    const interceptor = activeInterceptors[index];
    if (interceptor.matches(requestUrl, method, init?.body)) {
      const response = interceptor.createResponse();
      activeInterceptors.splice(index, 1);
      return response;
    }
  }

  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
};

const nock = (baseUrl: string): Scope => {
  const scope = new Scope(baseUrl);
  scopes.add(scope);
  return scope;
};

nock.disableNetConnect = (): void => {
  installFetchMock(mockedFetch);
};

nock.enableNetConnect = (): void => {
  restoreFetch();
};

nock.cleanAll = (): void => {
  activeInterceptors.splice(0, activeInterceptors.length);
  for (const scope of scopes) {
    scope.reset();
  }
};

export default nock;
apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
A codex/support/nock.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d93d0d4efa229c1d3a3e4c1041c3633aefe49524
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,280 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const nock = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+nock.disableNetConnect = (): void => {
+  installFetchMock(mockedFetch);
+};
+
+nock.enableNetConnect = (): void => {
+  restoreFetch();
+};
+
+nock.cleanAll = (): void => {
+  activeInterceptors.splice(0, activeInterceptors.length);
+  for (const scope of scopes) {
+    scope.reset();
+  }
+};
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d93d0d4efa229c1d3a3e4c1041c3633aefe49524
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,280 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const nock = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+nock.disableNetConnect = (): void => {
+  installFetchMock(mockedFetch);
+};
+
+nock.enableNetConnect = (): void => {
+  restoreFetch();
+};
+
+nock.cleanAll = (): void => {
+  activeInterceptors.splice(0, activeInterceptors.length);
+  for (const scope of scopes) {
+    scope.reset();
+  }
+};
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Refactoring function export with attached methods**

Iâ€™m working on properly typing the exported function that has methods attached in TypeScript. Because the function alone canâ€™t have extra properties without errors, I plan to define an interface combining the callable signature and methods, then create the function separately and use `Object.assign` to attach the methods, finally exporting it typed as that interface to satisfy strict typing.
file update
M /var/home/rick/Development/playlist-manager/codex/support/nock.ts
@@ -258,3 +258,3 @@
 
-const nock = (baseUrl: string): Scope => {
+const createScope = (baseUrl: string): Scope => {
   const scope = new Scope(baseUrl);
@@ -264,16 +264,23 @@
 
-nock.disableNetConnect = (): void => {
-  installFetchMock(mockedFetch);
-};
-
-nock.enableNetConnect = (): void => {
-  restoreFetch();
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
 };
 
-nock.cleanAll = (): void => {
-  activeInterceptors.splice(0, activeInterceptors.length);
-  for (const scope of scopes) {
-    scope.reset();
-  }
-};
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
 
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M codex/support/nock.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Verifying interceptor reset and body handling**

I'm making sure interceptors properly reset with `cleanAll` and that `scope.isDone()` reflects consumed interceptors accurately. I noticed we inconsistently pass `init?.body` instead of a parsed `body` variable to matchers, so I'll fix that. Also, Iâ€™m checking TypeScript imports and config around `BodyInit` to avoid type errors before running targeted tests to confirm current failures.
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 99ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing to run tests on Spotify implementation**
exec
bash -lc 'pnpm vitest run codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 4.41s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

(node:447960) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 2)
(Use `node --trace-warnings ...` to show where the warning was created)
 â¯ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests | 2 failed) 20ms
   Ã— Spotify provider integration > readPlaylist maps Spotify playlist data into PIF tracks 11ms
     â†’ NIY
   Ã— Spotify provider integration > writePlaylist batches adds and retries on rate limits 6ms
     â†’ NIY

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Tests 2 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts > Spotify provider integration > readPlaylist maps Spotify playlist data into PIF tracks
Error: NIY
 â¯ Spotify.readPlaylist packages/providers/spotify/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Confirming initial failing tests**
Plan update
  âœ“ Analyze task requirements and inspect existing Spotify provider structure
  âœ“ Create failing Vitest coverage for Spotify importer/exporter with mocked HTTP fixtures
  â†’ Implement Spotify client and provider to satisfy tests
  â€¢ Run full test suite and finalize changes with commit
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {



thinking
**Implementing Spotify provider and client classes**

I'm planning the Spotify provider by creating a SpotifyClient class that wraps Spotify API calls with proper error handling for rate limits, including retries with backoff. I'll implement readPlaylist to aggregate tracks across paged responses, mapping Spotify fields accurately to the PIF format, and writePlaylist to batch-add tracks with retries on 429 errors. Defining interfaces and careful handling of query params and responses will help ensure correctness and test alignment.
thinking
**Adding writePlaylist with retry and backoff**

Iâ€™m implementing writePlaylist to batch-add tracks with a retryWithBackoff helper that catches Spotify rate-limit errors (429), waits using exponential backoff or the serverâ€™s retry-after header, and retries up to a limit. This approach ensures robust handling of transient rate limits while reporting how many tracks were attempted, added, and failed. Iâ€™m also setting up a simple sleep method compatible with test timers and carefully computing counts to align with expected behavior.
file update
A /var/home/rick/Development/playlist-manager/packages/providers/spotify/src/spotify.client.ts
import { RateLimitError } from '@app/contracts';

export interface SpotifyClientOptions {
  token: string;
  baseUrl?: string;
}

export interface SpotifyUserProfile {
  id: string;
}

export interface SpotifyArtist {
  name: string;
}

export interface SpotifyAlbum {
  name?: string | null;
  release_date?: string | null;
}

export interface SpotifyTrack {
  id?: string | null;
  name: string;
  duration_ms?: number | null;
  explicit?: boolean | null;
  external_ids?: { isrc?: string | null } | null;
  artists?: SpotifyArtist[] | null;
  album?: SpotifyAlbum | null;
  is_local?: boolean | null;
}

export interface SpotifyPlaylistItem {
  track: SpotifyTrack | null;
}

export interface SpotifyPlaylistPage {
  items: SpotifyPlaylistItem[];
  next: string | null;
  offset: number;
  limit: number;
  total: number;
}

export interface SpotifyPlaylist {
  id: string;
  name: string;
  description?: string | null;
  tracks: SpotifyPlaylistPage;
}

const defaultBaseUrl = 'https://api.spotify.com/v1';

const parseRetryAfter = (value: string | null): number | undefined => {
  if (!value) return undefined;
  const numeric = Number(value);
  if (Number.isFinite(numeric)) {
    return Math.max(0, numeric) * 1000;
  }
  const parsedDate = Date.parse(value);
  if (!Number.isNaN(parsedDate)) {
    return Math.max(0, parsedDate - Date.now());
  }
  return undefined;
};

export class SpotifyClient {
  private readonly baseUrl: string;

  constructor(private readonly options: SpotifyClientOptions) {
    if (!options.token) {
      throw new Error('Spotify token is required');
    }
    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
  }

  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
    const url = new URL(`${this.baseUrl}${path}`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value === undefined || value === null) continue;
        url.searchParams.set(key, String(value));
      }
    }
    return url.toString();
  }

  private async request<T>(method: string, path: string, options?: {
    body?: unknown;
    query?: Record<string, string | number | undefined>;
  }): Promise<T> {
    const url = this.buildUrl(path, options?.query);
    const headers: Record<string, string> = {
      authorization: `Bearer ${this.options.token}`,
    };

    const init: RequestInit = {
      method,
      headers,
    };

    if (options?.body !== undefined) {
      headers['content-type'] = 'application/json';
      init.body = JSON.stringify(options.body);
    }

    const response = await fetch(url, init);

    if (response.status === 429) {
      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
    }

    if (!response.ok) {
      const message = await response.text().catch(() => response.statusText);
      throw new Error(`Spotify API ${response.status}: ${message}`);
    }

    if (response.status === 204) {
      return undefined as T;
    }

    const text = await response.text();
    if (!text) {
      return undefined as T;
    }

    try {
      return JSON.parse(text) as T;
    } catch {
      return undefined as T;
    }
  }

  getPlaylist(id: string): Promise<SpotifyPlaylist> {
    const encoded = encodeURIComponent(id);
    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
  }

  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
    const encoded = encodeURIComponent(id);
    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
      query: {
        offset: opts.offset,
        limit: opts.limit,
      },
    });
  }

  getCurrentUser(): Promise<SpotifyUserProfile> {
    return this.request<SpotifyUserProfile>('GET', '/me');
  }

  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
    const encoded = encodeURIComponent(userId);
    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
  }

  addTracks(playlistId: string, uris: string[]): Promise<void> {
    const encoded = encodeURIComponent(playlistId);
    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
      body: { uris },
    });
  }
}
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
A packages/providers/spotify/src/spotify.client.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Implementing Spotify provider with pagination and retry**

I'm working through building a Spotify provider that paginates playlist tracks properly, normalizes options like page and batch sizes, and maps results to a standard format. I'm adding retry logic with exponential backoff for rate-limited requests and handling tracks without Spotify IDs by tracking skips. Next, I'll fully implement and refactor the Spotify class and update the main entry file accordingly.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/spotify/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Spotify implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'spotify';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M packages/providers/spotify/src/index.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Spotify implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'spotify';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Spotify implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'spotify';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing to add new implementation**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/spotify/src/index.ts
@@ -0,0 +1,224 @@
+import type {
+  BackoffOptions,
+  Exporter,
+  Importer,
+  PIF,
+  ProviderAuth,
+  ProviderImpl,
+  ProviderName,
+  ReadOptions,
+  WriteOptions,
+  WritePlaylistResult,
+} from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
+export default class Spotify implements ProviderImpl, Importer, Exporter {
+  public readonly name: ProviderName = 'spotify';
+
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
+
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private static accumulateTracks(playlist: SpotifyPlaylist, pageSize: number): SpotifyPlaylistItem[] {
+    const items: SpotifyPlaylistItem[] = [...playlist.tracks.items];
+    return items;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
+  }
+}
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M packages/providers/spotify/src/index.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..8167c235e68450cb491e576ec58a6a72dd4c41a9
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,224 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
 
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
+
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private static accumulateTracks(playlist: SpotifyPlaylist, pageSize: number): SpotifyPlaylistItem[] {
+    const items: SpotifyPlaylistItem[] = [...playlist.tracks.items];
+    return items;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..8167c235e68450cb491e576ec58a6a72dd4c41a9
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,224 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
 
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
+
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private static accumulateTracks(playlist: SpotifyPlaylist, pageSize: number): SpotifyPlaylistItem[] {
+    const items: SpotifyPlaylistItem[] = [...playlist.tracks.items];
+    return items;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Cleaning up unused methods and verifying track mapping**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/spotify/src/index.ts
@@ -105,7 +105,2 @@
 
-  private static accumulateTracks(playlist: SpotifyPlaylist, pageSize: number): SpotifyPlaylistItem[] {
-    const items: SpotifyPlaylistItem[] = [...playlist.tracks.items];
-    return items;
-  }
-
   private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M packages/providers/spotify/src/index.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Reviewing Spotify client logic and types**

I'll verify imports and type usage for SpotifyPlaylist-related types, confirm that pagination with `next` URLs and offsets is correctly handled to avoid infinite loops, and ensure error retries for RateLimitError work as intended. Then I'll re-check the TypeScript correctness and run tests to confirm all is solid.
exec
bash -lc 'pnpm vitest run codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 6.97s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 âœ“ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 30ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  02:57:25
   Duration  2.66s (transform 131ms, setup 0ms, collect 1.97s, tests 30ms, environment 0ms, prepare 96ms)

file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing to run full test suite**
Plan update
  âœ“ Analyze task requirements and inspect existing Spotify provider structure
  âœ“ Create failing Vitest coverage for Spotify importer/exporter with mocked HTTP fixtures
  âœ“ Implement Spotify client and provider to satisfy tests
  â†’ Run full test suite and finalize changes with commit
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Running full test suite**
exec
bash -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager exited 1 in 7.50s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 â¯ apps/api/src/routes/__tests__/auth.providers.test.ts (2 tests | 1 failed) 55ms
   âœ“ GET /auth/providers > omits providers that are disabled via flags 33ms
   Ã— feature guard middleware > blocks provider-dependent routes when a provider is disabled 20ms
     â†’ Failed to load url nanoid (resolved id: nanoid) in /var/home/rick/Development/playlist-manager/apps/api/src/plugins/errors.ts. Does the file exist?
 âœ“ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 44ms
 âœ“ packages/interop/test/importers/file-importers.test.ts (8 tests) 31ms
 â¯ apps/api/src/dev/__tests__/ensure-api-dev.test.ts (2 tests | 2 failed) 16ms
   Ã— ensureApiDevServer > spawns the API when target port is free 12ms
     â†’ listen EPERM: operation not permitted 127.0.0.1
   Ã— ensureApiDevServer > attaches to an existing API when port is busy 2ms
     â†’ listen EPERM: operation not permitted 127.0.0.1
 âœ“ apps/api/src/routes/__tests__/docs.test.ts (3 tests) 16ms
 â¯ packages/db/test/healthcheck.cli.test.ts (2 tests | 2 failed) 17ms
   Ã— runHealthcheck CLI helper > exits with 0 and logs success when healthy 14ms
     â†’ Failed to load url @prisma/client (resolved id: @prisma/client) in /var/home/rick/Development/playlist-manager/packages/db/src/client.ts. Does the file exist?
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Handling test failures and preparing commit**

The test suite failed due to environmental issues unrelated to my changes, so Iâ€™ll note that clearly in the final report. Before committing, I want to double-check the repo status, verify formatting, and confirm all necessary imports and type handling are correct in the Spotify provider code. Iâ€™m updating the plan to reflect that I ran the full test suite despite failures and need to finalize with a commit.
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 1.26s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 1]
 M packages/providers/spotify/src/index.ts
 M vitest.config.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/TASKS/work_list
?? codex/code/codex/06b_spotify_impl/
?? codex/support/
?? packages/providers/spotify/src/spotify.client.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing files for commit**
exec
bash -lc 'git add codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts codex/code/codex/06b_spotify_impl/tests/fixtures codex/support/nock.ts packages/providers/spotify/src/index.ts packages/providers/spotify/src/spotify.client.ts vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 894ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Verifying staged files with git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 66ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 1]
A  codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
A  codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
A  codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
A  codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
A  codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
A  codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
A  codex/support/nock.ts
M  packages/providers/spotify/src/index.ts
A  packages/providers/spotify/src/spotify.client.ts
M  vitest.config.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing commit and verifying details**
exec
bash -lc 'git commit -m "feat(spotify): implement importer and exporter"' in /var/home/rick/Development/playlist-manager succeeded in 585ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[main 2177cd7] feat(spotify): implement importer and exporter
 10 files changed, 896 insertions(+), 5 deletions(-)
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
 create mode 100644 codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
 create mode 100644 codex/support/nock.ts
 create mode 100644 packages/providers/spotify/src/spotify.client.ts
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Verifying clean working tree**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 2]
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Updating plan and preparing final note**
Plan update
  âœ“ Analyze task requirements and inspect existing Spotify provider structure
  âœ“ Create failing Vitest coverage for Spotify importer/exporter with mocked HTTP fixtures
  âœ“ Implement Spotify client and provider to satisfy tests
  âœ“ Run full test suite and finalize changes with commit
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Organizing final response details**

Iâ€™m gathering all the key info needed for the final summary: test results including a successful targeted test and a failing broader run due to environment issues, a commit message, a detailed summary of modified files with line numbers, new stubs and configs added, and an overview of git status noting untracked logs and branch status. Iâ€™m considering how to structure this with clear bullet points and concise explanations to keep it straightforward and complete.
exec
bash -lc "nl -ba packages/providers/spotify/src/index.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 89ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import type {
     2	  BackoffOptions,
     3	  Exporter,
     4	  Importer,
     5	  PIF,
     6	  ProviderAuth,
     7	  ProviderImpl,
     8	  ProviderName,
     9	  ReadOptions,
    10	  WriteOptions,
    11	  WritePlaylistResult,
    12	} from '@app/contracts';
    13	import { RateLimitError } from '@app/contracts';
    14	
    15	import {
    16	  SpotifyClient,
    17	  type SpotifyPlaylist,
    18	  type SpotifyPlaylistItem,
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

exec
bash -lc "nl -ba packages/providers/spotify/src/index.ts | sed -n '200,400p'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
   200	      added += batch.length;
   201	    }
   202	
   203	    const report: WritePlaylistResult['report'] = {
   204	      attempted: uris.length,
   205	      added,
   206	      failed: uris.length - added,
   207	    };
   208	
   209	    if (skipped > 0) {
   210	      report.skipped = skipped;
   211	      report.notes = [`${skipped} track(s) missing spotify_track_id`];
   212	    }
   213	
   214	    return {
   215	      destId: created.id,
   216	      report,
   217	    };
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Reviewing spotify.client.ts lines**
exec
bash -lc "nl -ba packages/providers/spotify/src/spotify.client.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { RateLimitError } from '@app/contracts';
     2	
     3	export interface SpotifyClientOptions {
     4	  token: string;
     5	  baseUrl?: string;
     6	}
     7	
     8	export interface SpotifyUserProfile {
     9	  id: string;
    10	}
    11	
    12	export interface SpotifyArtist {
    13	  name: string;
    14	}
    15	
    16	export interface SpotifyAlbum {
    17	  name?: string | null;
    18	  release_date?: string | null;
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Preparing to reference line numbers**
exec
bash -lc "nl -ba codex/support/nock.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	type QueryMatcher = (query: Record<string, string>) => boolean;
     2	type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
     3	
     4	interface ReplyConfig {
     5	  status: number;
     6	  body?: unknown;
     7	  headers?: Record<string, string>;
     8	}
     9	
    10	const normalizePath = (basePath: string, path: string): string => {
    11	  const normalized = path.startsWith('/') ? path : `/${path}`;
    12	  if (!basePath || basePath === '/') {
    13	    return normalized;
    14	  }
    15	  return `${basePath.replace(/\/$/, '')}${normalized}`;
    16	};
    17	
    18	const parseQuery = (url: URL): Record<string, string> => {
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

exec
bash -lc "nl -ba codex/support/nock.ts | sed -n '200,400p'" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
   200	    this.origin = parsed.origin;
   201	    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
   202	  }
   203	
   204	  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
   205	    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
   206	    this.interceptors.add(interceptor);
   207	    return interceptor;
   208	  }
   209	
   210	  get(path: string): Interceptor {
   211	    return this.register('GET', path);
   212	  }
   213	
   214	  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
   215	    return this.register('POST', path, bodyMatcher);
   216	  }
   217	
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Reviewing mock fetch usage and preparing commit summary**
exec
bash -lc 'git show --stat HEAD' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
commit 2177cd7b86be93793fa8f2cc8abfb661ce0ed948
Author: Rick Pfahl <pfahlr@gmail.com>
Date:   Thu Nov 6 02:58:17 2025 -0500

    feat(spotify): implement importer and exporter

 .../tests/fixtures/add-tracks-success.json         |   3 +
 .../tests/fixtures/create-playlist-response.json   |   4 +
 .../tests/fixtures/playlist-metadata.json          |  32 +++
 .../tests/fixtures/playlist-tracks-page-2.json     |  26 ++
 .../06b_spotify_impl/tests/fixtures/profile.json   |   4 +
 .../06b_spotify_impl/tests/spotify.impl.test.ts    | 175 +++++++++++++
 codex/support/nock.ts                              | 287 +++++++++++++++++++++
 packages/providers/spotify/src/index.ts            | 205 ++++++++++++++-
 packages/providers/spotify/src/spotify.client.ts   | 164 ++++++++++++
 vitest.config.ts                                   |   1 +
 10 files changed, 896 insertions(+), 5 deletions(-)
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {


thinking
**Composing detailed final summary**

I'll organize the final message to clearly cover the stub creation, configuration updates, test details including failures due to missing environment dependencies, implementation highlights, and untracked logs. Then Iâ€™ll provide commit information, a concise modified files summary with line references, git status, and suggested next steps aligned with the user's instructions.
codex
**Changes**
- Implemented real Spotify importer/exporter flow with pagination mapping, ID normalization, and retryable batching in `packages/providers/spotify/src/index.ts:33-218`.
- Added lightweight API wrapper handling auth, rate limits, and REST helpers in `packages/providers/spotify/src/spotify.client.ts:1-164`.
- Created Vitest coverage with mocked HTTP fixtures exercising importer and exporter behaviors in `codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts:1-187` plus JSON fixtures under `codex/code/codex/06b_spotify_impl/tests/fixtures`.
- Introduced a minimal `nock` stub wired via alias for deterministic fetch interception in tests (`codex/support/nock.ts:1-287`, `vitest.config.ts:8`).

**Tests**
- `pnpm vitest run codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts`
- `pnpm vitest run` *(fails: workspace lacks optional deps like `@prisma/client`, `fastify`, `tweetnacl`, missing SQL fixtures, and local socket binding is disallowed in this sandbox; Spotify scenarios pass)*

Commit message: `feat(spotify): implement importer and exporter`  
Modified files: `packages/providers/spotify/src/index.ts`, `packages/providers/spotify/src/spotify.client.ts`, `codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts`, fixture JSONs under `codex/code/codex/06b_spotify_impl/tests/fixtures/`, `codex/support/nock.ts`, `vitest.config.ts`  
Git status: clean (only task log files remain untracked)
file update:
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
new file mode 100644
index 0000000000000000000000000000000000000000..02b14c87e4876cae1f9ca092d695e75375b5bd24
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/add-tracks-success.json
@@ -0,0 +1,3 @@
+{
+  "snapshot_id": "snapshot-002"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
new file mode 100644
index 0000000000000000000000000000000000000000..f0e7e3c95d24bf86dc25887f85db911a3374ced9
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/create-playlist-response.json
@@ -0,0 +1,4 @@
+{
+  "id": "fresh-playlist-42",
+  "snapshot_id": "snapshot-001"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
new file mode 100644
index 0000000000000000000000000000000000000000..bd11e0a0d03de506e00e8906a5e041aa392274b0
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-metadata.json
@@ -0,0 +1,32 @@
+{
+  "id": "test-playlist",
+  "name": "Focus Flow",
+  "description": "Deep work background music.",
+  "tracks": {
+    "limit": 1,
+    "offset": 0,
+    "total": 2,
+    "next": "https://api.spotify.com/v1/playlists/test-playlist/tracks?offset=1&limit=1",
+    "items": [
+      {
+        "added_at": "2024-01-01T12:00:00Z",
+        "track": {
+          "id": "track-001",
+          "name": "Deep Dive",
+          "duration_ms": 231000,
+          "explicit": false,
+          "external_ids": {
+            "isrc": "USRC12400001"
+          },
+          "artists": [
+            { "name": "Aurora Lane" }
+          ],
+          "album": {
+            "name": "Ocean Patterns",
+            "release_date": "2023-09-01"
+          }
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
new file mode 100644
index 0000000000000000000000000000000000000000..987c44ff218ebc20642b216c6c640a0feaba74f8
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/playlist-tracks-page-2.json
@@ -0,0 +1,26 @@
+{
+  "limit": 1,
+  "offset": 1,
+  "total": 2,
+  "next": null,
+  "items": [
+    {
+      "added_at": "2024-01-01T12:03:00Z",
+      "track": {
+        "id": "track-002",
+        "name": "Shallow Breath",
+        "duration_ms": 198500,
+        "explicit": true,
+        "external_ids": {},
+        "artists": [
+          { "name": "Aurora Lane" },
+          { "name": "Synthline" }
+        ],
+        "album": {
+          "name": "Ocean Patterns",
+          "release_date": "2023"
+        }
+      }
+    }
+  ]
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
new file mode 100644
index 0000000000000000000000000000000000000000..1410799405e225924dbb61c3f350907cecff15ff
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/fixtures/profile.json
@@ -0,0 +1,4 @@
+{
+  "id": "user-123",
+  "display_name": "Productive Listener"
+}
diff --git a/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..997b2179463c1ca88e825737eb89808bfd129408
--- /dev/null
+++ b/codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts
@@ -0,0 +1,175 @@
+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
+import nock from 'nock';
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import Spotify from '../../../../../packages/providers/spotify/src/index.ts';
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+describe('Spotify provider integration', () => {
+  const baseUrl = 'https://api.spotify.com';
+
+  beforeEach(() => {
+    nock.disableNetConnect();
+  });
+
+  afterEach(() => {
+    nock.cleanAll();
+    nock.enableNetConnect();
+    vi.useRealTimers();
+  });
+
+  test('readPlaylist maps Spotify playlist data into PIF tracks', async () => {
+    const playlistId = 'test-playlist';
+    const playlist = loadFixture('playlist-metadata.json');
+    const pageTwo = loadFixture('playlist-tracks-page-2.json');
+
+    const playlistScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}`)
+      .query(true)
+      .reply(200, playlist);
+
+    const trackPageScope = nock(baseUrl)
+      .get(`/v1/playlists/${playlistId}/tracks`)
+      .query((qs) => qs.offset === '1' && qs.limit === '1')
+      .reply(200, pageTwo);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const result = await provider.readPlaylist(playlistId, { pageSize: 1 });
+
+    expect(result).toMatchObject({
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: playlistId,
+    });
+    expect(result.tracks).toHaveLength(2);
+    expect(result.tracks[0]).toMatchObject({
+      position: 1,
+      title: 'Deep Dive',
+      artists: ['Aurora Lane'],
+      album: 'Ocean Patterns',
+      duration_ms: 231000,
+      explicit: false,
+      release_date: '2023-09-01',
+      isrc: 'USRC12400001',
+      provider_ids: { spotify_track_id: 'track-001' },
+    });
+    expect(result.tracks[1]).toMatchObject({
+      position: 2,
+      title: 'Shallow Breath',
+      artists: ['Aurora Lane', 'Synthline'],
+      album: 'Ocean Patterns',
+      duration_ms: 198500,
+      explicit: true,
+      release_date: '2023',
+      isrc: null,
+      provider_ids: { spotify_track_id: 'track-002' },
+    });
+
+    expect(playlistScope.isDone()).toBe(true);
+    expect(trackPageScope.isDone()).toBe(true);
+  });
+
+  test('writePlaylist batches adds and retries on rate limits', async () => {
+    vi.useFakeTimers();
+
+    const profile = loadFixture('profile.json');
+    const created = loadFixture('create-playlist-response.json');
+    const addSuccess = loadFixture('add-tracks-success.json');
+
+    const scope = nock(baseUrl)
+      .get('/v1/me')
+      .reply(200, profile)
+      .post('/v1/users/user-123/playlists', (body) => body.name === 'Focus Flow')
+      .reply(201, created);
+
+    const addTracksScope = nock(baseUrl)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(
+        429,
+        { error: { status: 429, message: 'Rate limited' } },
+        { 'Retry-After': '1' },
+      )
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-001', 'spotify:track:track-002'],
+      })
+      .reply(201, addSuccess)
+      .post('/v1/playlists/fresh-playlist-42/tracks', {
+        uris: ['spotify:track:track-003'],
+      })
+      .reply(201, addSuccess);
+
+    const provider = new Spotify({ auth: { token: 'test-token' } });
+
+    const pif: PIF = {
+      name: 'Focus Flow',
+      description: 'Deep work background music.',
+      source_service: 'spotify',
+      source_playlist_id: 'test-playlist',
+      tracks: [
+        {
+          position: 1,
+          title: 'Deep Dive',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 231000,
+          explicit: false,
+          release_date: '2023-09-01',
+          isrc: 'USRC12400001',
+          provider_ids: { spotify_track_id: 'track-001' },
+        },
+        {
+          position: 2,
+          title: 'Shallow Breath',
+          artists: ['Aurora Lane', 'Synthline'],
+          album: 'Ocean Patterns',
+          duration_ms: 198500,
+          explicit: true,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-002' },
+        },
+        {
+          position: 3,
+          title: 'Edge of Night',
+          artists: ['Aurora Lane'],
+          album: 'Ocean Patterns',
+          duration_ms: 204000,
+          explicit: false,
+          release_date: '2023',
+          isrc: null,
+          provider_ids: { spotify_track_id: 'track-003' },
+        },
+      ],
+    };
+
+    const pending = provider.writePlaylist(pif, {
+      batch: { batchSize: 2 },
+    });
+
+    await vi.advanceTimersByTimeAsync(1000);
+    const result = await pending;
+
+    expect(result).toEqual({
+      destId: 'fresh-playlist-42',
+      report: {
+        attempted: 3,
+        added: 3,
+        failed: 0,
+      },
+    });
+
+    expect(scope.isDone()).toBe(true);
+    expect(addTracksScope.isDone()).toBe(true);
+  });
+});
diff --git a/codex/support/nock.ts b/codex/support/nock.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0b1a92faf60630659420e55c8e64a966390464e2
--- /dev/null
+++ b/codex/support/nock.ts
@@ -0,0 +1,287 @@
+type QueryMatcher = (query: Record<string, string>) => boolean;
+type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;
+
+interface ReplyConfig {
+  status: number;
+  body?: unknown;
+  headers?: Record<string, string>;
+}
+
+const normalizePath = (basePath: string, path: string): string => {
+  const normalized = path.startsWith('/') ? path : `/${path}`;
+  if (!basePath || basePath === '/') {
+    return normalized;
+  }
+  return `${basePath.replace(/\/$/, '')}${normalized}`;
+};
+
+const parseQuery = (url: URL): Record<string, string> => {
+  const result: Record<string, string> = {};
+  for (const [key, value] of url.searchParams.entries()) {
+    result[key] = value;
+  }
+  return result;
+};
+
+const deepEqual = (a: unknown, b: unknown): boolean => {
+  if (a === b) return true;
+  if (typeof a !== typeof b) return false;
+
+  if (Array.isArray(a) && Array.isArray(b)) {
+    if (a.length !== b.length) return false;
+    return a.every((value, index) => deepEqual(value, b[index]));
+  }
+
+  if (a && b && typeof a === 'object') {
+    const keysA = Object.keys(a as Record<string, unknown>);
+    const keysB = Object.keys(b as Record<string, unknown>);
+    if (keysA.length !== keysB.length) return false;
+    return keysA.every((key) =>
+      Object.prototype.hasOwnProperty.call(b, key) && deepEqual(
+        (a as Record<string, unknown>)[key],
+        (b as Record<string, unknown>)[key],
+      ),
+    );
+  }
+
+  return false;
+};
+
+const parseBody = (body: BodyInit | null | undefined): unknown => {
+  if (body === null || body === undefined) return undefined;
+  if (typeof body === 'string') {
+    try {
+      return JSON.parse(body);
+    } catch {
+      return body;
+    }
+  }
+  if (body instanceof URLSearchParams) {
+    return Object.fromEntries(body.entries());
+  }
+  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
+    try {
+      const decoder = new TextDecoder();
+      return parseBody(decoder.decode(body instanceof ArrayBuffer ? body : body.buffer));
+    } catch {
+      return undefined;
+    }
+  }
+  return body;
+};
+
+const toQueryMatcher = (matcher: unknown): QueryMatcher => {
+  if (typeof matcher === 'function') {
+    return matcher as QueryMatcher;
+  }
+  if (matcher === true) {
+    return () => true;
+  }
+  if (matcher && typeof matcher === 'object') {
+    const expected = Object.entries(matcher as Record<string, string | number>)
+      .reduce<Record<string, string>>((acc, [key, value]) => {
+        acc[key] = String(value);
+        return acc;
+      }, {});
+
+    return (actual) => Object.entries(expected).every(([key, value]) => actual[key] === value);
+  }
+  return () => true;
+};
+
+const toBodyMatcher = (matcher: BodyMatcher): ((body: unknown) => boolean) | undefined => {
+  if (!matcher) return undefined;
+  if (typeof matcher === 'function') return matcher as (body: unknown) => boolean;
+  return (body) => deepEqual(body, matcher as Record<string, unknown>);
+};
+
+let originalFetch: typeof globalThis.fetch | undefined;
+let fetchPatched = false;
+
+const installFetchMock = (handler: typeof fetch) => {
+  if (fetchPatched) return;
+  originalFetch = globalThis.fetch;
+  globalThis.fetch = handler;
+  fetchPatched = true;
+};
+
+const restoreFetch = () => {
+  if (fetchPatched && originalFetch) {
+    globalThis.fetch = originalFetch;
+  }
+  fetchPatched = false;
+};
+
+const respond = ({ status, body, headers }: ReplyConfig): Response => {
+  const init: ResponseInit = { status, headers };
+  if (body === undefined) {
+    return new Response(null, init);
+  }
+
+  if (typeof body === 'object' && body !== null && !(body instanceof ArrayBuffer)) {
+    const hdrs = new Headers(headers);
+    if (!hdrs.has('content-type')) {
+      hdrs.set('content-type', 'application/json');
+    }
+    return new Response(JSON.stringify(body), { ...init, headers: hdrs });
+  }
+
+  return new Response(String(body), init);
+};
+
+const activeInterceptors: Interceptor[] = [];
+
+class Interceptor {
+  private queryMatcher: QueryMatcher = () => true;
+  private bodyMatcher?: (body: unknown) => boolean;
+  private replyConfig?: ReplyConfig;
+  private consumed = false;
+
+  constructor(
+    private readonly scope: Scope,
+    private readonly method: string,
+    private readonly path: string,
+    bodyMatcher: BodyMatcher,
+  ) {
+    this.bodyMatcher = toBodyMatcher(bodyMatcher);
+  }
+
+  query(matcher: unknown): this {
+    this.queryMatcher = toQueryMatcher(matcher);
+    return this;
+  }
+
+  reply(status: number, body?: unknown, headers?: Record<string, string>): Scope {
+    this.replyConfig = { status, body, headers };
+    if (!activeInterceptors.includes(this)) {
+      activeInterceptors.push(this);
+    }
+    installFetchMock(mockedFetch);
+    return this.scope;
+  }
+
+  markConsumed() {
+    this.consumed = true;
+  }
+
+  isConsumed(): boolean {
+    return this.consumed;
+  }
+
+  matches(url: URL, method: string, body: BodyInit | null | undefined): boolean {
+    if (method.toUpperCase() !== this.method) return false;
+    if (url.origin !== this.scope.origin) return false;
+    if (url.pathname !== this.path) return false;
+    if (!this.queryMatcher(parseQuery(url))) return false;
+
+    if (this.bodyMatcher) {
+      return this.bodyMatcher(parseBody(body));
+    }
+
+    return true;
+  }
+
+  createResponse(): Response {
+    if (!this.replyConfig) {
+      throw new Error('Reply not configured for interceptor');
+    }
+    this.markConsumed();
+    return respond(this.replyConfig);
+  }
+}
+
+class Scope {
+  readonly origin: string;
+  private readonly interceptors: Set<Interceptor> = new Set();
+  private readonly basePath: string;
+
+  constructor(baseUrl: string) {
+    const parsed = new URL(baseUrl);
+    this.origin = parsed.origin;
+    this.basePath = parsed.pathname === '/' ? '' : parsed.pathname.replace(/\/$/, '');
+  }
+
+  private register(method: string, path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    const interceptor = new Interceptor(this, method, normalizePath(this.basePath, path), bodyMatcher);
+    this.interceptors.add(interceptor);
+    return interceptor;
+  }
+
+  get(path: string): Interceptor {
+    return this.register('GET', path);
+  }
+
+  post(path: string, bodyMatcher?: BodyMatcher): Interceptor {
+    return this.register('POST', path, bodyMatcher);
+  }
+
+  isDone(): boolean {
+    for (const interceptor of this.interceptors) {
+      if (!interceptor.isConsumed()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  reset() {
+    this.interceptors.clear();
+  }
+}
+
+const scopes = new Set<Scope>();
+
+const mockedFetch: typeof fetch = async (input, init) => {
+  const requestUrl = (() => {
+    if (typeof input === 'string') return new URL(input);
+    if (input instanceof URL) return input;
+    if (input && typeof input === 'object' && 'url' in input) {
+      return new URL((input as Request).url);
+    }
+    throw new Error('Unsupported fetch input for nock mock');
+  })();
+
+  const method = (init?.method ?? ((input as Request)?.method ?? 'GET')).toUpperCase();
+  const body = init?.body ?? (input instanceof Request ? input.body : undefined);
+
+  for (let index = 0; index < activeInterceptors.length; index += 1) {
+    const interceptor = activeInterceptors[index];
+    if (interceptor.matches(requestUrl, method, init?.body)) {
+      const response = interceptor.createResponse();
+      activeInterceptors.splice(index, 1);
+      return response;
+    }
+  }
+
+  throw new Error(`No nock matched for ${method} ${requestUrl.toString()}`);
+};
+
+const createScope = (baseUrl: string): Scope => {
+  const scope = new Scope(baseUrl);
+  scopes.add(scope);
+  return scope;
+};
+
+type NockFn = {
+  (baseUrl: string): Scope;
+  disableNetConnect(): void;
+  enableNetConnect(): void;
+  cleanAll(): void;
+};
+
+const nock: NockFn = Object.assign(createScope, {
+  disableNetConnect: (): void => {
+    installFetchMock(mockedFetch);
+  },
+  enableNetConnect: (): void => {
+    restoreFetch();
+  },
+  cleanAll: (): void => {
+    activeInterceptors.splice(0, activeInterceptors.length);
+    for (const scope of scopes) {
+      scope.reset();
+    }
+  },
+});
+
+export default nock;
diff --git a/packages/providers/spotify/src/index.ts b/packages/providers/spotify/src/index.ts
index a7ad347108f3a22ae7bbbe7368570f181b946623..c8c65c0cc874e7001f1ec4acf2be407b779dcebf
--- a/packages/providers/spotify/src/index.ts
+++ b/packages/providers/spotify/src/index.ts
@@ -1,24 +1,219 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  SpotifyClient,
+  type SpotifyPlaylist,
+  type SpotifyPlaylistItem,
+} from './spotify.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.trunc(batchSize);
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+interface SpotifyOptions {
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
+const toUri = (trackId: string): string => `spotify:track:${trackId}`;
+
+const mapTrack = (item: SpotifyPlaylistItem, index: number) => {
+  const track = item.track;
+  if (!track || track.is_local) {
+    return undefined;
+  }
+
+  const artists = (track.artists ?? [])
+    .map((artist) => artist?.name)
+    .filter((name): name is string => Boolean(name));
+
+  return {
+    position: index + 1,
+    title: track.name,
+    artists,
+    album: track.album?.name ?? null,
+    duration_ms: track.duration_ms ?? null,
+    explicit: track.explicit ?? null,
+    release_date: track.album?.release_date ?? null,
+    isrc: track.external_ids?.isrc ?? null,
+    provider_ids: track.id ? { spotify_track_id: track.id } : undefined,
+  };
+};
+
 export default class Spotify implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'spotify';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: SpotifyOptions;
+  private client?: SpotifyClient;
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+  constructor(options?: SpotifyOptions) {
+    this.options = options ?? {};
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  private ensureClient(): SpotifyClient {
+    if (this.client) return this.client;
+    const token = this.options.auth?.token;
+    if (!token) {
+      throw new Error('Spotify auth token is required');
+    }
+    this.client = new SpotifyClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(playlist: SpotifyPlaylist, pageSize: number): Promise<SpotifyPlaylistItem[]> {
+    const items = [...playlist.tracks.items];
+
+    let next = playlist.tracks.next;
+    let offset = playlist.tracks.offset + playlist.tracks.items.length;
+
+    const client = this.ensureClient();
+
+    while (next) {
+      const page = await client.getPlaylistTracks(playlist.id, { offset, limit: pageSize });
+      items.push(...page.items);
+      next = page.next;
+      offset += page.items.length;
+      if (page.items.length === 0) {
+        break;
+      }
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const pageSize = normalizePageSize(opts?.pageSize);
+    const client = this.ensureClient();
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(playlist, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name,
+      description: playlist.description ?? null,
+      source_service: 'spotify',
+      source_playlist_id: playlist.id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff(fn: () => Promise<void>, backoff: BackoffOptions | undefined) {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        await fn();
+        return;
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
+
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
+  }
+
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+    const backoff = opts?.backoff;
+
+    const profile = await client.getCurrentUser();
+    const created = await client.createPlaylist(profile.id, {
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const uris: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const trackId = track.provider_ids?.spotify_track_id;
+      if (!trackId) {
+        skipped += 1;
+        continue;
+      }
+      uris.push(toUri(trackId));
+    }
+
+    let added = 0;
+    for (let cursor = 0; cursor < uris.length; cursor += batchSize) {
+      const batch = uris.slice(cursor, cursor + batchSize);
+      await this.runWithBackoff(() => client.addTracks(created.id, batch), backoff);
+      added += batch.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: uris.length,
+      added,
+      failed: uris.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing spotify_track_id`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/spotify/src/spotify.client.ts b/packages/providers/spotify/src/spotify.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c03653476ed8ab0800c50f2074e1d67a4ad2f3bf
--- /dev/null
+++ b/packages/providers/spotify/src/spotify.client.ts
@@ -0,0 +1,164 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface SpotifyClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface SpotifyUserProfile {
+  id: string;
+}
+
+export interface SpotifyArtist {
+  name: string;
+}
+
+export interface SpotifyAlbum {
+  name?: string | null;
+  release_date?: string | null;
+}
+
+export interface SpotifyTrack {
+  id?: string | null;
+  name: string;
+  duration_ms?: number | null;
+  explicit?: boolean | null;
+  external_ids?: { isrc?: string | null } | null;
+  artists?: SpotifyArtist[] | null;
+  album?: SpotifyAlbum | null;
+  is_local?: boolean | null;
+}
+
+export interface SpotifyPlaylistItem {
+  track: SpotifyTrack | null;
+}
+
+export interface SpotifyPlaylistPage {
+  items: SpotifyPlaylistItem[];
+  next: string | null;
+  offset: number;
+  limit: number;
+  total: number;
+}
+
+export interface SpotifyPlaylist {
+  id: string;
+  name: string;
+  description?: string | null;
+  tracks: SpotifyPlaylistPage;
+}
+
+const defaultBaseUrl = 'https://api.spotify.com/v1';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const parsedDate = Date.parse(value);
+  if (!Number.isNaN(parsedDate)) {
+    return Math.max(0, parsedDate - Date.now());
+  }
+  return undefined;
+};
+
+export class SpotifyClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: SpotifyClientOptions) {
+    if (!options.token) {
+      throw new Error('Spotify token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(`${this.baseUrl}${path}`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(method: string, path: string, options?: {
+    body?: unknown;
+    query?: Record<string, string | number | undefined>;
+  }): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Spotify rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Spotify API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<SpotifyPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylist>('GET', `/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { offset: number; limit: number }): Promise<SpotifyPlaylistPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request<SpotifyPlaylistPage>('GET', `/playlists/${encoded}/tracks`, {
+      query: {
+        offset: opts.offset,
+        limit: opts.limit,
+      },
+    });
+  }
+
+  getCurrentUser(): Promise<SpotifyUserProfile> {
+    return this.request<SpotifyUserProfile>('GET', '/me');
+  }
+
+  createPlaylist(userId: string, payload: { name: string; description?: string | null }): Promise<{ id: string }> {
+    const encoded = encodeURIComponent(userId);
+    return this.request<{ id: string }>('POST', `/users/${encoded}/playlists`, { body: payload });
+  }
+
+  addTracks(playlistId: string, uris: string[]): Promise<void> {
+    const encoded = encodeURIComponent(playlistId);
+    return this.request<void>('POST', `/playlists/${encoded}/tracks`, {
+      body: { uris },
+    });
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 0bce3ef2f7cd257e4e4fd00f47e84135c3c821dc..d6cc1e9cf053285a68ba81acd41fd0840bab88b2
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -10,6 +10,7 @@
     alias: {
       '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
       '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
+      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
     },
   },
   test: {

tokens used
187,822
**Changes**
- Implemented real Spotify importer/exporter flow with pagination mapping, ID normalization, and retryable batching in `packages/providers/spotify/src/index.ts:33-218`.
- Added lightweight API wrapper handling auth, rate limits, and REST helpers in `packages/providers/spotify/src/spotify.client.ts:1-164`.
- Created Vitest coverage with mocked HTTP fixtures exercising importer and exporter behaviors in `codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts:1-187` plus JSON fixtures under `codex/code/codex/06b_spotify_impl/tests/fixtures`.
- Introduced a minimal `nock` stub wired via alias for deterministic fetch interception in tests (`codex/support/nock.ts:1-287`, `vitest.config.ts:8`).

**Tests**
- `pnpm vitest run codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts`
- `pnpm vitest run` *(fails: workspace lacks optional deps like `@prisma/client`, `fastify`, `tweetnacl`, missing SQL fixtures, and local socket binding is disallowed in this sandbox; Spotify scenarios pass)*

Commit message: `feat(spotify): implement importer and exporter`  
Modified files: `packages/providers/spotify/src/index.ts`, `packages/providers/spotify/src/spotify.client.ts`, `codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts`, fixture JSONs under `codex/code/codex/06b_spotify_impl/tests/fixtures/`, `codex/support/nock.ts`, `vitest.config.ts`  
Git status: clean (only task log files remain untracked)
