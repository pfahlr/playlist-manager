OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5c06-e991-7863-8b50-600bee9b7fe2
--------
user
Implement the functionality described in codex/TASKS/06h_provider_fixture_harness.yaml, then verify with any available tests.

thinking
**Preparing to implement commit functionality**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 101ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas
scripts
tsconfig.json

thinking
**Inspecting provider fixture harness instructions**
exec
bash -lc 'cat codex/TASKS/06h_provider_fixture_harness.yaml' in /var/home/rick/Development/playlist-manager succeeded in 53ms:
id: 06h_provider_fixture_harness
title: Offline fixture harness for provider tests (record/replay)
branch: codex/06h_provider_fixture_harness
overview: >
  Add a record/replay harness (nock or fetch-mock with saved JSON) so provider tests run without network.
  Switch via PROVIDER_FIXTURES=1.
acceptance:
  - provider tests pass offline using stored fixtures
  - a script updates fixtures deterministically
artifacts_to_touch:
  - packages/providers/core/test/fixtures/*.json
  - packages/providers/core/test/fixtureHarness.ts
  - package.json scripts ("test:update-fixtures")
steps:
  - Wrap fetch; when recording, save responses; when replaying, serve from disk

thinking
**Preparing to implement test harness**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 61ms:
core
deezer
file-exporters
spotify
tidal
youtube

thinking
**Browsing core providers list**
exec
bash -lc 'ls packages/providers/core' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
src
test

thinking
**Inspecting test directory contents**
exec
bash -lc 'ls packages/providers/core/test' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
fixtureHarness.ts
mbidResolver.test.ts

thinking
**Inspecting fixtureHarness file**
exec
bash -lc "sed -n '1,200p' packages/providers/core/test/fixtureHarness.ts" in /var/home/rick/Development/playlist-manager succeeded in 112ms:
import fs from 'node:fs';
import path from 'node:path';

const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');

function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }

export async function fetchFx(url: string, init?: RequestInit) {
  if (MODE === 'live') return fetch(url, init);

  const file = path.join(DIR, key(url) + '.json');
  if (MODE === 'replay') {
    const body = fs.readFileSync(file, 'utf8');
    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
  }

  // record
  const resp = await fetch(url, init);

thinking
**Reviewing provider test setup**
exec
bash -lc "sed -n '1,200p' packages/providers/core/test/mbidResolver.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 71ms:
import { describe, it, expect } from 'vitest';
import { resolveMbid } from '../src/match/mbidResolver';

describe('resolveMbid', () => {
  it('prefers direct mbid', () => {
    const r = resolveMbid({
      provider: { title: 'Xtal', artist: 'Aphex Twin', mbid: 'm-1' },
      catalog: []
    });
    expect(r?.rule).toBe('mbid');
  });

  it('matches by isrc', () => {
    const r = resolveMbid({
      provider: { title: 'Song', artist: 'Artist', isrc: 'US-ABC-123' },
      catalog: [{ mbid: 'm-2', title: 'Song', primaryArtist: 'Artist', isrc: 'US-ABC-123' }]
    });
    expect(r?.rule).toBe('isrc');
  });
});

thinking
**Searching for network usage in providers**
exec
bash -lc 'rg -n "fetchFx" -n' in /var/home/rick/Development/playlist-manager succeeded in 9.90s:
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:98:export async function fetchFx(url: string, init?: RequestInit) {
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:138:bash -lc 'rg -n "fetchFx" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06g_provider_cache_backoff_1762417604.log:146:export async function fetchFx(url: string, init?: RequestInit) {
packages/providers/core/test/fixtureHarness.ts:10:export async function fetchFx(url: string, init?: RequestInit) {

thinking
**Investigating provider test integration**
exec
bash -lc 'rg -n "PROVIDER_FIXTURES" -n' in /var/home/rick/Development/playlist-manager succeeded in 64ms:
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:49:  Switch via PROVIDER_FIXTURES=1.
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:92:const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log:147:bash -lc 'rg -n "PROVIDER_FIXTURES" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06g_provider_cache_backoff_1762417604.log:140:const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
codex/TASKS/06h_provider_fixture_harness.yaml:6:  Switch via PROVIDER_FIXTURES=1.
packages/providers/core/test/fixtureHarness.ts:4:const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :

thinking
**Searching for fetch usage in providers**
exec
bash -lc "rg -n \"fetch\\(\" packages/providers" in /var/home/rick/Development/playlist-manager succeeded in 60ms:
packages/providers/tidal/src/tidal.client.ts:97:    const response = await fetch(url, init);
packages/providers/core/src/http/client.ts:30:      const resp = await fetch(this.opts.baseUrl + url, { ...init, method, headers: hdrs });
packages/providers/deezer/src/deezer.client.ts:112:      const response = await fetch(url, init);
packages/providers/core/test/fixtureHarness.ts:11:  if (MODE === 'live') return fetch(url, init);
packages/providers/core/test/fixtureHarness.ts:20:  const resp = await fetch(url, init);
packages/providers/spotify/src/spotify.client.ts:106:    const response = await fetch(url, init);
packages/providers/youtube/src/youtube.client.ts:122:    const response = await fetch(url, init);

thinking
**Investigating provider tests for fetch integration**
exec
bash -lc 'rg --files packages/providers | grep test' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
packages/providers/core/test/fixtureHarness.ts
packages/providers/core/test/mbidResolver.test.ts

thinking
**Planning offline fixture harness tasks**
Plan update
  → Understand existing provider fixture harness and requirements from task spec.
  • Add failing tests covering record/replay fixture harness behavior and fixture update script expectations.
  • Implement harness updates, fixture storage, and package scripts to satisfy tests, then run tests/prepare commit.

thinking
**Reviewing package.json scripts**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager succeeded in 59ms:
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
    "contract:test": "schemathesis run openapi.yaml --checks all --hypothesis-deadline=1000",
    "prisma:generate": "pnpm -F @app/db exec prisma generate",

thinking
**Investigating test fixture updates**
exec
bash -lc 'cat vitest.config.ts' in /var/home/rick/Development/playlist-manager succeeded in 49ms:
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { defineConfig } from 'vitest/config';

const rootDir = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  resolve: {
    alias: {
      '@app/contracts': path.resolve(rootDir, 'packages/contracts/src/index.ts'),
      '@app/interop': path.resolve(rootDir, 'packages/interop/src'),
      '@app/db': path.resolve(rootDir, 'packages/db/src/index.ts'),
      '@app/providers-spotify': path.resolve(rootDir, 'packages/providers/spotify/src/index.ts'),
      '@app/providers-deezer': path.resolve(rootDir, 'packages/providers/deezer/src/index.ts'),
      '@app/providers-tidal': path.resolve(rootDir, 'packages/providers/tidal/src/index.ts'),
      '@app/providers-youtube': path.resolve(rootDir, 'packages/providers/youtube/src/index.ts'),
      nock: path.resolve(rootDir, 'codex/support/nock.ts'),
    },
  },

thinking
**Opening alias target file**
exec
bash -lc "sed -n '1,200p' codex/support/nock.ts" in /var/home/rick/Development/playlist-manager succeeded in 47ms:
type QueryMatcher = (query: Record<string, string>) => boolean;
type BodyMatcher = ((body: unknown) => boolean) | Record<string, unknown> | undefined;

interface ReplyConfig {
  status: number;
  body?: unknown;
  headers?: Record<string, string>;
}

const normalizePath = (basePath: string, path: string): string => {
  const normalized = path.startsWith('/') ? path : `/${path}`;
  if (!basePath || basePath === '/') {
    return normalized;
  }
  return `${basePath.replace(/\/$/, '')}${normalized}`;
};

const parseQuery = (url: URL): Record<string, string> => {
  const result: Record<string, string> = {};
  for (const [key, value] of url.searchParams.entries()) {

thinking
**Analyzing fixture harness requirements**

I'm reviewing instructions and existing code to understand how to build a record/replay fixture harness for provider tests that intercepts fetch, saves responses, and plays them back offline, while considering earlier logs for context and acceptance criteria.
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log" in /var/home/rick/Development/playlist-manager succeeded in 54ms:
OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5c06-e991-7863-8b50-600bee9b7fe2
--------
user
Implement the functionality described in codex/TASKS/06h_provider_fixture_harness.yaml, then verify with any available tests.

thinking
**Preparing to implement commit functionality**
exec
bash -lc ls in /var/home/rick/Development/playlist-manager succeeded in 101ms:
AGENTS.md
apps

thinking
**Resolving commit and push instruction conflict**
Plan update
  ✓ Understand existing provider fixture harness and requirements from task spec.
  → Add failing tests covering record/replay fixture harness behavior and fixture update script expectations.
  • Implement harness updates, fixture storage, and package scripts to satisfy tests, then run tests/prepare commit.




thinking
**Designing fixture recording and replay tests**

I'm mapping out how to add tests for the fetch fixture harness with env-based modes for recording and replay. I want to ensure offline tests use stored JSON fixtures and that the recording mode writes full response metadata to disk. There's a lot to consider, like fixture naming, directory paths, environment variables, and a deterministic update script that clears old fixtures before recording new ones. I'll plan adding sample fixtures and restructuring the harness for testability while aligning with how record and replay are toggled. This will guide the test creation targeting `packages/providers/core/test/fixtureHarness.test.ts`.
thinking
**Finalizing test environment setup and fixture key design**

I'm refining the cross-platform fixture cleanup using a Node script embedded in package.json and planning detailed tests for both replay and record modes. I’m focusing on stable fixture key naming based on HTTP method and sanitized URLs, deciding to skip request body hashing for now to keep it simple. I’m also considering how to dynamically read environment variables during tests to avoid stale mode values, designing tests that confirm fetch is stubbed correctly in both modes, and ensuring helpful errors appear if fixture files are missing.
thinking
**Designing tests for fetchFx replay and record modes**

I'm working out the test cases to ensure `fetchFx` correctly replays fixtures without calling global fetch and records fixtures properly by mocking fetch and verifying output files. I’m planning to handle environment variables carefully across tests to isolate modes, committing a sample fixture file with the expected structure for replay mode, and using vitest utilities to spy, mock, and restore fetch cleanly between tests. The approach also contemplates dynamically importing the fixture harness module to respect environment changes per test for accurate TDD.
thinking
**Implementing test setup and cleanup procedures**

I’m setting up tests with proper environment management, restoring the original fetch after each test, cleaning temporary fixture directories, and dynamically importing the fixture harness to ensure environment variables take effect properly. The tests verify both replay mode (using committed fixture metadata) and record mode (mocking fetch, saving output), carefully handling file cleanup and module resets to maintain isolation between tests.
file update
A /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtureHarness.test.ts
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';

import { afterEach, describe, expect, it, vi } from 'vitest';

const nativeFetch = globalThis.fetch;
const defaultEnv = {
  fixtures: process.env.PROVIDER_FIXTURES,
  record: process.env.PROVIDER_RECORD,
  dir: process.env.PROVIDER_FIXTURE_DIR,
};

async function loadHarness() {
  vi.resetModules();
  return import('./fixtureHarness');
}

const cleanupDirs = new Set<string>();

afterEach(() => {
  cleanupDirs.forEach((dir) => {
    try {
      fs.rmSync(dir, { recursive: true, force: true });
    } catch (err) {
      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
    }
  });
  cleanupDirs.clear();

  if (nativeFetch) {
    globalThis.fetch = nativeFetch;
  }
  vi.restoreAllMocks();

  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;

  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
  else process.env.PROVIDER_RECORD = defaultEnv.record;

  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
});

describe('fixtureHarness', () => {
  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
    process.env.PROVIDER_FIXTURES = '1';
    const fetchSpy = vi.spyOn(globalThis, 'fetch');
    const { fetchFx } = await loadHarness();

    const resp = await fetchFx('https://fixtures.test/artist');
    expect(fetchSpy).not.toHaveBeenCalled();
    expect(resp.status).toBe(206);
    expect(resp.headers.get('x-fixture-source')).toBe('offline');
    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
  });

  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
    cleanupDirs.add(tmpDir);

    process.env.PROVIDER_RECORD = '1';
    process.env.PROVIDER_FIXTURE_DIR = tmpDir;

    const fetchMock = vi.fn().mockResolvedValue(
      new Response(JSON.stringify({ captured: true }), {
        status: 201,
        headers: {
          'content-type': 'application/json',
          'x-test': 'fixture',
        },
      }),
    );
    globalThis.fetch = fetchMock as typeof globalThis.fetch;

    const { fetchFx } = await loadHarness();
    const resp = await fetchFx('https://record.test/data', { method: 'POST' });

    expect(fetchMock).toHaveBeenCalledTimes(1);
    expect(resp.status).toBe(201);
    await expect(resp.json()).resolves.toEqual({ captured: true });

    const files = fs.readdirSync(tmpDir);
    expect(files).toHaveLength(1);

    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
    expect(recorded).toMatchObject({
      url: 'https://record.test/data',
      method: 'POST',
      status: 201,
      headers: {
        'content-type': 'application/json',
        'x-test': 'fixture',
      },
      body: '{"captured":true}',
    });
  });
});
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A packages/providers/core/test/fixtureHarness.test.ts
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});

file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});


thinking
**Preparing test fixture file**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
{
  "url": "https://fixtures.test/artist",
  "method": "GET",
  "status": 206,
  "headers": {
    "content-type": "application/json",
    "x-fixture-source": "offline"
  },
  "body": "{\"artist\":\"Boards of Canada\"}",
  "recordedAt": "2024-01-01T00:00:00.000Z"
}
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
A packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing to run tests with environment considerations**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/fixtureHarness.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 9.86s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ packages/providers/core/test/fixtureHarness.test.ts (2 tests | 2 failed) 47ms
   × fixtureHarness > replays stored responses when PROVIDER_FIXTURES=1 24ms
     → ENOENT: no such file or directory, open '/var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/https___fixtures_test_artist.json'
   × fixtureHarness > records fixtures with status and headers when PROVIDER_RECORD=1 21ms
     → expected [] to have a length of 1 but got +0

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  packages/providers/core/test/fixtureHarness.test.ts > fixtureHarness > replays stored responses when PROVIDER_FIXTURES=1
Error: ENOENT: no such file or directory, open '/var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/https___fixtures_test_artist.json'
 ❯ fetchFx packages/providers/core/test/fixtureHarness.ts:15:21
     13|   const file = path.join(DIR, key(url) + '.json');
     14|   if (MODE === 'replay') {
     15|     const body = fs.readFileSync(file, 'utf8');
       |                     ^
     16|     return new Response(body, { status: 200, headers: { 'content-type'…
     17|   }
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Analyzing test failures and planning fixes**
exec
bash -lc "sed -n '1,200p' packages/providers/core/test/fixtureHarness.ts" in /var/home/rick/Development/playlist-manager succeeded in 55ms:
import fs from 'node:fs';
import path from 'node:path';

const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');

function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }

export async function fetchFx(url: string, init?: RequestInit) {
  if (MODE === 'live') return fetch(url, init);

  const file = path.join(DIR, key(url) + '.json');
  if (MODE === 'replay') {
    const body = fs.readFileSync(file, 'utf8');
    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
  }

  // record
  const resp = await fetch(url, init);
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Designing deterministic fixture harness**

I'm outlining a comprehensive fixture harness that reads, writes, and replays HTTP responses with deterministic headers by filtering out dynamic ones like 'date' and sorting keys. I'll implement environment-controlled modes (live, record, replay), directory resolution, and safe file handling, ensuring consistent and test-friendly fixtures while staying flexible about header inclusion. This plan includes rewriting the entire file with clear modular functions and sync filesystem calls for simplicity.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtureHarness.ts
@@ -3,23 +3,107 @@
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M packages/providers/core/test/fixtureHarness.ts
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..6859d85fddb8b2e2ab32f41e40663143f299815a
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..6859d85fddb8b2e2ab32f41e40663143f299815a
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying type imports and utility usage**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/playlist-manager succeeded in 55ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": []
}
file update:
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..6859d85fddb8b2e2ab32f41e40663143f299815a
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Adding test:update-fixtures script**
file update
M /var/home/rick/Development/playlist-manager/package.json
@@ -30,3 +30,4 @@
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M package.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..6859d85fddb8b2e2ab32f41e40663143f299815a
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..6859d85fddb8b2e2ab32f41e40663143f299815a
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toUpperCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Adjusting HTTP method casing for fixture files**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtureHarness.ts
@@ -45,3 +45,3 @@
 const fixturePath = (url: string, init?: RequestInit): string => {
-  const method = (init?.method ?? 'GET').toUpperCase();
+  const method = (init?.method ?? 'GET').toLowerCase();
   return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M packages/providers/core/test/fixtureHarness.ts
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying fixture recording details**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/fixtureHarness.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.44s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ packages/providers/core/test/fixtureHarness.test.ts (2 tests | 1 failed) 49ms
   × fixtureHarness > replays stored responses when PROVIDER_FIXTURES=1 21ms
     → [fixtureHarness] Missing fixture "/var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.
   ✓ fixtureHarness > records fixtures with status and headers when PROVIDER_RECORD=1 26ms

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  packages/providers/core/test/fixtureHarness.test.ts > fixtureHarness > replays stored responses when PROVIDER_FIXTURES=1
Error: [fixtureHarness] Missing fixture "/var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.
 ❯ loadFixture packages/providers/core/test/fixtureHarness.ts:71:11
     69| const loadFixture = (file: string): FixtureRecord => {
     70|   if (!fs.existsSync(file)) {
     71|     throw new Error(
       |           ^
     72|       `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDE…
     73|     );
 ❯ fetchFx packages/providers/core/test/fixtureHarness.ts:94:20
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Aligning fixture filenames with sanitizer**
file update
D /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
{
  "url": "https://fixtures.test/artist",
  "method": "GET",
  "status": 206,
  "headers": {
    "content-type": "application/json",
    "x-fixture-source": "offline"
  },
  "body": "{\"artist\":\"Boards of Canada\"}",
  "recordedAt": "2024-01-01T00:00:00.000Z"
}
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
D packages/providers/core/test/fixtures/get_https___fixtures_test_artist.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }


thinking
**Adding duplicate file with same content**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
{
  "url": "https://fixtures.test/artist",
  "method": "GET",
  "status": 206,
  "headers": {
    "content-type": "application/json",
    "x-fixture-source": "offline"
  },
  "body": "{\"artist\":\"Boards of Canada\"}",
  "recordedAt": "2024-01-01T00:00:00.000Z"
}
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
A packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Rerunning tests**
exec
bash -lc 'pnpm vitest run packages/providers/core/test/fixtureHarness.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 4.18s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ packages/providers/core/test/fixtureHarness.test.ts (2 tests) 54ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  21:01:33
   Duration  726ms (transform 81ms, setup 0ms, collect 53ms, tests 54ms, environment 0ms, prepare 123ms)

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Updating test plan status**
Plan update
  ✓ Understand existing provider fixture harness and requirements from task spec.
  ✓ Add failing tests covering record/replay fixture harness behavior and fixture update script expectations.
  → Implement harness updates, fixture storage, and package scripts to satisfy tests, then run tests/prepare commit.
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying fixture update integration**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 69ms:
## main...origin/main [ahead 7]
 M package.json
 M packages/providers/core/test/fixtureHarness.ts
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
?? packages/providers/core/test/fixtureHarness.test.ts
?? packages/providers/core/test/fixtures/
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing commit and test strategy**
exec
bash -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager exited 1 in 8.76s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ apps/api/src/routes/__tests__/auth.providers.test.ts (2 tests | 1 failed) 189ms
   ✓ GET /auth/providers > omits providers that are disabled via flags 61ms
   × feature guard middleware > blocks provider-dependent routes when a provider is disabled 124ms
     → Failed to load url nanoid (resolved id: nanoid) in /var/home/rick/Development/playlist-manager/apps/api/src/plugins/errors.ts. Does the file exist?
 ✓ packages/providers/core/test/fixtureHarness.test.ts (2 tests) 70ms
 ✓ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests) 51ms
 ✓ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests) 51ms
 ✓ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 61ms
 ✓ codex/code/codex/06f_provider_factory_tests/tests/providers.factory.test.ts (4 tests) 1566ms
   ✓ provider factory > getProviderAuthForUser: returns token and throws MissingProviderAuthError when missing  1373ms
 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 43ms
 ❯ apps/api/src/dev/__tests__/ensure-api-dev.test.ts (2 tests | 2 failed) 41ms
   × ensureApiDevServer > spawns the API when target port is free 29ms
     → listen EPERM: operation not permitted 127.0.0.1
   × ensureApiDevServer > attaches to an existing API when port is busy 4ms
     → listen EPERM: operation not permitted 127.0.0.1
 ✓ packages/interop/test/importers/file-importers.test.ts (8 tests) 61ms
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Reporting test failures due to environment issues**

I'll summarize that the full test suite fails because of missing dependencies and permission problems unrelated to our changes, while our targeted tests pass. I’m gathering specific failure details to include in the final message so the user can reproduce and understand these environment limitations.
Plan update
  ✓ Understand existing provider fixture harness and requirements from task spec.
  ✓ Add failing tests covering record/replay fixture harness behavior and fixture update script expectations.
  ✓ Implement harness updates, fixture storage, and package scripts to satisfy tests, then run tests/prepare commit.
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing files for commit**
exec
bash -lc 'git add package.json packages/providers/core/test/fixtureHarness.ts packages/providers/core/test/fixtureHarness.test.ts packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json' in /var/home/rick/Development/playlist-manager succeeded in 80ms:

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Checking git status for staged changes**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 67ms:
## main...origin/main [ahead 7]
M  package.json
A  packages/providers/core/test/fixtureHarness.test.ts
M  packages/providers/core/test/fixtureHarness.ts
A  packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
?? packages/providers/core/test/fixtures/https___record_test_data.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Investigating unexpected test fixture file**
exec
bash -lc 'ls packages/providers/core/test/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 64ms:
get_https_fixtures_test_artist.json
https___record_test_data.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Investigating unexpected test fixture file**
exec
bash -lc 'rm packages/providers/core/test/fixtures/https___record_test_data.json' in /var/home/rick/Development/playlist-manager succeeded in 57ms:

file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying file removal and git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 67ms:
## main...origin/main [ahead 7]
M  package.json
A  packages/providers/core/test/fixtureHarness.test.ts
M  packages/providers/core/test/fixtureHarness.ts
A  packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying staged changes**
exec
bash -lc 'git diff --staged' in /var/home/rick/Development/playlist-manager succeeded in 62ms:
diff --git a/package.json b/package.json
index 7dd4642..132e31b 100644
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000..11a9b8b
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing commit for fixture harness and tests**

I’m reviewing the fixture harness implementation and test script details, making sure type usage and header handling are sound. I’m also thinking through test script behaviors, environment variables, and fixture directory management. Finally, I’m shaping a clear commit message around adding the record/replay fixture harness for providers and ensuring the test suite is green despite known environment-related failures. I’m ready to commit these carefully staged changes next.
exec
bash -lc 'git commit -m "test(providers): add offline fixture harness"' in /var/home/rick/Development/playlist-manager succeeded in 230ms:
[main 56219e0] test(providers): add offline fixture harness
 4 files changed, 210 insertions(+), 15 deletions(-)
 create mode 100644 packages/providers/core/test/fixtureHarness.test.ts
 create mode 100644 packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Verifying commit contents**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 131ms:
## main...origin/main [ahead 8]
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Summarizing test results and next steps**

I'll gather detailed test outcomes, noting that the targeted fixtureHarness.test.ts passes but full vitest run fails due to environment issues. I need to capture info about new fixture update scripts, environment variables, test file changes with line numbers, and provide a clear final summary including commit messages, modified files with line refs, and suggested logical next steps for resolving test failures.
exec
bash -lc 'nl -ba packages/providers/core/test/fixtureHarness.ts' in /var/home/rick/Development/playlist-manager succeeded in 194ms:
     1	import fs from 'node:fs';
     2	import path from 'node:path';
     3	
     4	type Mode = 'live' | 'record' | 'replay';
     5	
     6	interface FixtureRecord {
     7	  url: string;
     8	  method: string;
     9	  status: number;
    10	  headers: Record<string, string>;
    11	  body: string;
    12	  recordedAt: string;
    13	}
    14	
    15	const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
    16	const IGNORED_HEADERS = new Set([
    17	  'age',
    18	  'cache-control',
    19	  'connection',
    20	  'date',
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing to reference package.json lines**
exec
bash -lc "nl -ba package.json | sed -n '20,80p'" in /var/home/rick/Development/playlist-manager succeeded in 55ms:
    20	    "prisma:generate": "pnpm -F @app/db exec prisma generate",
    21	    "prisma:migrate:dev": "pnpm -F @app/db exec prisma migrate dev",
    22	    "prisma:migrate:deploy": "pnpm -F @app/db exec prisma migrate deploy",
    23	    "prisma:seed": "pnpm -F @app/db exec prisma db seed",
    24	    "prisma:studio": "pnpm -F @app/db exec prisma studio",
    25	    "db:health": "tsx packages/db/src/healthcheck.ts",
    26	    "check:gen": "pnpm run gen:types && git diff --exit-code -- packages/contracts/src/api.types.ts",
    27	    "test:contract:dredd:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && dredd openapi.yaml http://127.0.0.1:4010 --config dredd.yml\"",
    28	    "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
    29	    "api:dev": "tsx apps/api/src/dev/start.ts",
    30	    "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
    31	    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
    32	    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
    33	  },
    34	  "devDependencies": {
    35	    "@redocly/cli": "^1.25.0",
    36	    "@stoplight/prism-cli": "^5.7.0",
    37	    "concurrently": "^9.0.1",
    38	    "dredd": "^14.0.0",
    39	    "openapi-typescript": "^7.10.1",
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing to add line numbers for test file**
exec
bash -lc 'nl -ba packages/providers/core/test/fixtureHarness.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 64ms:
     1	import fs from 'node:fs';
     2	import os from 'node:os';
     3	import path from 'node:path';
     4	
     5	import { afterEach, describe, expect, it, vi } from 'vitest';
     6	
     7	const nativeFetch = globalThis.fetch;
     8	const defaultEnv = {
     9	  fixtures: process.env.PROVIDER_FIXTURES,
    10	  record: process.env.PROVIDER_RECORD,
    11	  dir: process.env.PROVIDER_FIXTURE_DIR,
    12	};
    13	
    14	async function loadHarness() {
    15	  vi.resetModules();
    16	  return import('./fixtureHarness');
    17	}
    18	
    19	const cleanupDirs = new Set<string>();
    20	
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}


thinking
**Preparing detailed summary and test report**
codex
**Summary**
- Wrapped provider test fetches in a proper record/replay harness with mode auto-detection, per-method fixture keys, overridable directories, header scrubbing for deterministic files, and clearer guidance when fixtures are missing `packages/providers/core/test/fixtureHarness.ts:4-109`.
- Added an offline JSON fixture so replay mode can be exercised without network `packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json:1`.
- Created Vitest coverage that proves replay ignores real fetches and record mode writes structured fixtures (including `PROVIDER_FIXTURE_DIR` overrides) `packages/providers/core/test/fixtureHarness.test.ts:1-99`.
- Introduced `pnpm test:update-fixtures` to wipe and re-record provider fixtures in one deterministic command `package.json:20-55`.

**Tests**
- `pnpm vitest run packages/providers/core/test/fixtureHarness.test.ts`
- `pnpm vitest run` *(fails: environment cannot resolve several modules including `nanoid`, `@prisma/client`, and `tweetnacl`; API dev tests cannot bind to 127.0.0.1 (EPERM); DB explain tests reference missing SQL files under `packages/scripts/explain`.)*

**Next Steps**
- 1) Install/generate the missing runtime deps (`nanoid`, `@prisma/client`, `tweetnacl`) or mock them so the full Vitest suite can resolve imports.
- 2) Provide the SQL files expected under `packages/scripts/explain/*.sql` or skip those DB explain tests.
- 3) Run the suite on a host that allows binding to 127.0.0.1 for the API dev server tests, or guard those tests behind a capability check.

Commit
- `test(providers): add offline fixture harness`

Modified Files
- `package.json`
- `packages/providers/core/test/fixtureHarness.ts`
- `packages/providers/core/test/fixtureHarness.test.ts`
- `packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json`

Git Status
```
## main...origin/main [ahead 8]
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
```

Let me know if you want follow-up changes or help unblocking the failing suites.
file update:
diff --git a/package.json b/package.json
index 7dd4642208f837a221c9181e3c344e437a21f654..132e31bdc52a2d0e4acd193adc404b781c979319
--- a/package.json
+++ b/package.json
@@ -28,7 +28,8 @@
     "test:contract:st:prism": "concurrently -k -s first \"pnpm mock:api\" \"wait-on tcp:4010 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:4010 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
     "api:dev": "tsx apps/api/src/dev/start.ts",
     "test:contract:dredd:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && dredd openapi.yaml http://127.0.0.1:3101 --config dredd.server.yml\"",
-    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\""
+    "test:contract:st:server": "concurrently -k -s first \"API_FAKE_ENQUEUE=1 tsx apps/api/src/dev/ensure-api-dev.cli.ts\" \"wait-on tcp:3101 && docker run --rm --network=host -v $(pwd):/work -w /work docker.io/schemathesis/schemathesis:stable run openapi.yaml --url=http://127.0.0.1:3101 --phases=examples --checks not_a_server_error,status_code_conformance,content_type_conformance,response_headers_conformance,response_schema_conformance\"",
+    "test:update-fixtures": "node -e \"const fs=require('node:fs');const path=require('node:path');const dir=path.join(process.cwd(),'packages/providers/core/test/fixtures');fs.rmSync(dir,{recursive:true,force:true});\" && PROVIDER_RECORD=1 pnpm vitest run packages/providers"
   },
   "devDependencies": {
     "@redocly/cli": "^1.25.0",
diff --git a/packages/providers/core/test/fixtureHarness.test.ts b/packages/providers/core/test/fixtureHarness.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..11a9b8ba9349288ff79b2b69b26b2df146ed6e45
--- /dev/null
+++ b/packages/providers/core/test/fixtureHarness.test.ts
@@ -0,0 +1,99 @@
+import fs from 'node:fs';
+import os from 'node:os';
+import path from 'node:path';
+
+import { afterEach, describe, expect, it, vi } from 'vitest';
+
+const nativeFetch = globalThis.fetch;
+const defaultEnv = {
+  fixtures: process.env.PROVIDER_FIXTURES,
+  record: process.env.PROVIDER_RECORD,
+  dir: process.env.PROVIDER_FIXTURE_DIR,
+};
+
+async function loadHarness() {
+  vi.resetModules();
+  return import('./fixtureHarness');
+}
+
+const cleanupDirs = new Set<string>();
+
+afterEach(() => {
+  cleanupDirs.forEach((dir) => {
+    try {
+      fs.rmSync(dir, { recursive: true, force: true });
+    } catch (err) {
+      if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err;
+    }
+  });
+  cleanupDirs.clear();
+
+  if (nativeFetch) {
+    globalThis.fetch = nativeFetch;
+  }
+  vi.restoreAllMocks();
+
+  if (defaultEnv.fixtures === undefined) delete process.env.PROVIDER_FIXTURES;
+  else process.env.PROVIDER_FIXTURES = defaultEnv.fixtures;
+
+  if (defaultEnv.record === undefined) delete process.env.PROVIDER_RECORD;
+  else process.env.PROVIDER_RECORD = defaultEnv.record;
+
+  if (defaultEnv.dir === undefined) delete process.env.PROVIDER_FIXTURE_DIR;
+  else process.env.PROVIDER_FIXTURE_DIR = defaultEnv.dir;
+});
+
+describe('fixtureHarness', () => {
+  it('replays stored responses when PROVIDER_FIXTURES=1', async () => {
+    process.env.PROVIDER_FIXTURES = '1';
+    const fetchSpy = vi.spyOn(globalThis, 'fetch');
+    const { fetchFx } = await loadHarness();
+
+    const resp = await fetchFx('https://fixtures.test/artist');
+    expect(fetchSpy).not.toHaveBeenCalled();
+    expect(resp.status).toBe(206);
+    expect(resp.headers.get('x-fixture-source')).toBe('offline');
+    await expect(resp.json()).resolves.toEqual({ artist: 'Boards of Canada' });
+  });
+
+  it('records fixtures with status and headers when PROVIDER_RECORD=1', async () => {
+    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'provider-fixtures-'));
+    cleanupDirs.add(tmpDir);
+
+    process.env.PROVIDER_RECORD = '1';
+    process.env.PROVIDER_FIXTURE_DIR = tmpDir;
+
+    const fetchMock = vi.fn().mockResolvedValue(
+      new Response(JSON.stringify({ captured: true }), {
+        status: 201,
+        headers: {
+          'content-type': 'application/json',
+          'x-test': 'fixture',
+        },
+      }),
+    );
+    globalThis.fetch = fetchMock as typeof globalThis.fetch;
+
+    const { fetchFx } = await loadHarness();
+    const resp = await fetchFx('https://record.test/data', { method: 'POST' });
+
+    expect(fetchMock).toHaveBeenCalledTimes(1);
+    expect(resp.status).toBe(201);
+    await expect(resp.json()).resolves.toEqual({ captured: true });
+
+    const files = fs.readdirSync(tmpDir);
+    expect(files).toHaveLength(1);
+
+    const recorded = JSON.parse(fs.readFileSync(path.join(tmpDir, files[0]), 'utf8'));
+    expect(recorded).toMatchObject({
+      url: 'https://record.test/data',
+      method: 'POST',
+      status: 201,
+      headers: {
+        'content-type': 'application/json',
+        'x-test': 'fixture',
+      },
+      body: '{"captured":true}',
+    });
+  });
+});
diff --git a/packages/providers/core/test/fixtureHarness.ts b/packages/providers/core/test/fixtureHarness.ts
index 8e3d9282e0227f155e823e38d4ab5c5f0d580c76..f08c0cc6ef3b5147eb3f8ec39189772d9bd9fb01
--- a/packages/providers/core/test/fixtureHarness.ts
+++ b/packages/providers/core/test/fixtureHarness.ts
@@ -1,25 +1,109 @@
 import fs from 'node:fs';
 import path from 'node:path';
 
-const MODE = process.env.PROVIDER_FIXTURES === '1' ? 'replay' :
-             process.env.PROVIDER_RECORD === '1' ? 'record' : 'live';
-const DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+type Mode = 'live' | 'record' | 'replay';
+
+interface FixtureRecord {
+  url: string;
+  method: string;
+  status: number;
+  headers: Record<string, string>;
+  body: string;
+  recordedAt: string;
+}
+
+const DEFAULT_FIXTURE_DIR = path.join(process.cwd(), 'packages/providers/core/test/fixtures');
+const IGNORED_HEADERS = new Set([
+  'age',
+  'cache-control',
+  'connection',
+  'date',
+  'etag',
+  'keep-alive',
+  'last-modified',
+  'server',
+  'set-cookie',
+  'transfer-encoding',
+  'via',
+]);
+
+const sanitize = (input: string): string =>
+  input.replace(/[^a-z0-9]+/gi, '_').replace(/^_+|_+$/g, '').toLowerCase();
+
+const getMode = (): Mode => {
+  if (process.env.PROVIDER_RECORD === '1') return 'record';
+  if (process.env.PROVIDER_FIXTURES === '1') return 'replay';
+  return 'live';
+};
+
+const resolveDir = (): string => {
+  const custom = process.env.PROVIDER_FIXTURE_DIR;
+  if (!custom) return DEFAULT_FIXTURE_DIR;
+  return path.isAbsolute(custom) ? custom : path.join(process.cwd(), custom);
+};
+
+const fixturePath = (url: string, init?: RequestInit): string => {
+  const method = (init?.method ?? 'GET').toLowerCase();
+  return path.join(resolveDir(), `${method}_${sanitize(url)}.json`);
+};
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true });
+};
+
+const headersToObject = (headers: Headers): Record<string, string> => {
+  const result = new Map<string, string>();
+  headers.forEach((value, key) => {
+    const normalized = key.toLowerCase();
+    if (IGNORED_HEADERS.has(normalized)) return;
+    result.set(normalized, result.has(normalized) ? `${result.get(normalized)}, ${value}` : value);
+  });
+  return Array.from(result.entries())
+    .sort(([a], [b]) => a.localeCompare(b))
+    .reduce<Record<string, string>>((acc, [key, value]) => {
+      acc[key] = value;
+      return acc;
+    }, {});
+};
+
+const loadFixture = (file: string): FixtureRecord => {
+  if (!fs.existsSync(file)) {
+    throw new Error(
+      `[fixtureHarness] Missing fixture "${file}". Re-run with PROVIDER_RECORD=1 or pnpm test:update-fixtures.`,
+    );
+  }
+  return JSON.parse(fs.readFileSync(file, 'utf8')) as FixtureRecord;
+};
+
+const saveFixture = (file: string, record: FixtureRecord) => {
+  ensureDir(path.dirname(file));
+  fs.writeFileSync(file, `${JSON.stringify(record, null, 2)}\n`);
+};
 
-function key(url: string) { return url.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }
+const respond = (record: FixtureRecord): Response => new Response(record.body, {
+  status: record.status,
+  headers: record.headers,
+});
 
 export async function fetchFx(url: string, init?: RequestInit) {
-  if (MODE === 'live') return fetch(url, init);
+  const mode = getMode();
+  if (mode === 'live') return fetch(url, init);
 
-  const file = path.join(DIR, key(url) + '.json');
-  if (MODE === 'replay') {
-    const body = fs.readFileSync(file, 'utf8');
-    return new Response(body, { status: 200, headers: { 'content-type': 'application/json' } });
+  const file = fixturePath(url, init);
+  if (mode === 'replay') {
+    return respond(loadFixture(file));
   }
 
-  // record
   const resp = await fetch(url, init);
-  const text = await resp.text();
-  fs.mkdirSync(DIR, { recursive: true });
-  fs.writeFileSync(file, text);
-  return new Response(text, { status: resp.status, headers: resp.headers });
+  const body = await resp.text();
+  const record: FixtureRecord = {
+    url,
+    method: (init?.method ?? 'GET').toUpperCase(),
+    status: resp.status,
+    headers: headersToObject(resp.headers),
+    body,
+    recordedAt: new Date().toISOString(),
+  };
+  saveFixture(file, record);
+  return respond(record);
 }
diff --git a/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
new file mode 100644
index 0000000000000000000000000000000000000000..80027f9112ddf6155bebba520e39a1498bf556c1
--- /dev/null
+++ b/packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json
@@ -0,0 +1,11 @@
+{
+  "url": "https://fixtures.test/artist",
+  "method": "GET",
+  "status": 206,
+  "headers": {
+    "content-type": "application/json",
+    "x-fixture-source": "offline"
+  },
+  "body": "{\"artist\":\"Boards of Canada\"}",
+  "recordedAt": "2024-01-01T00:00:00.000Z"
+}

tokens used
73,858
**Summary**
- Wrapped provider test fetches in a proper record/replay harness with mode auto-detection, per-method fixture keys, overridable directories, header scrubbing for deterministic files, and clearer guidance when fixtures are missing `packages/providers/core/test/fixtureHarness.ts:4-109`.
- Added an offline JSON fixture so replay mode can be exercised without network `packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json:1`.
- Created Vitest coverage that proves replay ignores real fetches and record mode writes structured fixtures (including `PROVIDER_FIXTURE_DIR` overrides) `packages/providers/core/test/fixtureHarness.test.ts:1-99`.
- Introduced `pnpm test:update-fixtures` to wipe and re-record provider fixtures in one deterministic command `package.json:20-55`.

**Tests**
- `pnpm vitest run packages/providers/core/test/fixtureHarness.test.ts`
- `pnpm vitest run` *(fails: environment cannot resolve several modules including `nanoid`, `@prisma/client`, and `tweetnacl`; API dev tests cannot bind to 127.0.0.1 (EPERM); DB explain tests reference missing SQL files under `packages/scripts/explain`.)*

**Next Steps**
- 1) Install/generate the missing runtime deps (`nanoid`, `@prisma/client`, `tweetnacl`) or mock them so the full Vitest suite can resolve imports.
- 2) Provide the SQL files expected under `packages/scripts/explain/*.sql` or skip those DB explain tests.
- 3) Run the suite on a host that allows binding to 127.0.0.1 for the API dev server tests, or guard those tests behind a capability check.

Commit
- `test(providers): add offline fixture harness`

Modified Files
- `package.json`
- `packages/providers/core/test/fixtureHarness.ts`
- `packages/providers/core/test/fixtureHarness.test.ts`
- `packages/providers/core/test/fixtures/get_https_fixtures_test_artist.json`

Git Status
```
## main...origin/main [ahead 8]
?? codex/LOGS/codex_run_2025-11-06_20-55-45.log
?? codex/LOGS/tasklog_06h_provider_fixture_harness_1762480545.log
?? codex/TASKS/work_list
```

Let me know if you want follow-up changes or help unblocking the failing suites.
