OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a5835-74a7-7b51-b14b-359603c02a3c
--------
user
Implement the functionality described in codex/TASKS/06d_tidal_impl.yaml, then verify with any available tests.

thinking
**Resolving commit and push instruction conflicts**
exec
bash -lc 'cat codex/TASKS/06d_tidal_impl.yaml' in /var/home/rick/Development/playlist-manager/. succeeded in 93ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
id: 06d_tidal_impl
title: TIDAL importer/exporter (mocked HTTP) to/from PIF
branch: codex/06d_tidal_impl
overview: >
  Implement TIDAL Importer/Exporter with mocked API responses. Handle pagination and track add batches.
acceptance:
  - Tests in codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts pass:
    * importer extracts ISRC from track.isrc or externalIds.
    * exporter creates playlist, then adds items in batches; verifies 429 backoff logic.
artifacts_to_touch:
  - packages/providers/tidal/src/index.ts
  - packages/providers/tidal/src/tidal.client.ts
  - codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json
constraints:
  - No network; use nock targeting https://api.tidal.com/v1/*
tests:
  path: codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
  content: |

thinking
**Exploring Tidal provider code**
exec
bash -lc 'ls packages/providers/tidal/src' in /var/home/rick/Development/playlist-manager/. succeeded in 120ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
index.ts

thinking
**Opening file**
exec
bash -lc 'cat packages/providers/tidal/src/index.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 52ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class Tidal implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'tidal';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');

thinking
**Planning Tidal client implementation**
exec
bash -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager/. succeeded in 59ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
core
deezer
file-exporters
spotify
tidal
youtube

thinking
**Checking example indexes**
exec
bash -lc 'cat packages/providers/spotify/src/index.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 57ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  BackoffOptions,
  Exporter,
  Importer,
  PIF,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';
import { RateLimitError } from '@app/contracts';

import {
  SpotifyClient,
  type SpotifyPlaylist,
  type SpotifyPlaylistItem,

thinking
**Preparing to implement Tidal importer/exporter**
exec
bash -lc "sed -n '1,160p' codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts" in /var/home/rick/Development/playlist-manager/. exited 2 in 59ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
sed: can't read codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts: No such file or directory

thinking
**Listing codex and code directories**
exec
bash -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager/. succeeded in 77ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
codex

thinking
**Listing contents**
exec
bash -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager/. succeeded in 58ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces
06b_spotify_impl
06c_deezer_impl

thinking
**Investigating test file location and creation**
exec
bash -lc 'ls codex/code/codex/06b_spotify_impl/tests' in /var/home/rick/Development/playlist-manager/. succeeded in 55ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
fixtures
spotify.impl.test.ts

thinking
**Preparing TDD plan for new directory**
Plan update
  → Review existing provider implementations and task requirements
  • Add failing tests per task in codex/code/codex/06d_tidal_impl/tests and run to observe failure
  • Implement Tidal client and importer/exporter to satisfy tests
  • Run full test suite (or relevant subset) to confirm pass
  • Prepare and create commit with descriptive message

thinking
**Updating plan after step completion**
Plan update
  ✓ Review existing provider implementations and task requirements
  → Add failing tests per task in codex/code/codex/06d_tidal_impl/tests and run to observe failure
  • Implement Tidal client and importer/exporter to satisfy tests
  • Run full test suite (or relevant subset) to confirm pass
  • Prepare and create commit with descriptive message

thinking
**Setting up test directory and fixture**
exec
bash -lc 'mkdir -p codex/code/codex/06d_tidal_impl/tests/fixtures' in /var/home/rick/Development/playlist-manager/. succeeded in 92ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Preparing to create test file**
exec
bash -lc "cat <<'EOF' > codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
import nock from 'nock';
import { expect, test } from 'vitest';
import Tidal from '../../../../packages/providers/tidal/src';

const td = new Tidal({ token: 't' });

test('importer -> maps tidal to PIF with isrc when present', async () => {
  nock('https://api.tidal.com')
    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
      items: [
        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
      ]
    });
  const pif = await td.readPlaylist({ id: 'ab12' });
  expect(pif.tracks[0].isrc).toBe('USX1');
  expect(pif.tracks[1].artists[0]).toBe('BB');
});

test('exporter -> batch add handling', async () => {
  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
  nock('https://api.tidal.com')
    .post('/v1/playlists').reply(200, { uuid: 'U123' })
    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
  const res = await td.writePlaylist({ pif });
  expect(res.destId).toBe('U123');
});
EOF
" in /var/home/rick/Development/playlist-manager/. succeeded in 64ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

thinking
**Verifying method signature usage**
exec
bash -lc "sed -n '1,160p' codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 73ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import nock from 'nock';
import path from 'node:path';
import { readFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import Spotify from '../../../../../packages/providers/spotify/src/index.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const loadFixture = (name: string) =>
  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));

describe('Spotify provider integration', () => {
  const baseUrl = 'https://api.spotify.com';

  beforeEach(() => {

thinking
**Examining readPlaylist signature in contracts**
exec
bash -lc "sed -n '1,200p' packages/contracts/src/index.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export * from './pif';
export * from './providers';

thinking
**Reviewing provider definitions**
exec
bash -lc "sed -n '1,200p' packages/contracts/src/providers.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 72ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
// packages/contracts/src/providers.ts

/** Canonical provider IDs used across the app & OpenAPI spec */
export type ProviderName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

/** Minimal PIF v1 types (keep in sync with /schemas/pif-v1.schema.json) */
export interface PIF {
  name: string;
  description?: string | null;
  source_service?: ProviderName | 'amazon' | null;
  source_playlist_id?: string | null;
  tracks: PIFTrack[];
}

export interface PIFTrack {
  position: number;                // 1-based
  title: string;
  artists: string[];               // primary first; features after

thinking
**Examining readPlaylist signature mismatch**
exec
bash -lc "sed -n '1,160p' codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 45ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { afterEach, beforeEach, expect, test, vi } from 'vitest';
import nock from 'nock';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import Deezer from '../../../../../packages/providers/deezer/src/index.ts';

import playlistFixture from './fixtures/deezer.playlist.json';
import createdFixture from './fixtures/deezer.created.json';

const baseUrl = 'https://api.deezer.com';

beforeEach(() => {
  nock.disableNetConnect();
});

afterEach(() => {
  nock.cleanAll();
  nock.enableNetConnect();

thinking
**Evaluating readPlaylist signature and test alignment**

I'm weighing the mismatch between the current `readPlaylist` method expecting a string versus the user-provided test calling it with an object. This could cause TypeScript errors unless we adjust either the method signature or the tests. I want to check existing Tidal provider code and fixtures to align implementation and tests properly while supporting key features like ISRC extraction and API rate-limit handling. Let's explore other providers too for patterns that might help.
exec
bash -lc "sed -n '1,200p' packages/providers/deezer/src/index.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import type {
  Exporter,
  Importer,
  PIF,
  PIFTrack,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

import {
  DeezerClient,
  type DeezerTrack,
} from './deezer.client.ts';


thinking
**Planning Tidal client and tests**

I’m gathering information to build a Tidal client similar to Deezer’s by examining its code. I want to define test fixtures that represent playlists and tracks, focusing on key fields like ISRC. The tests will follow interface signatures and cover features like batch adding and handling rate limits. I’m curious how closely I can mirror the existing patterns for Tidal.
exec
bash -lc "sed -n '1,200p' packages/providers/deezer/src/deezer.client.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { RateLimitError } from '@app/contracts';

export interface DeezerClientOptions {
  token: string;
  baseUrl?: string;
  retries?: number;
}

export interface DeezerPlaylistMetadata {
  id?: string | number;
  title?: string | null;
  description?: string | null;
  nb_tracks?: number | null;
}

export interface DeezerArtist {
  id?: string | number;
  name?: string | null;

thinking
**Preparing and adjusting Tidal tests**

I’m working through the test setup for the Tidal provider, refining imports to use correct relative paths with `.ts` extensions, adding before/after hooks for nock to simulate rate limits, and aligning the readPlaylist calls with the expected interface. I’m also planning to enhance test coverage around importer mapping and 429 backoff to make sure everything behaves as intended.
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,115 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
+
+const baseUrl = 'https://api.tidal.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, { name: 'T', description: 'tidal mix', numberOfTracks: 2 })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, {
       items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
+        {
+          track: {
+            id: 't1',
+            title: 'A',
+            isrc: 'USX1',
+            artists: [{ name: 'AA' }],
+            album: { title: 'AL' },
+            duration: 123000,
+          },
+        },
+        {
+          track: {
+            id: 't2',
+            title: 'B',
+            artists: [{ name: 'BB' }],
+            album: { title: 'BL' },
+            duration: 1000,
+            externalIds: { isrc: 'USX2' },
+          },
+        },
+      ],
     });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..386a311e99c03d8bb6e7608ffb69c7bdb9431b93
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,115 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
+
+const baseUrl = 'https://api.tidal.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, { name: 'T', description: 'tidal mix', numberOfTracks: 2 })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, {
       items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
+        {
+          track: {
+            id: 't1',
+            title: 'A',
+            isrc: 'USX1',
+            artists: [{ name: 'AA' }],
+            album: { title: 'AL' },
+            duration: 123000,
+          },
+        },
+        {
+          track: {
+            id: 't2',
+            title: 'B',
+            artists: [{ name: 'BB' }],
+            album: { title: 'BL' },
+            duration: 1000,
+            externalIds: { isrc: 'USX2' },
+          },
+        },
+      ],
     });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..386a311e99c03d8bb6e7608ffb69c7bdb9431b93
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,115 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
+
+const baseUrl = 'https://api.tidal.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, { name: 'T', description: 'tidal mix', numberOfTracks: 2 })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, {
       items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
+        {
+          track: {
+            id: 't1',
+            title: 'A',
+            isrc: 'USX1',
+            artists: [{ name: 'AA' }],
+            album: { title: 'AL' },
+            duration: 123000,
+          },
+        },
+        {
+          track: {
+            id: 't2',
+            title: 'B',
+            artists: [{ name: 'BB' }],
+            album: { title: 'BL' },
+            duration: 1000,
+            externalIds: { isrc: 'USX2' },
+          },
+        },
+      ],
     });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Preparing test fixture creation**
exec
bash -lc "cat <<'EOF' > codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json
{
  \"name\": \"T\",
  \"description\": \"tidal mix\",
  \"numberOfTracks\": 2,
  \"items\": [
    {
      \"track\": {
        \"id\": \"t1\",
        \"title\": \"A\",
        \"isrc\": \"USX1\",
        \"artists\": [{ \"name\": \"AA\" }],
        \"album\": { \"title\": \"AL\" },
        \"duration\": 123000
      }
    },
    {
      \"track\": {
        \"id\": \"t2\",
        \"title\": \"B\",
        \"artists\": [{ \"name\": \"BB\" }],
        \"album\": { \"title\": \"BL\" },
        \"duration\": 1000,
        \"externalIds\": { \"isrc\": \"USX2\" }
      }
    }
  ]
}
EOF
" in /var/home/rick/Development/playlist-manager/. succeeded in 72ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..386a311e99c03d8bb6e7608ffb69c7bdb9431b93
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,115 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
+
+const baseUrl = 'https://api.tidal.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, { name: 'T', description: 'tidal mix', numberOfTracks: 2 })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, {
       items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
+        {
+          track: {
+            id: 't1',
+            title: 'A',
+            isrc: 'USX1',
+            artists: [{ name: 'AA' }],
+            album: { title: 'AL' },
+            duration: 123000,
+          },
+        },
+        {
+          track: {
+            id: 't2',
+            title: 'B',
+            artists: [{ name: 'BB' }],
+            album: { title: 'BL' },
+            duration: 1000,
+            externalIds: { isrc: 'USX2' },
+          },
+        },
+      ],
     });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Updating test file imports**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1 +1,5 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
 import { afterEach, beforeEach, expect, test, vi } from 'vitest';
@@ -6,2 +10,7 @@
 const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
 
@@ -20,31 +29,14 @@
 
+  const playlist = loadFixture('tidal.playlist.json');
+
   nock(baseUrl)
     .get('/v1/playlists/ab12')
-    .reply(200, { name: 'T', description: 'tidal mix', numberOfTracks: 2 })
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
     .get('/v1/playlists/ab12/tracks')
     .query({ limit: 100, offset: 0 })
-    .reply(200, {
-      items: [
-        {
-          track: {
-            id: 't1',
-            title: 'A',
-            isrc: 'USX1',
-            artists: [{ name: 'AA' }],
-            album: { title: 'AL' },
-            duration: 123000,
-          },
-        },
-        {
-          track: {
-            id: 't2',
-            title: 'B',
-            artists: [{ name: 'BB' }],
-            album: { title: 'BL' },
-            duration: 1000,
-            externalIds: { isrc: 'USX2' },
-          },
-        },
-      ],
-    });
+    .reply(200, { items: playlist.items });
 
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..1a0dfc7ce7dbaec72a4e9a0847707a965a577dcc
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..1a0dfc7ce7dbaec72a4e9a0847707a965a577dcc
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Preparing to run tests**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/playlist-manager/. succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
{
  "name": "playlist-manager",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "packageManager": "pnpm@9.12.3",
  "engines": {
    "node": ">=18.18"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "lint:api": "redocly lint openapi.yaml --extends recommended",
    "gen:types": "openapi-typescript openapi.yaml -o packages/contracts/src/api.types.ts",
    "mock:api": "prism mock openapi.yaml",
    "check:breaking": "oasdiff breaking origin:openapi.yaml openapi.yaml --warn-added",
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..1a0dfc7ce7dbaec72a4e9a0847707a965a577dcc
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Preparing to run tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. exited 1 in 2.52s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager


⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts [ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts ]
Error: Failed to load url ../../../../packages/providers/tidal/src/index.ts (resolved id: ../../../../packages/providers/tidal/src/index.ts) in /var/home/rick/Development/playlist-manager/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts. Does the file exist?
 ❯ loadAndTransform node_modules/vite/dist/node/chunks/dep-Bid9ssRr.js:41317:17

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  no tests
   Start at  03:10:21
   Duration  560ms (transform 78ms, setup 0ms, collect 0ms, tests 0ms, environment 0ms, prepare 102ms)

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..1a0dfc7ce7dbaec72a4e9a0847707a965a577dcc
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Correcting import path levels**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -7,3 +7,3 @@
 
-import Tidal from '../../../../packages/providers/tidal/src/index.ts';
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Preparing to rerun tests**
exec
bash -lc 'pnpm vitest run codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. exited 1 in 2.64s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

(node:458945) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 2)
(Use `node --trace-warnings ...` to show where the warning was created)
 ❯ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests | 2 failed) 15ms
   × importer maps tidal playlist tracks into PIF, preferring track.isrc 8ms
     → NIY
   × exporter creates playlist and adds tracks in batches with backoff on 429 5ms
     → NIY

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts > importer maps tidal playlist tracks into PIF, preferring track.isrc
Error: NIY
 ❯ Tidal.readPlaylist packages/providers/tidal/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Planning Tidal client implementation**
exec
bash -lc 'ls packages/providers/core/src' in /var/home/rick/Development/playlist-manager/. succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
http
index.ts
match
types.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Verifying HTTP client usage**
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/http/index.ts" in /var/home/rick/Development/playlist-manager/. exited 2 in 56ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
sed: can't read packages/providers/core/src/http/index.ts: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Listing items**
exec
bash -lc 'ls packages/providers/core/src/http' in /var/home/rick/Development/playlist-manager/. succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
client.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Opening file**
exec
bash -lc "sed -n '1,200p' packages/providers/core/src/http/client.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 54ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
export type HttpMethod = 'GET'|'POST'|'PUT'|'PATCH'|'DELETE';

export interface HttpClientOptions {
  baseUrl: string;
  headers?: Record<string, string>;
  getAuthHeader?: () => Promise<string | undefined>;
  retries?: number;
  retryBaseMs?: number;
}

function sleep(ms: number) { return new Promise((r) => setTimeout(r, ms)); }

export class HttpClient {
  constructor(private opts: HttpClientOptions) {}

  async request<T>(method: HttpMethod, url: string, init?: RequestInit): Promise<T> {
    const { retries = 3, retryBaseMs = 300 } = this.opts;
    let attempt = 0;
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });


thinking
**Planning Tidal client implementation**
exec
bash -lc "sed -n '1,200p' packages/providers/spotify/src/spotify.client.ts" in /var/home/rick/Development/playlist-manager/. succeeded in 58ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
import { RateLimitError } from '@app/contracts';

export interface SpotifyClientOptions {
  token: string;
  baseUrl?: string;
}

export interface SpotifyUserProfile {
  id: string;
}

export interface SpotifyArtist {
  name: string;
}

export interface SpotifyAlbum {
  name?: string | null;
  release_date?: string | null;
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });



thinking
**Designing Tidal provider implementation**
thinking
**Preparing new file creation**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/tidal/src/tidal.client.ts
import { RateLimitError } from '@app/contracts';

export interface TidalClientOptions {
  token: string;
  baseUrl?: string;
}

export interface TidalPlaylist {
  uuid?: string;
  name?: string | null;
  description?: string | null;
  numberOfTracks?: number | null;
}

export interface TidalArtist {
  name?: string | null;
}

export interface TidalAlbum {
  title?: string | null;
}

export interface TidalExternalIds {
  isrc?: string | null;
}

export interface TidalTrack {
  id?: string | null;
  title?: string | null;
  duration?: number | null;
  isrc?: string | null;
  artists?: TidalArtist[] | null;
  album?: TidalAlbum | null;
  externalIds?: TidalExternalIds | null;
}

export interface TidalTrackItem {
  track?: TidalTrack | null;
}

export interface TidalTrackPage {
  items?: TidalTrackItem[] | null;
}

const defaultBaseUrl = 'https://api.tidal.com';

const parseRetryAfter = (value: string | null): number | undefined => {
  if (!value) return undefined;
  const numeric = Number(value);
  if (Number.isFinite(numeric)) {
    return Math.max(0, numeric) * 1000;
  }
  const timestamp = Date.parse(value);
  if (!Number.isNaN(timestamp)) {
    return Math.max(0, timestamp - Date.now());
  }
  return undefined;
};

export class TidalClient {
  private readonly baseUrl: string;

  constructor(private readonly options: TidalClientOptions) {
    if (!options?.token) {
      throw new Error('Tidal token is required');
    }
    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
  }

  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
    const url = new URL(path, `${this.baseUrl}/`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value === undefined || value === null) continue;
        url.searchParams.set(key, String(value));
      }
    }
    return url.toString();
  }

  private async request<T>(
    method: 'GET' | 'POST',
    path: string,
    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
  ): Promise<T> {
    const url = this.buildUrl(path, options?.query);
    const headers: Record<string, string> = {
      authorization: `Bearer ${this.options.token}`,
    };
    const init: RequestInit = { method, headers };

    if (options?.body !== undefined) {
      headers['content-type'] = 'application/json';
      init.body = JSON.stringify(options.body);
    }

    const response = await fetch(url, init);

    if (response.status === 429) {
      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
    }

    if (!response.ok) {
      const message = await response.text().catch(() => response.statusText);
      throw new Error(`Tidal API ${response.status}: ${message}`);
    }

    if (response.status === 204) {
      return undefined as T;
    }

    const text = await response.text();
    if (!text) {
      return undefined as T;
    }

    try {
      return JSON.parse(text) as T;
    } catch {
      return undefined as T;
    }
  }

  getPlaylist(id: string): Promise<TidalPlaylist> {
    const encoded = encodeURIComponent(id);
    return this.request('GET', `/v1/playlists/${encoded}`);
  }

  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
    const encoded = encodeURIComponent(id);
    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
      query: {
        limit: opts.limit,
        offset: opts.offset,
      },
    });
  }

  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
    return this.request('POST', '/v1/playlists', { body: payload });
  }

  addPlaylistItems(
    playlistId: string,
    trackIds: string[],
  ): Promise<{ succeeded: number }> {
    const encoded = encodeURIComponent(playlistId);
    const items = trackIds.map((id) => ({ id }));
    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
  }
}
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A packages/providers/tidal/src/tidal.client.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Designing Tidal provider implementation**
file update
M /var/home/rick/Development/playlist-manager/packages/providers/tidal/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Tidal implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'tidal';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M packages/providers/tidal/src/index.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Tidal implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'tidal';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Tidal implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'tidal';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Inserting implementation with apply_patch**
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Tidal implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'tidal';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Preparing to add new file via patch**
exec
bash -lc 'cat packages/providers/tidal/src/index.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 38ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class Tidal implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'tidal';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Preparing to write file content**
exec
bash -lc "cat <<'EOF' > packages/providers/tidal/src/index.ts
import type {
  BackoffOptions,
  Exporter,
  Importer,
  PIF,
  PIFTrack,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';
import { RateLimitError } from '@app/contracts';

import {
  TidalClient,
  type TidalTrackItem,
} from './tidal.client.ts';

type Milliseconds = number;

const DEFAULT_PAGE_SIZE = 100;
const DEFAULT_BATCH_SIZE = 100;
const DEFAULT_BACKOFF: Required<BackoffOptions> = {
  retries: 3,
  baseDelayMs: 500,
  maxDelayMs: 8000,
};

const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));

const normalizePageSize = (pageSize: number | undefined): number => {
  if ("'!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
    return DEFAULT_PAGE_SIZE;
  }
  return Math.min(Math.trunc(pageSize), 100);
};

const normalizeBatchSize = (batchSize: number | undefined): number => {
  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
    return DEFAULT_BATCH_SIZE;
  }
  return Math.max(1, Math.trunc(batchSize));
};

const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
});

const toMilliseconds = (value: number | string | null | undefined): number | null => {
  if (value === undefined || value === null) return null;
  const numeric = Number(value);
  if (!Number.isFinite(numeric) || numeric <= 0) return null;
  if (numeric >= 1000) {
    return Math.round(numeric);
  }
  return Math.round(numeric * 1000);
};

const extractArtists = (item: TidalTrackItem): string[] => {
  const track = item?.track;
  if (!track?.artists) return [];
  return track.artists
    .map((artist) => artist?.name?.trim())
    .filter((name): name is string => Boolean(name));
};

const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
  const track = item?.track;
  if (!track?.title) {
    return undefined;
  }

  const artists = extractArtists(item);
  const artistList = artists.length > 0 ? artists : ['"'Unknown Artist'];

  const mapped: PIFTrack = {
    position: index + 1,
    title: track.title,
    artists: artistList,
    album: track.album?.title ?? null,
    duration_ms: toMilliseconds(track.duration),
    explicit: null,
    release_date: null,
    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
  };

  if (track.id) {
    mapped.provider_ids = { tidal_track_id: track.id };
  }

  return mapped;
};

interface TidalOptions {
  token?: string;
  auth?: ProviderAuth;
  baseUrl?: string;
}

export default class Tidal implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'tidal';

  private readonly options: TidalOptions;
  private client?: TidalClient;

  constructor(options?: TidalOptions) {
    this.options = options ?? {};
  }

  private ensureClient(): TidalClient {
    if (this.client) return this.client;
    const token = this.options.token ?? this.options.auth?.token;
    if ("'!token) {
      throw new Error('"'Tidal auth token is required');
    }
    this.client = new TidalClient({
      token,
      baseUrl: this.options.baseUrl,
    });
    return this.client;
  }

  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
    const client = this.ensureClient();
    const items: TidalTrackItem[] = [];
    let offset = 0;
    let iteration = 0;
    const maxIterations = 1000;

    while (iteration < maxIterations) {
      iteration += 1;
      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
      const pageItems = Array.isArray(page.items) ? page.items : [];
      if (pageItems.length === 0) {
        break;
      }

      items.push(...pageItems);

      if (pageItems.length < pageSize) {
        break;
      }

      offset += pageItems.length;
    }

    return items;
  }

  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
    const client = this.ensureClient();
    const pageSize = normalizePageSize(opts?.pageSize);

    const playlist = await client.getPlaylist(id);
    const items = await this.fetchAllTracks(id, pageSize);

    const tracks = items
      .map(mapTrack)
      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));

    return {
      name: playlist.name ?? 'Untitled Playlist',
      description: playlist.description ?? null,
      source_service: 'tidal',
      source_playlist_id: id,
      tracks,
    };
  }

  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
    let attempt = 0;

    while (true) {
      try {
        return await fn();
      } catch (error) {
        if ("'!(error instanceof RateLimitError)) {
          throw error;
        }

        if (attempt >= retries) {
          throw error;
        }

        const delay = Math.min(
          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
          maxDelayMs,
        );
        attempt += 1;
        await sleep(delay);
      }
    }
  }

  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
    const client = this.ensureClient();
    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);

    const created = await client.createPlaylist({
      name: pif.name,
      description: pif.description ?? null,
    });

    const playlistId = created.uuid;
    if (!playlistId) {
      throw new Error('"'Tidal playlist UUID missing from create response');
    }

    const trackIds: string[] = [];
    let skipped = 0;

    for (const track of pif.tracks) {
      const tidalId = track.provider_ids?.tidal_track_id;
      if ("'!tidalId) {
        skipped += 1;
        continue;
      }
      trackIds.push(tidalId);
    }

    let added = 0;

    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
      const batch = trackIds.slice(cursor, cursor + batchSize);
      const result = await this.runWithBackoff(
        () => client.addPlaylistItems(playlistId, batch),
        opts?.backoff,
      );
      const succeeded = result?.succeeded ?? batch.length;
      added += succeeded;
    }

    const report: WritePlaylistResult['"'report'] = {
      attempted: trackIds.length,
      added,
      failed: Math.max(0, trackIds.length - added),
    };

    if (skipped > 0) {
      report.skipped = skipped;
      report.notes = ["'`${skipped} track(s) missing tidal_track_id`];
    }

    return {
      destId: playlistId,
      report,
    };
  }
}
EOF
' in /var/home/rick/Development/playlist-manager/. succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..f3fc31c440d232964d3eb967e7cbc960142e6e1e
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = result?.succeeded ?? batch.length;
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Reviewing code and test strategy**

I’m making sure imports and types are handled correctly in the tidal provider code, checking array usage, default values, and type filters. I’m also considering improvements for pagination and edge cases in importing data. Before running tests, I want to mark earlier plan steps completed to keep progress clear.
Plan update
  ✓ Review existing provider implementations and task requirements
  ✓ Add failing tests per task in codex/code/codex/06d_tidal_impl/tests and run to observe failure
  → Implement Tidal client and importer/exporter to satisfy tests
  • Run full test suite (or relevant subset) to confirm pass
  • Prepare and create commit with descriptive message
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..f3fc31c440d232964d3eb967e7cbc960142e6e1e
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = result?.succeeded ?? batch.length;
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Running tests again**
exec
bash -lc 'pnpm vitest run codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 2.13s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests) 20ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  03:13:05
   Duration  498ms (transform 89ms, setup 0ms, collect 150ms, tests 20ms, environment 0ms, prepare 72ms)

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..f3fc31c440d232964d3eb967e7cbc960142e6e1e
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = result?.succeeded ?? batch.length;
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Updating plan status**
Plan update
  ✓ Review existing provider implementations and task requirements
  ✓ Add failing tests per task in codex/code/codex/06d_tidal_impl/tests and run to observe failure
  ✓ Implement Tidal client and importer/exporter to satisfy tests
  ✓ Run full test suite (or relevant subset) to confirm pass
  → Prepare and create commit with descriptive message
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..f3fc31c440d232964d3eb967e7cbc960142e6e1e
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = result?.succeeded ?? batch.length;
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Evaluating testing approach and code adjustments**

I'm considering whether to run the full test suite or just the targeted tests given the instructions say to verify with any available tests. I'll note running targeted tests for now but might mention full runs in the final message. Also, I'm reviewing code details like limiting the `succeeded` count to batch length to avoid inconsistencies and preparing to apply a patch to fix this inside the for loop.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/tidal/src/index.ts
@@ -233,3 +233,3 @@
       );
-      const succeeded = result?.succeeded ?? batch.length;
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
       added += succeeded;
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M packages/providers/tidal/src/index.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}

file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Reviewing track importing logic and test strategy**

I'll verify that the report's failed count never goes negative and that pagination and batch track additions handle correctly. I’m also planning to run the full test suite with `pnpm vitest run` to ensure all tests pass, as emphasized in the instructions, even if it takes more time.
exec
bash -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager/. exited 1 in 4.00s:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ apps/api/src/routes/__tests__/auth.providers.test.ts (2 tests | 1 failed) 94ms
   ✓ GET /auth/providers > omits providers that are disabled via flags 55ms
   × feature guard middleware > blocks provider-dependent routes when a provider is disabled 37ms
     → Failed to load url nanoid (resolved id: nanoid) in /var/home/rick/Development/playlist-manager/apps/api/src/plugins/errors.ts. Does the file exist?
 ✓ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 36ms
 ✓ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests) 22ms
 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 27ms
 ✓ packages/interop/test/importers/file-importers.test.ts (8 tests) 34ms
 ❯ apps/api/src/dev/__tests__/ensure-api-dev.test.ts (2 tests | 2 failed) 15ms
   × ensureApiDevServer > spawns the API when target port is free 12ms
     → listen EPERM: operation not permitted 127.0.0.1
   × ensureApiDevServer > attaches to an existing API when port is busy 2ms
     → listen EPERM: operation not permitted 127.0.0.1
 ✓ apps/api/src/routes/__tests__/docs.test.ts (3 tests) 14ms
 ❯ packages/db/test/healthcheck.cli.test.ts (2 tests | 2 failed) 23ms
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Documenting test suite limitations**

I’m noting that the full test suite fails due to missing dependencies and environment issues like lack of network, so I’ll explain this clearly in the final message. I’ll update the plan to reflect that step 4 is “completed” since we attempted it and step 5 as “in progress” before finalizing, ensuring the user understands the constraints affecting the test results.
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager/. succeeded in 146ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 3]
 M packages/providers/tidal/src/index.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/TASKS/work_list
?? codex/code/codex/06d_tidal_impl/
?? packages/providers/tidal/src/tidal.client.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Evaluating files to stage for commit**
exec
bash -lc 'git diff packages/providers/tidal/src/index.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93..d22f770 100644
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Reviewing new client and tests**
exec
bash -lc 'git diff codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Checking untracked files in directory**
exec
bash -lc 'git ls-files --stage codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 91ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Checking diff for new file**
exec
bash -lc 'git diff -- codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts' in /var/home/rick/Development/playlist-manager/. succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Diagnosing missing git diff output**
exec
bash -lc 'git add packages/providers/tidal/src/index.ts packages/providers/tidal/src/tidal.client.ts codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json' in /var/home/rick/Development/playlist-manager/. succeeded in 96ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Checking git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager/. succeeded in 44ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 3]
A  codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json
A  codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
M  packages/providers/tidal/src/index.ts
A  packages/providers/tidal/src/tidal.client.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Preparing final commit and message**
exec
bash -lc 'git commit -m "feat(tidal): implement importer/exporter"' in /var/home/rick/Development/playlist-manager/. succeeded in 127ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
[main 86410fa] feat(tidal): implement importer/exporter
 4 files changed, 521 insertions(+), 5 deletions(-)
 create mode 100644 codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json
 create mode 100644 codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
 create mode 100644 packages/providers/tidal/src/tidal.client.ts
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Checking git commit status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/playlist-manager/. succeeded in 56ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
## main...origin/main [ahead 4]
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Updating plan completion status**
Plan update
  ✓ Review existing provider implementations and task requirements
  ✓ Add failing tests per task in codex/code/codex/06d_tidal_impl/tests and run to observe failure
  ✓ Implement Tidal client and importer/exporter to satisfy tests
  ✓ Run full test suite (or relevant subset) to confirm pass
  ✓ Prepare and create commit with descriptive message
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Preparing for final response**
exec
bash -lc "nl -ba packages/providers/tidal/src/index.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager/. succeeded in 41ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import type {
     2	  BackoffOptions,
     3	  Exporter,
     4	  Importer,
     5	  PIF,
     6	  PIFTrack,
     7	  ProviderAuth,
     8	  ProviderImpl,
     9	  ProviderName,
    10	  ReadOptions,
    11	  WriteOptions,
    12	  WritePlaylistResult,
    13	} from '@app/contracts';
    14	import { RateLimitError } from '@app/contracts';
    15	
    16	import {
    17	  TidalClient,
    18	  type TidalTrackItem,
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Waiting for more input**
exec
bash -lc "nl -ba packages/providers/tidal/src/index.ts | sed -n '200,320p'" in /var/home/rick/Development/playlist-manager/. succeeded in 47ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
   200	  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
   201	    const client = this.ensureClient();
   202	    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
   203	
   204	    const created = await client.createPlaylist({
   205	      name: pif.name,
   206	      description: pif.description ?? null,
   207	    });
   208	
   209	    const playlistId = created.uuid;
   210	    if (!playlistId) {
   211	      throw new Error('Tidal playlist UUID missing from create response');
   212	    }
   213	
   214	    const trackIds: string[] = [];
   215	    let skipped = 0;
   216	
   217	    for (const track of pif.tracks) {
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Requesting line numbers**
exec
bash -lc "nl -ba packages/providers/tidal/src/tidal.client.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager/. succeeded in 39ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import { RateLimitError } from '@app/contracts';
     2	
     3	export interface TidalClientOptions {
     4	  token: string;
     5	  baseUrl?: string;
     6	}
     7	
     8	export interface TidalPlaylist {
     9	  uuid?: string;
    10	  name?: string | null;
    11	  description?: string | null;
    12	  numberOfTracks?: number | null;
    13	}
    14	
    15	export interface TidalArtist {
    16	  name?: string | null;
    17	}
    18	
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Capturing test lines**
exec
bash -lc "nl -ba codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager/. succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	import path from 'node:path';
     2	import { readFileSync } from 'node:fs';
     3	import { fileURLToPath } from 'node:url';
     4	
     5	import { afterEach, beforeEach, expect, test, vi } from 'vitest';
     6	import nock from 'nock';
     7	
     8	import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
     9	
    10	const baseUrl = 'https://api.tidal.com';
    11	const __filename = fileURLToPath(import.meta.url);
    12	const __dirname = path.dirname(__filename);
    13	
    14	const loadFixture = (name: string) =>
    15	  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
    16	
    17	beforeEach(() => {
    18	  nock.disableNetConnect();
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Noting to mention fixture lines**
exec
bash -lc 'nl -ba codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json' in /var/home/rick/Development/playlist-manager/. succeeded in 40ms:
/home/rick/.bashrc: line 30: /home/rick/.config/broot/launcher/bash/br: No such file or directory
/home/rick/.bash_profile: line 10: /home/rick/.config/broot/launcher/bash/br: No such file or directory
     1	{
     2	  "name": "T",
     3	  "description": "tidal mix",
     4	  "numberOfTracks": 2,
     5	  "items": [
     6	    {
     7	      "track": {
     8	        "id": "t1",
     9	        "title": "A",
    10	        "isrc": "USX1",
    11	        "artists": [{ "name": "AA" }],
    12	        "album": { "title": "AL" },
    13	        "duration": 123000
    14	      }
    15	    },
    16	    {
    17	      "track": {
    18	        "id": "t2",
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}


thinking
**Composing final commit summary with tests and status**

I’m organizing a clear final message covering the new Tidal importer/exporter implementation, detailed file references with line numbers, a rundown of test commands showing partial success and expected failures due to environment issues, plus a concise Git status noting untracked logs. I’ll also include the commit message and suggest natural next steps for improving the test environment to run the full suite smoothly.
codex
Implemented TIDAL importer/exporter end-to-end and added contract coverage.  
- Added pagination, ISRC resolution, and rate-limit-aware batching in provider facade (`packages/providers/tidal/src/index.ts:33`, `packages/providers/tidal/src/index.ts:154`, `packages/providers/tidal/src/index.ts:200`).  
- Built a lightweight Tidal HTTP client that propagates 429 retry metadata (`packages/providers/tidal/src/tidal.client.ts:45`).  
- Backed changes with Vitest coverage and shared fixtures for importer/exporter flows (`codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts:27`, `codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json:1`).

Tests  
- ✅ `pnpm vitest run codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts`  
- ⚠️ `pnpm vitest run` (fails for unrelated suites: missing deps such as `@prisma/client`, `fastify`, `nanoid`, and sandbox socket permissions)

Commit  
- `feat(tidal): implement importer/exporter`

Status  
- `## main...origin/main [ahead 4]`  
- Untracked log/work files remain under `codex/LOGS/` and `codex/TASKS/work_list` (left untouched).  

Next steps (optional)  
1. Restore/install the missing dependencies or adjust sandbox permissions, then rerun `pnpm vitest run` if full-suite validation is required.
file update:
diff --git a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
index 2a10d8b92b3b7e6545e5a561c328db726cff67b7..7358497715359710ef24f623a69520702be7ad4a
--- a/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
+++ b/codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts
@@ -1,28 +1,107 @@
+import path from 'node:path';
+import { readFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
 import nock from 'nock';
-import { expect, test } from 'vitest';
-import Tidal from '../../../../packages/providers/tidal/src';
 
-const td = new Tidal({ token: 't' });
+import Tidal from '../../../../../packages/providers/tidal/src/index.ts';
 
-test('importer -> maps tidal to PIF with isrc when present', async () => {
-  nock('https://api.tidal.com')
-    .get('/v1/playlists/ab12').reply(200, { name: 'T', numberOfTracks: 2 })
-    .get('/v1/playlists/ab12/tracks').query({ limit: 100, offset: 0 }).reply(200, {
-      items: [
-        { track: { title: 'A', isrc: 'USX1', artists: [{ name: 'AA' }], album: { title: 'AL' }, duration: 123000 } },
-        { track: { title: 'B', artists: [{ name: 'BB' }], album: { title: 'BL' }, duration: 1000 } }
-      ]
-    });
-  const pif = await td.readPlaylist({ id: 'ab12' });
-  expect(pif.tracks[0].isrc).toBe('USX1');
-  expect(pif.tracks[1].artists[0]).toBe('BB');
+const baseUrl = 'https://api.tidal.com';
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const loadFixture = (name: string) =>
+  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
 });
 
-test('exporter -> batch add handling', async () => {
-  const pif = { name: 'TX', tracks: [{ title: 'a', artists: ['x'] }, { title: 'b', artists: ['y'] }] };
-  nock('https://api.tidal.com')
-    .post('/v1/playlists').reply(200, { uuid: 'U123' })
-    .post('/v1/playlists/U123/items', body => true).reply(200, { succeeded: 2 });
-  const res = await td.writePlaylist({ pif });
-  expect(res.destId).toBe('U123');
+test('importer maps tidal playlist tracks into PIF, preferring track.isrc', async () => {
+  const provider = new Tidal({ token: 'test-token' });
+
+  const playlist = loadFixture('tidal.playlist.json');
+
+  nock(baseUrl)
+    .get('/v1/playlists/ab12')
+    .reply(200, {
+      name: playlist.name,
+      description: playlist.description,
+      numberOfTracks: playlist.numberOfTracks,
+    })
+    .get('/v1/playlists/ab12/tracks')
+    .query({ limit: 100, offset: 0 })
+    .reply(200, { items: playlist.items });
+
+  const pif = await provider.readPlaylist('ab12');
+
+  expect(pif).toMatchObject({
+    name: 'T',
+    description: 'tidal mix',
+    source_service: 'tidal',
+    source_playlist_id: 'ab12',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'A',
+    artists: ['AA'],
+    album: 'AL',
+    duration_ms: 123000,
+    isrc: 'USX1',
+    provider_ids: { tidal_track_id: 't1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'B',
+    artists: ['BB'],
+    album: 'BL',
+    duration_ms: 1000,
+    isrc: 'USX2',
+    provider_ids: { tidal_track_id: 't2' },
+  });
+});
+
+test('exporter creates playlist and adds tracks in batches with backoff on 429', async () => {
+  vi.useFakeTimers();
+
+  const provider = new Tidal({ token: 'test-token' });
+
+  nock(baseUrl)
+    .post('/v1/playlists', (body) => body?.name === 'TX')
+    .reply(200, { uuid: 'U123' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(429, { status: 429 }, { 'Retry-After': '1' })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 2)
+    .reply(200, { succeeded: 2 })
+    .post('/v1/playlists/U123/items', (body) => Array.isArray(body?.items) && body.items.length === 1)
+    .reply(200, { succeeded: 1 });
+
+  const pif = {
+    name: 'TX',
+    tracks: [
+      { position: 1, title: 'Track 1', artists: ['Artist'], provider_ids: { tidal_track_id: 'a' } },
+      { position: 2, title: 'Track 2', artists: ['Artist'], provider_ids: { tidal_track_id: 'b' } },
+      { position: 3, title: 'Track 3', artists: ['Artist'], provider_ids: { tidal_track_id: 'c' } },
+    ],
+  };
+
+  const pending = provider.writePlaylist(pif, { batch: { batchSize: 2 } });
+
+  await vi.advanceTimersByTimeAsync(1000);
+  const result = await pending;
+
+  expect(result.destId).toBe('U123');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
 });
diff --git a/packages/providers/tidal/src/index.ts b/packages/providers/tidal/src/index.ts
index aed2d93fc3809937916a6f80fc6801a1977a088d..d22f770fdb4fde975c93231105b58f5c08c298a6
--- a/packages/providers/tidal/src/index.ts
+++ b/packages/providers/tidal/src/index.ts
@@ -1,24 +1,254 @@
 import type {
+  BackoffOptions,
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
   WriteOptions,
   WritePlaylistResult,
 } from '@app/contracts';
+import { RateLimitError } from '@app/contracts';
+
+import {
+  TidalClient,
+  type TidalTrackItem,
+} from './tidal.client.ts';
+
+type Milliseconds = number;
+
+const DEFAULT_PAGE_SIZE = 100;
+const DEFAULT_BATCH_SIZE = 100;
+const DEFAULT_BACKOFF: Required<BackoffOptions> = {
+  retries: 3,
+  baseDelayMs: 500,
+  maxDelayMs: 8000,
+};
+
+const sleep = (ms: Milliseconds) => new Promise((resolve) => setTimeout(resolve, ms));
+
+const normalizePageSize = (pageSize: number | undefined): number => {
+  if (!pageSize || Number.isNaN(pageSize) || pageSize <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(pageSize), 100);
+};
+
+const normalizeBatchSize = (batchSize: number | undefined): number => {
+  if (!batchSize || Number.isNaN(batchSize) || batchSize <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(batchSize));
+};
+
+const normalizeBackoff = (backoff?: BackoffOptions): Required<BackoffOptions> => ({
+  retries: backoff?.retries ?? DEFAULT_BACKOFF.retries,
+  baseDelayMs: backoff?.baseDelayMs ?? DEFAULT_BACKOFF.baseDelayMs,
+  maxDelayMs: backoff?.maxDelayMs ?? DEFAULT_BACKOFF.maxDelayMs,
+});
+
+const toMilliseconds = (value: number | string | null | undefined): number | null => {
+  if (value === undefined || value === null) return null;
+  const numeric = Number(value);
+  if (!Number.isFinite(numeric) || numeric <= 0) return null;
+  if (numeric >= 1000) {
+    return Math.round(numeric);
+  }
+  return Math.round(numeric * 1000);
+};
+
+const extractArtists = (item: TidalTrackItem): string[] => {
+  const track = item?.track;
+  if (!track?.artists) return [];
+  return track.artists
+    .map((artist) => artist?.name?.trim())
+    .filter((name): name is string => Boolean(name));
+};
+
+const mapTrack = (item: TidalTrackItem, index: number): PIFTrack | undefined => {
+  const track = item?.track;
+  if (!track?.title) {
+    return undefined;
+  }
+
+  const artists = extractArtists(item);
+  const artistList = artists.length > 0 ? artists : ['Unknown Artist'];
+
+  const mapped: PIFTrack = {
+    position: index + 1,
+    title: track.title,
+    artists: artistList,
+    album: track.album?.title ?? null,
+    duration_ms: toMilliseconds(track.duration),
+    explicit: null,
+    release_date: null,
+    isrc: track.isrc ?? track.externalIds?.isrc ?? null,
+  };
+
+  if (track.id) {
+    mapped.provider_ids = { tidal_track_id: track.id };
+  }
+
+  return mapped;
+};
+
+interface TidalOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
 
 export default class Tidal implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'tidal';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: TidalOptions;
+  private client?: TidalClient;
+
+  constructor(options?: TidalOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): TidalClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('Tidal auth token is required');
+    }
+    this.client = new TidalClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private async fetchAllTracks(id: string, pageSize: number): Promise<TidalTrackItem[]> {
+    const client = this.ensureClient();
+    const items: TidalTrackItem[] = [];
+    let offset = 0;
+    let iteration = 0;
+    const maxIterations = 1000;
+
+    while (iteration < maxIterations) {
+      iteration += 1;
+      const page = await client.getPlaylistTracks(id, { limit: pageSize, offset });
+      const pageItems = Array.isArray(page.items) ? page.items : [];
+      if (pageItems.length === 0) {
+        break;
+      }
+
+      items.push(...pageItems);
+
+      if (pageItems.length < pageSize) {
+        break;
+      }
+
+      offset += pageItems.length;
+    }
+
+    return items;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlist = await client.getPlaylist(id);
+    const items = await this.fetchAllTracks(id, pageSize);
+
+    const tracks = items
+      .map(mapTrack)
+      .filter((track): track is NonNullable<ReturnType<typeof mapTrack>> => Boolean(track));
+
+    return {
+      name: playlist.name ?? 'Untitled Playlist',
+      description: playlist.description ?? null,
+      source_service: 'tidal',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async runWithBackoff<T>(fn: () => Promise<T>, backoff?: BackoffOptions): Promise<T> {
+    const { retries, baseDelayMs, maxDelayMs } = normalizeBackoff(backoff);
+    let attempt = 0;
+
+    while (true) {
+      try {
+        return await fn();
+      } catch (error) {
+        if (!(error instanceof RateLimitError)) {
+          throw error;
+        }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+        if (attempt >= retries) {
+          throw error;
+        }
+
+        const delay = Math.min(
+          error.retryAfterMs ?? baseDelayMs * Math.pow(2, attempt),
+          maxDelayMs,
+        );
+        attempt += 1;
+        await sleep(delay);
+      }
+    }
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      name: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const playlistId = created.uuid;
+    if (!playlistId) {
+      throw new Error('Tidal playlist UUID missing from create response');
+    }
+
+    const trackIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const tidalId = track.provider_ids?.tidal_track_id;
+      if (!tidalId) {
+        skipped += 1;
+        continue;
+      }
+      trackIds.push(tidalId);
+    }
+
+    let added = 0;
+
+    for (let cursor = 0; cursor < trackIds.length; cursor += batchSize) {
+      const batch = trackIds.slice(cursor, cursor + batchSize);
+      const result = await this.runWithBackoff(
+        () => client.addPlaylistItems(playlistId, batch),
+        opts?.backoff,
+      );
+      const succeeded = Math.min(result?.succeeded ?? batch.length, batch.length);
+      added += succeeded;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: trackIds.length,
+      added,
+      failed: Math.max(0, trackIds.length - added),
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing tidal_track_id`];
+    }
+
+    return {
+      destId: playlistId,
+      report,
+    };
   }
 }
diff --git a/packages/providers/tidal/src/tidal.client.ts b/packages/providers/tidal/src/tidal.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bfe0192933c55257e7e844f68c10eb8922a7585a
--- /dev/null
+++ b/packages/providers/tidal/src/tidal.client.ts
@@ -0,0 +1,152 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface TidalClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface TidalPlaylist {
+  uuid?: string;
+  name?: string | null;
+  description?: string | null;
+  numberOfTracks?: number | null;
+}
+
+export interface TidalArtist {
+  name?: string | null;
+}
+
+export interface TidalAlbum {
+  title?: string | null;
+}
+
+export interface TidalExternalIds {
+  isrc?: string | null;
+}
+
+export interface TidalTrack {
+  id?: string | null;
+  title?: string | null;
+  duration?: number | null;
+  isrc?: string | null;
+  artists?: TidalArtist[] | null;
+  album?: TidalAlbum | null;
+  externalIds?: TidalExternalIds | null;
+}
+
+export interface TidalTrackItem {
+  track?: TidalTrack | null;
+}
+
+export interface TidalTrackPage {
+  items?: TidalTrackItem[] | null;
+}
+
+const defaultBaseUrl = 'https://api.tidal.com';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric)) {
+    return Math.max(0, numeric) * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+export class TidalClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: TidalClientOptions) {
+    if (!options?.token) {
+      throw new Error('Tidal token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(path: string, query?: Record<string, string | number | undefined>): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: 'GET' | 'POST',
+    path: string,
+    options?: { body?: unknown; query?: Record<string, string | number | undefined> },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = { method, headers };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('Tidal rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`Tidal API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<TidalPlaylist> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}`);
+  }
+
+  getPlaylistTracks(id: string, opts: { limit: number; offset: number }): Promise<TidalTrackPage> {
+    const encoded = encodeURIComponent(id);
+    return this.request('GET', `/v1/playlists/${encoded}/tracks`, {
+      query: {
+        limit: opts.limit,
+        offset: opts.offset,
+      },
+    });
+  }
+
+  createPlaylist(payload: { name: string; description?: string | null }): Promise<{ uuid: string }> {
+    return this.request('POST', '/v1/playlists', { body: payload });
+  }
+
+  addPlaylistItems(
+    playlistId: string,
+    trackIds: string[],
+  ): Promise<{ succeeded: number }> {
+    const encoded = encodeURIComponent(playlistId);
+    const items = trackIds.map((id) => ({ id }));
+    return this.request('POST', `/v1/playlists/${encoded}/items`, { body: { items } });
+  }
+}

tokens used
111,626
Implemented TIDAL importer/exporter end-to-end and added contract coverage.  
- Added pagination, ISRC resolution, and rate-limit-aware batching in provider facade (`packages/providers/tidal/src/index.ts:33`, `packages/providers/tidal/src/index.ts:154`, `packages/providers/tidal/src/index.ts:200`).  
- Built a lightweight Tidal HTTP client that propagates 429 retry metadata (`packages/providers/tidal/src/tidal.client.ts:45`).  
- Backed changes with Vitest coverage and shared fixtures for importer/exporter flows (`codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts:27`, `codex/code/codex/06d_tidal_impl/tests/fixtures/tidal.playlist.json:1`).

Tests  
- ✅ `pnpm vitest run codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts`  
- ⚠️ `pnpm vitest run` (fails for unrelated suites: missing deps such as `@prisma/client`, `fastify`, `nanoid`, and sandbox socket permissions)

Commit  
- `feat(tidal): implement importer/exporter`

Status  
- `## main...origin/main [ahead 4]`  
- Untracked log/work files remain under `codex/LOGS/` and `codex/TASKS/work_list` (left untouched).  

Next steps (optional)  
1. Restore/install the missing dependencies or adjust sandbox permissions, then rerun `pnpm vitest run` if full-suite validation is required.
