OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a583b-9742-7cb2-b97a-75917ef667cc
--------
user
Implement the functionality described in codex/TASKS/06e_youtube_impl.yaml, then verify with any available tests.

thinking
**Preparing environment for task inspection**
exec
zsh -lc pwd in /var/home/rick/Development/playlist-manager succeeded in 145ms:
/home/rick/Development/playlist-manager

thinking
**Listing files**
exec
zsh -lc ls in /var/home/rick/Development/playlist-manager succeeded in 37ms:
AGENTS.md
apps
codex
codex.toml
docker-compose.yml
docs
dredd.server.yml
dredd.yml
env.json
node_modules
openapi.dredd.yaml
openapi.yaml
package.json
packages
pnpm-lock.yaml
pnpm-workspace.yaml
README.md
schemas
scripts
tsconfig.json

thinking
**Opening task file**
exec
zsh -lc 'cat codex/TASKS/06e_youtube_impl.yaml' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
id: 06e_youtube_impl
title: YouTube importer/exporter (mocked HTTP) to/from PIF (YT → YT Music)
branch: codex/06e_youtube_impl
overview: >
  Implement YouTube Importer/Exporter. Importer reads a playlist to PIF; exporter creates a playlist and adds videoIds.
  Prefer official artist/Topic channels; include basic search (mocked) when direct IDs not provided.
acceptance:
  - Tests in codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts pass:
    * importer maps items with duration/title/channel to PIF (best-effort ISRC absent).
    * exporter creates playlist and adds items in batches; uses cached mapping for title/artist → videoId.
artifacts_to_touch:
  - packages/providers/youtube/src/index.ts
  - packages/providers/youtube/src/youtube.client.ts
  - codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
constraints:
  - No real API; mock https://www.googleapis.com/youtube/v3/* with nock.
  - Search calls capped and cached (in-memory map) within the class (unit test asserts call count).
tests:
  path: codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
  content: |

thinking
**Preparing to follow TDD approach**
exec
zsh -lc "sed -n '1,160p' packages/providers/youtube/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 37ms:
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class YouTube implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'youtube';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');
  }


thinking
**Waiting for YouTube client details**
exec
zsh -lc "sed -n '1,200p' packages/providers/youtube/src/youtube.client.ts" in /var/home/rick/Development/playlist-manager exited 2 in 41ms:
sed: can't read packages/providers/youtube/src/youtube.client.ts: No such file or directory

thinking
**Searching for files in youtube provider**
exec
zsh -lc 'ls packages/providers/youtube/src' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
index.ts

thinking
**Preparing to add YouTube client and tests**
exec
zsh -lc "sed -n '1,200p' codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 40ms:
sed: can't read codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts: No such file or directory

thinking
**Checking project directory structure**
exec
zsh -lc 'ls codex' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
code
LOGS
support
TASKS

thinking
**Listing codex/code directory contents**
exec
zsh -lc 'ls codex/code' in /var/home/rick/Development/playlist-manager succeeded in 44ms:
codex

thinking
**Listing codex/code/codex directory**
exec
zsh -lc 'ls codex/code/codex' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
02a_prisma_init
02b_raw_migrations
03a_dbpkg_singleton
04a_api_validation_wiring
05a_pif_validator
05b_file_exporters
06a_provider_interfaces
06b_spotify_impl
06c_deezer_impl
06d_tidal_impl

thinking
**Checking for missing tests**
exec
zsh -lc 'ls codex/code/codex/06d_tidal_impl' in /var/home/rick/Development/playlist-manager succeeded in 46ms:
tests

thinking
**Listing test directory contents**
exec
zsh -lc 'ls codex/code/codex/06d_tidal_impl/tests' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
fixtures
tidal.impl.test.ts

thinking
**Checking test folder and setup**
exec
zsh -lc 'ls packages/providers' in /var/home/rick/Development/playlist-manager succeeded in 42ms:
core
deezer
file-exporters
spotify
tidal
youtube

thinking
**Inspecting other provider implementations**
exec
zsh -lc "sed -n '1,200p' packages/providers/spotify/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
import type {
  BackoffOptions,
  Exporter,
  Importer,
  PIF,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';
import { RateLimitError } from '@app/contracts';

import {
  SpotifyClient,
  type SpotifyPlaylist,
  type SpotifyPlaylistItem,
} from './spotify.client.ts';

exec
zsh -lc "sed -n '200,400p' packages/providers/spotify/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
      added += batch.length;
    }

    const report: WritePlaylistResult['report'] = {
      attempted: uris.length,
      added,
      failed: uris.length - added,
    };

    if (skipped > 0) {
      report.skipped = skipped;
      report.notes = [`${skipped} track(s) missing spotify_track_id`];
    }

    return {
      destId: created.id,
      report,
    };
  }
}

thinking
**Reviewing pattern usage and provider configurations**
exec
zsh -lc "sed -n '1,200p' packages/providers/tidal/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 40ms:
import type {
  BackoffOptions,
  Exporter,
  Importer,
  PIF,
  PIFTrack,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';
import { RateLimitError } from '@app/contracts';

import {
  TidalClient,
  type TidalTrackItem,
} from './tidal.client.ts';


thinking
**Reviewing provider implementation and tests**

I’m checking how to create a new YouTube provider by following the existing contracts and making sure the provider implements the correct interface without changing the spec. I'll focus on test-driven development by creating new test files first, and I want to confirm the proper import paths for tests by comparing with existing tests like the tidal implementation.
exec
zsh -lc "sed -n '1,200p' codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
import path from 'node:path';
import { readFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';

import { afterEach, beforeEach, expect, test, vi } from 'vitest';
import nock from 'nock';

import Tidal from '../../../../../packages/providers/tidal/src/index.ts';

const baseUrl = 'https://api.tidal.com';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const loadFixture = (name: string) =>
  JSON.parse(readFileSync(path.join(__dirname, 'fixtures', name), 'utf8'));

beforeEach(() => {
  nock.disableNetConnect();
});


thinking
**Preparing to create new test files**
exec
zsh -lc 'rg "class YouTube" -n' in /var/home/rick/Development/playlist-manager succeeded in 191ms:
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:86:export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:270:zsh -lc 'rg "class YouTube" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:220:export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:365:codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:373:packages/providers/youtube/src/index.ts:export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:2159:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:2413:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:2665:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:2924:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:3179:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:3440:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:3693:-export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:3733:export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:3985: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:4250: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:4536: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:4801: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:5091: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:5371: export default class YouTube implements ProviderImpl, Importer, Exporter {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:5638: export default class YouTube implements ProviderImpl, Importer, Exporter {

thinking
**Analyzing provider client implementation**
exec
zsh -lc "sed -n '1,200p' packages/providers/tidal/src/tidal.client.ts" in /var/home/rick/Development/playlist-manager succeeded in 37ms:
import { RateLimitError } from '@app/contracts';

export interface TidalClientOptions {
  token: string;
  baseUrl?: string;
}

export interface TidalPlaylist {
  uuid?: string;
  name?: string | null;
  description?: string | null;
  numberOfTracks?: number | null;
}

export interface TidalArtist {
  name?: string | null;
}

export interface TidalAlbum {
  title?: string | null;

thinking
**Verifying fetch usage and contract imports**
exec
zsh -lc 'rg "export interface PIF" -n' in /var/home/rick/Development/playlist-manager succeeded in 45ms:
codex/LOGS/tasklog_06e_youtube_impl_1762416891.log:320:zsh -lc 'rg "export interface PIF" -n' in /var/home/rick/Development/playlist-manager
codex/LOGS/tasklog_06d_tidal_impl_1762416484.log:260:export interface PIF {
codex/LOGS/tasklog_06d_tidal_impl_1762416484.log:268:export interface PIFTrack {
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:115:export interface PIF {
codex/LOGS/tasklog_06c_deezer_impl_1762415964.log:123:export interface PIFTrack {
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:235:export interface PIF {
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:243:export interface PIFTrack {
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:305:export interface PIFProviderIds {
codex/LOGS/tasklog_06b_spotify_impl_1762415175.log:313:export interface PIFTrack {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:102:export interface PIF {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:110:export interface PIFTrack {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:631:export interface PIFProviderIds {
codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log:639:export interface PIFTrack {
packages/contracts/src/pif.ts:6:export interface PIFProviderIds {
packages/contracts/src/pif.ts:14:export interface PIFTrack {
packages/contracts/src/pif.ts:28:export interface PIFDocument {
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:517:export interface PIFProviderIds {
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:525:export interface PIFTrack {
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:539:export interface PIFDocument {
codex/LOGS/tasklog_05a_pif_validator_1762403333.log:2620:export interface PIFProviderIds {

thinking
**Opening contracts provider file**
exec
zsh -lc "sed -n '1,160p' packages/contracts/src/providers.ts" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
// packages/contracts/src/providers.ts

/** Canonical provider IDs used across the app & OpenAPI spec */
export type ProviderName = 'spotify' | 'deezer' | 'tidal' | 'youtube';

/** Minimal PIF v1 types (keep in sync with /schemas/pif-v1.schema.json) */
export interface PIF {
  name: string;
  description?: string | null;
  source_service?: ProviderName | 'amazon' | null;
  source_playlist_id?: string | null;
  tracks: PIFTrack[];
}

export interface PIFTrack {
  position: number;                // 1-based
  title: string;
  artists: string[];               // primary first; features after
  album?: string | null;
  duration_ms?: number | null;

thinking
**Planning YouTube provider implementation**

I’m outlining a multi-step plan starting with tests for the importer and exporter, followed by implementing the YouTube provider logic, and then running tests to verify everything. This approach will help me stay organized and tackle the task methodically.
Plan update
  • Add YouTube importer/exporter tests and fixtures for TDD coverage
  • Implement YouTube provider client and importer/exporter logic
  • Run targeted and repo tests to ensure green

thinking
**Preparing test folder structure**
exec
zsh -lc 'mkdir -p codex/code/codex/06e_youtube_impl/tests/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 38ms:


thinking
**Preparing to create and enhance tests**

I’m planning to create a new test file with the given snippet and add imports like `nock` and `vitest`. I want to strengthen the tests by disabling real network calls and mocking APIs using `nock`, following best practices seen in other tests. I also need to create a `yt.playlist.json` fixture with sample playlist data, since it’s referenced in artifacts. The tests should load this fixture and verify key behaviors like importer mapping and caching search calls, even though the provided snippet is minimal. I’m considering expanding the tests to assert search caching limits and proper mapping of playlist items to PIF tracks, including parsing artist info from channel titles. This approach will help align with constraints and ensure reliable functionality.
exec
zsh -lc "sed -n '1,200p' codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts" in /var/home/rick/Development/playlist-manager succeeded in 51ms:
import { afterEach, beforeEach, expect, test, vi } from 'vitest';
import nock from 'nock';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import Deezer from '../../../../../packages/providers/deezer/src/index.ts';

import playlistFixture from './fixtures/deezer.playlist.json';
import createdFixture from './fixtures/deezer.created.json';

const baseUrl = 'https://api.deezer.com';

beforeEach(() => {
  nock.disableNetConnect();
});

afterEach(() => {
  nock.cleanAll();
  nock.enableNetConnect();
  vi.useRealTimers();
});

thinking
**Designing tests and fixtures for YouTube importer/exporter**

I'm planning tests using nock to mock YouTube API calls, creating fixtures like `yt.playlist.json` for playlist and video responses to reduce duplication. I want to ensure the importer properly maps playlist data and the exporter correctly creates playlists and adds videos, considering batch processing and search caching as per the task details. I'll examine task logs for further clues on expected test behaviors.
exec
zsh -lc "sed -n '1,200p' codex/LOGS/tasklog_06e_youtube_impl_1762416891.log" in /var/home/rick/Development/playlist-manager succeeded in 37ms:
OpenAI Codex v0.55.0 (research preview)
--------
workdir: /var/home/rick/Development/playlist-manager
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a583b-9742-7cb2-b97a-75917ef667cc
--------
user
Implement the functionality described in codex/TASKS/06e_youtube_impl.yaml, then verify with any available tests.

thinking
**Preparing environment for task inspection**
exec
zsh -lc pwd in /var/home/rick/Development/playlist-manager succeeded in 145ms:
/home/rick/Development/playlist-manager


thinking
**Planning caching and batch tests**

I’m figuring out how to test that unique track searches are cached properly using nock to intercept YouTube API calls, while also handling playlist item additions in batches. The idea is to confirm only two search calls happen despite repeated tracks and to ensure playlistItems requests correspond to batching logic, probably sending each track individually. I'll check earlier logs for related test details to align the plan.
exec
zsh -lc "rg \"exporter -> create \\+ add videos\" -n codex/LOGS/tasklog_06e_youtube_impl_1762416891.log" in /var/home/rick/Development/playlist-manager exited 1 in 40ms:


thinking
**Checking for test file references**
exec
zsh -lc 'rg "youtube.impl.test" -n codex/LOGS/tasklog_06e_youtube_impl_1762416891.log' in /var/home/rick/Development/playlist-manager succeeded in 39ms:
57:  - Tests in codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts pass:
63:  - codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
68:  path: codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
111:zsh -lc "sed -n '1,200p' codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts" in /var/home/rick/Development/playlist-manager exited 2 in 40ms:
112:sed: can't read codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts: No such file or directory
379:zsh -lc 'mkdir -p codex/code/codex/06e_youtube_impl/tests/fixtures' in /var/home/rick/Development/playlist-manager succeeded in 38ms:
447:zsh -lc 'rg "youtube.impl.test" -n codex/LOGS/tasklog_06e_youtube_impl_1762416891.log' in /var/home/rick/Development/playlist-manager


thinking
**Designing YouTube importer/exporter tests and client**
thinking
**Detailing YouTube provider batching and caching logic**

I’m outlining the batching approach to insert playlist items one request per video ID while processing chunks internally. The design includes caching search calls across the provider instance, parsing ISO durations, building search keys from normalized title and artists, and handling skipped tracks. I’m also preparing to write tests with mock HTTP interceptions to verify these behaviors end-to-end.
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
import { afterEach, beforeEach, expect, test, vi } from 'vitest';
import nock from 'nock';

import type { PIF } from '../../../../../packages/contracts/src/index.ts';
import YouTube from '../../../../../packages/providers/youtube/src/index.ts';

import fixture from './fixtures/yt.playlist.json';

const baseUrl = 'https://www.googleapis.com';

beforeEach(() => {
  nock.disableNetConnect();
});

afterEach(() => {
  nock.cleanAll();
  nock.enableNetConnect();
  vi.useRealTimers();
});

test('importer -> PIF basic mapping', async () => {
  const provider = new YouTube({ token: 'fake-token' });

  nock(baseUrl)
    .get('/youtube/v3/playlists')
    .query((query) => query.id === 'PL123')
    .reply(200, fixture.playlist)
    .get('/youtube/v3/playlistItems')
    .query((query) => query.playlistId === 'PL123')
    .reply(200, fixture.playlistItems)
    .get('/youtube/v3/videos')
    .query((query) => query.id === 'vid1,vid2')
    .reply(200, fixture.videos);

  const pif = await provider.readPlaylist('PL123');

  expect(pif).toMatchObject({
    name: 'Sample Mix',
    description: 'demo playlist',
    source_service: 'youtube',
    source_playlist_id: 'PL123',
  });
  expect(pif.tracks).toHaveLength(2);
  expect(pif.tracks[0]).toMatchObject({
    position: 1,
    title: 'Song One (Official Video)',
    artists: ['Artist One'],
    duration_ms: 185000,
    provider_ids: { youtube_video_id: 'vid1' },
  });
  expect(pif.tracks[1]).toMatchObject({
    position: 2,
    title: 'Song Two',
    artists: ['Artist Two'],
    duration_ms: 250000,
    provider_ids: { youtube_video_id: 'vid2' },
  });
});

test('exporter -> create + add videos with cached search', async () => {
  vi.useFakeTimers();

  const provider = new YouTube({ token: 'fake-token' });

  const searchScope = nock(baseUrl)
    .get('/youtube/v3/search')
    .query((query) => query.q?.includes('Song Two Artist Two'))
    .once()
    .reply(200, {
      items: [
        { id: { videoId: 'search_vid' } },
      ],
    });

  const playlistScope = nock(baseUrl)
    .post('/youtube/v3/playlists')
    .query((query) => query.part === 'snippet')
    .reply(200, { id: 'PLZ' });

  const itemsScope = nock(baseUrl)
    .post('/youtube/v3/playlistItems')
    .query((query) => query.part === 'snippet')
    .times(3)
    .reply(200, { status: 'ok' });

  const pif = {
    name: 'YT Out',
    tracks: [
      {
        position: 1,
        title: 'Direct Track',
        artists: ['Artist One'],
        provider_ids: { youtube_video_id: 'vid_direct' },
      },
      {
        position: 2,
        title: 'Song Two',
        artists: ['Artist Two'],
      },
      {
        position: 3,
        title: 'Song Two',
        artists: ['Artist Two'],
      },
    ],
  } satisfies PIF;

  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });

  await vi.runOnlyPendingTimersAsync();

  expect(result.destId).toBe('PLZ');
  expect(result.report).toMatchObject({
    attempted: 3,
    added: 3,
    failed: 0,
  });

  expect(searchScope.isDone()).toBe(true);
  expect(playlistScope.isDone()).toBe(true);
  expect(itemsScope.isDone()).toBe(true);
});
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Preparing fixture JSON data**
file update
A /var/home/rick/Development/playlist-manager/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
{
  "playlist": {
    "items": [
      {
        "id": "PL123",
        "snippet": {
          "title": "Sample Mix",
          "description": "demo playlist"
        }
      }
    ]
  },
  "playlistItems": {
    "items": [
      {
        "contentDetails": {
          "videoId": "vid1"
        }
      },
      {
        "contentDetails": {
          "videoId": "vid2"
        }
      }
    ]
  },
  "videos": {
    "items": [
      {
        "id": "vid1",
        "snippet": {
          "title": "Song One (Official Video)",
          "channelTitle": "Artist One - Topic"
        },
        "contentDetails": {
          "duration": "PT3M5S"
        }
      },
      {
        "id": "vid2",
        "snippet": {
          "title": "Song Two",
          "channelTitle": "Artist Two"
        },
        "contentDetails": {
          "duration": "PT4M10S"
        }
      }
    ]
  }
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Updating plan after tests check**
Plan update
  ✓ Add YouTube importer/exporter tests and fixtures for TDD coverage
  • Implement YouTube provider client and importer/exporter logic
  • Run targeted and repo tests to ensure green
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Preparing to run targeted tests**
exec
zsh -lc 'pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.11s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests | 2 failed) 11ms
   × importer -> PIF basic mapping 7ms
     → NIY
   × exporter -> create + add videos with cached search 2ms
     → (0 , default)(...).get(...).query(...).once is not a function

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts > importer -> PIF basic mapping
Error: NIY
 ❯ YouTube.readPlaylist packages/providers/youtube/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
     18|     throw new Error('NIY');
       |           ^
     19|   }
     20| 
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d0389e19c4ea4509ab18c93c1453e457f32cb375
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .once()
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Fixing nock interceptor usage in tests**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -67,3 +67,3 @@
     .query((query) => query.q?.includes('Song Two Artist Two'))
-    .once()
+    .times(1)
     .reply(200, {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9ffe39179e1c93eabe921656ed6bf65d120bc465
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .times(1)
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9ffe39179e1c93eabe921656ed6bf65d120bc465
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .times(1)
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Rerunning tests to confirm failure**
exec
zsh -lc 'pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.19s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests | 2 failed) 12ms
   × importer -> PIF basic mapping 8ms
     → NIY
   × exporter -> create + add videos with cached search 2ms
     → (0 , default)(...).get(...).query(...).times is not a function

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts > importer -> PIF basic mapping
Error: NIY
 ❯ YouTube.readPlaylist packages/providers/youtube/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
     18|     throw new Error('NIY');
       |           ^
     19|   }
     20| 
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9ffe39179e1c93eabe921656ed6bf65d120bc465
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .times(1)
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Investigating nock import and usage issues**
exec
zsh -lc "rg \"\\.times\" -n codex/code" in /var/home/rick/Development/playlist-manager succeeded in 47ms:
codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts:68:    .times(1)
codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts:83:    .times(3)
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9ffe39179e1c93eabe921656ed6bf65d120bc465
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,122 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .times(1)
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .times(3)
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Adjusting nock mock usage for repeated calls**
file update
M /var/home/rick/Development/playlist-manager/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -67,3 +67,2 @@
     .query((query) => query.q?.includes('Song Two Artist Two'))
-    .times(1)
     .reply(200, {
@@ -82,3 +81,8 @@
     .query((query) => query.part === 'snippet')
-    .times(3)
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
     .reply(200, { status: 'ok' });
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Rerunning tests without `times`**
exec
zsh -lc 'pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.12s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests | 2 failed) 11ms
   × importer -> PIF basic mapping 7ms
     → NIY
   × exporter -> create + add videos with cached search 2ms
     → NIY

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts > importer -> PIF basic mapping
Error: NIY
 ❯ YouTube.readPlaylist packages/providers/youtube/src/index.ts:18:11
     16| 
     17|   async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
     18|     throw new Error('NIY');
       |           ^
     19|   }
     20| 
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});


thinking
**Designing and implementing YouTube client and provider**

I'm planning to build a comprehensive `YouTubeClient` matching other providers, handling auth with bearer tokens, managing endpoints for playlists, videos, and searches, plus dealing with paging and batch limits. I'll design helper methods for requests, error handling, and data mapping to PIF tracks, then integrate this client into the provider's index with caching and playlist writing logic. My next step is creating `youtube.client.ts` with these detailed plans.
file update
A /var/home/rick/Development/playlist-manager/packages/providers/youtube/src/youtube.client.ts
import { RateLimitError } from '@app/contracts';

export interface YouTubeClientOptions {
  token: string;
  baseUrl?: string;
}

export interface YouTubePlaylistSnippet {
  title?: string | null;
  description?: string | null;
}

export interface YouTubePlaylistItem {
  id?: string | null;
  snippet?: YouTubePlaylistSnippet | null;
}

export interface YouTubePlaylistResponse {
  items?: YouTubePlaylistItem[] | null;
}

export interface YouTubePlaylistItemsResponse {
  items?: Array<{
    contentDetails?: {
      videoId?: string | null;
    } | null;
  }> | null;
  nextPageToken?: string | null;
}

export interface YouTubeVideoSnippet {
  title?: string | null;
  channelTitle?: string | null;
}

export interface YouTubeVideoDetails {
  duration?: string | null;
}

export interface YouTubeVideo {
  id?: string | null;
  snippet?: YouTubeVideoSnippet | null;
  contentDetails?: YouTubeVideoDetails | null;
}

export interface YouTubeVideosResponse {
  items?: YouTubeVideo[] | null;
}

export interface YouTubeSearchResponse {
  items?: Array<{
    id?: {
      videoId?: string | null;
    } | null;
  }> | null;
}

const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';

const parseRetryAfter = (value: string | null): number | undefined => {
  if (!value) return undefined;
  const numeric = Number(value);
  if (Number.isFinite(numeric) && numeric >= 0) {
    return numeric * 1000;
  }
  const timestamp = Date.parse(value);
  if (!Number.isNaN(timestamp)) {
    return Math.max(0, timestamp - Date.now());
  }
  return undefined;
};

type HttpMethod = 'GET' | 'POST';

export class YouTubeClient {
  private readonly baseUrl: string;

  constructor(private readonly options: YouTubeClientOptions) {
    if (!options?.token) {
      throw new Error('YouTube token is required');
    }
    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
  }

  private buildUrl(
    path: string,
    query?: Record<string, string | number | null | undefined>,
  ): string {
    const url = new URL(path, `${this.baseUrl}/`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value === undefined || value === null) continue;
        url.searchParams.set(key, String(value));
      }
    }
    return url.toString();
  }

  private async request<T>(
    method: HttpMethod,
    path: string,
    options?: {
      query?: Record<string, string | number | null | undefined>;
      body?: unknown;
    },
  ): Promise<T> {
    const url = this.buildUrl(path, options?.query);
    const headers: Record<string, string> = {
      authorization: `Bearer ${this.options.token}`,
    };
    const init: RequestInit = {
      method,
      headers,
    };

    if (options?.body !== undefined) {
      headers['content-type'] = 'application/json';
      init.body = JSON.stringify(options.body);
    }

    const response = await fetch(url, init);

    if (response.status === 429) {
      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
    }

    if (!response.ok) {
      const message = await response.text().catch(() => response.statusText);
      throw new Error(`YouTube API ${response.status}: ${message}`);
    }

    if (response.status === 204) {
      return undefined as T;
    }

    const text = await response.text();
    if (!text) {
      return undefined as T;
    }

    try {
      return JSON.parse(text) as T;
    } catch {
      return undefined as T;
    }
  }

  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
    return this.request('GET', '/playlists', {
      query: {
        part: 'snippet',
        id,
      },
    });
  }

  getPlaylistItems(
    playlistId: string,
    opts: { maxResults: number; pageToken?: string },
  ): Promise<YouTubePlaylistItemsResponse> {
    return this.request('GET', '/playlistItems', {
      query: {
        part: 'contentDetails',
        playlistId,
        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
        pageToken: opts.pageToken,
      },
    });
  }

  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
    return this.request('GET', '/videos', {
      query: {
        part: 'snippet,contentDetails',
        id: ids.join(','),
      },
    });
  }

  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
    return this.request('GET', '/search', {
      query: {
        part: 'snippet',
        type: 'video',
        maxResults,
        q: query,
      },
    });
  }

  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
    return this.request('POST', '/playlists', {
      query: { part: 'snippet' },
      body: {
        snippet: {
          title: payload.title,
          description: payload.description ?? null,
        },
        status: {
          privacyStatus: 'private',
        },
      },
    });
  }

  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
    for (const videoId of videoIds) {
      await this.request('POST', '/playlistItems', {
        query: { part: 'snippet' },
        body: {
          snippet: {
            playlistId,
            resourceId: {
              kind: 'youtube#video',
              videoId,
            },
          },
        },
      });
    }
  }
}
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
A packages/providers/youtube/src/youtube.client.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Preparing to implement YouTube client integration**
exec
zsh -lc "sed -n '1,160p' packages/providers/youtube/src/index.ts" in /var/home/rick/Development/playlist-manager succeeded in 37ms:
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class YouTube implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'youtube';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');
  }

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Designing YouTube provider implementation**

I'm working through importing types and defining helpers like `parseIsoDuration` and `normalizeArtist`. I’m outlining a class with options, client initialization, search caching, and key methods for reading playlists by paging through items, batching video detail fetches, extracting artist info, mapping tracks, and assembling the final playlist structure. Next, I plan to implement all this carefully in the target file.
file update
D /var/home/rick/Development/playlist-manager/packages/providers/youtube/src/index.ts
import type {
  Exporter,
  Importer,
  PIF,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

export default class YouTube implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'youtube';

  constructor(..._args: unknown[]) {}

  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
    throw new Error('NIY');
  }

  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
    throw new Error('NIY');
  }
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
D packages/providers/youtube/src/index.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
deleted file mode 100644
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..0000000000000000000000000000000000000000
--- a/packages/providers/youtube/src/index.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class YouTube implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'youtube';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
deleted file mode 100644
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..0000000000000000000000000000000000000000
--- a/packages/providers/youtube/src/index.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import type {
-  Exporter,
-  Importer,
-  PIF,
-  ProviderImpl,
-  ProviderName,
-  ReadOptions,
-  WriteOptions,
-  WritePlaylistResult,
-} from '@app/contracts';
-
-export default class YouTube implements ProviderImpl, Importer, Exporter {
-  public readonly name: ProviderName = 'youtube';
-
-  constructor(..._args: unknown[]) {}
-
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
-  }
-
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
-  }
-}
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Adding new implementation file**
file update
A /var/home/rick/Development/playlist-manager/packages/providers/youtube/src/index.ts
import type {
  Exporter,
  Importer,
  PIF,
  PIFTrack,
  ProviderAuth,
  ProviderImpl,
  ProviderName,
  ReadOptions,
  WriteOptions,
  WritePlaylistResult,
} from '@app/contracts';

import {
  YouTubeClient,
  type YouTubeVideo,
} from './youtube.client.ts';

interface YouTubeOptions {
  token?: string;
  auth?: ProviderAuth;
  baseUrl?: string;
}

const DEFAULT_PAGE_SIZE = 50;
const DEFAULT_BATCH_SIZE = 50;

const normalizePageSize = (value: number | undefined): number => {
  if (!value || Number.isNaN(value) || value <= 0) {
    return DEFAULT_PAGE_SIZE;
  }
  return Math.min(Math.trunc(value), 50);
};

const normalizeBatchSize = (value: number | undefined): number => {
  if (!value || Number.isNaN(value) || value <= 0) {
    return DEFAULT_BATCH_SIZE;
  }
  return Math.max(1, Math.trunc(value));
};

const ISO_DURATION_RE =
  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;

const parseDurationMs = (value: string | null | undefined): number | null => {
  if (!value) return null;
  const match = ISO_DURATION_RE.exec(value);
  if (!match) return null;

  const [, d, h, m, s] = match;

  const days = d ? Number(d) : 0;
  const hours = h ? Number(h) : 0;
  const minutes = m ? Number(m) : 0;
  const seconds = s ? Number(s) : 0;

  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
    return null;
  }

  const totalSeconds =
    (days * 24 * 60 * 60) +
    (hours * 60 * 60) +
    (minutes * 60) +
    seconds;

  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
    return null;
  }

  return Math.round(totalSeconds * 1000);
};

const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
  if (!channelTitle) return null;
  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
  return trimmed.length > 0 ? trimmed : null;
};

const extractArtists = (video: YouTubeVideo): string[] => {
  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
  if (fromChannel) {
    return [fromChannel];
  }
  return ['Unknown Artist'];
};

const chunk = <T,>(input: T[], size: number): T[][] => {
  if (input.length === 0) return [];
  const batches: T[][] = [];
  for (let i = 0; i < input.length; i += size) {
    batches.push(input.slice(i, i + size));
  }
  return batches;
};

const buildSearchKey = (track: PIFTrack): string | null => {
  const title = track.title?.trim().toLowerCase();
  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
  if (!title || artists.length === 0) {
    return null;
  }
  return `${title}|${artists.join(',')}`;
};

const buildSearchQuery = (track: PIFTrack): string | null => {
  const title = track.title?.trim();
  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
  if (!title || artists.length === 0) {
    return null;
  }
  return `${title} ${artists.join(' ')}`.trim();
};

export default class YouTube implements ProviderImpl, Importer, Exporter {
  public readonly name: ProviderName = 'youtube';

  private readonly options: YouTubeOptions;
  private client?: YouTubeClient;
  private readonly searchCache = new Map<string, string | null>();

  constructor(options?: YouTubeOptions) {
    this.options = options ?? {};
  }

  private ensureClient(): YouTubeClient {
    if (this.client) return this.client;
    const token = this.options.token ?? this.options.auth?.token;
    if (!token) {
      throw new Error('YouTube auth token is required');
    }
    this.client = new YouTubeClient({
      token,
      baseUrl: this.options.baseUrl,
    });
    return this.client;
  }

  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
    if (!video) return undefined;
    const title = video.snippet?.title?.trim();
    if (!title) {
      return undefined;
    }

    const track: PIFTrack = {
      position: index + 1,
      title,
      artists: extractArtists(video),
      album: null,
      duration_ms: parseDurationMs(video.contentDetails?.duration),
      explicit: null,
      release_date: null,
      isrc: null,
      provider_ids: { youtube_video_id: videoId },
    };

    return track;
  }

  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
    const client = this.ensureClient();
    const pageSize = normalizePageSize(opts?.pageSize);

    const playlistResponse = await client.getPlaylist(id);
    const playlistItemIds: string[] = [];
    let pageToken: string | undefined;
    let iterations = 0;

    while (iterations < 1000) {
      iterations += 1;
      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
      const items = page.items ?? [];
      for (const item of items) {
        const videoId = item?.contentDetails?.videoId;
        if (videoId) {
          playlistItemIds.push(videoId);
        }
      }
      if (!page.nextPageToken) {
        break;
      }
      pageToken = page.nextPageToken ?? undefined;
      if (!pageToken) {
        break;
      }
    }

    const videoMap = new Map<string, YouTubeVideo>();
    for (const group of chunk(playlistItemIds, 50)) {
      if (group.length === 0) continue;
      const details = await client.getVideos(group);
      const videos = details.items ?? [];
      for (const video of videos) {
        const videoId = video?.id;
        if (videoId) {
          videoMap.set(videoId, video);
        }
      }
    }

    const tracks = playlistItemIds
      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
      .filter((track): track is PIFTrack => Boolean(track));

    const playlistItem = playlistResponse.items?.[0];
    const snippet = playlistItem?.snippet;

    return {
      name: snippet?.title ?? `Playlist ${id}`,
      description: snippet?.description ?? null,
      source_service: 'youtube',
      source_playlist_id: id,
      tracks,
    };
  }

  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
    const directId = track.provider_ids?.youtube_video_id?.trim();
    if (directId) {
      return directId;
    }

    const key = buildSearchKey(track);
    if (!key) {
      return null;
    }

    if (this.searchCache.has(key)) {
      return this.searchCache.get(key) ?? null;
    }

    const query = buildSearchQuery(track);
    if (!query) {
      this.searchCache.set(key, null);
      return null;
    }

    const client = this.ensureClient();
    const response = await client.searchVideos(query, { maxResults: 5 });
    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
    this.searchCache.set(key, first);
    return first;
  }

  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
    const client = this.ensureClient();
    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);

    const created = await client.createPlaylist({
      title: pif.name,
      description: pif.description ?? null,
    });

    const videoIds: string[] = [];
    let skipped = 0;

    for (const track of pif.tracks) {
      const videoId = await this.resolveVideoId(track);
      if (videoId) {
        videoIds.push(videoId);
      } else {
        skipped += 1;
      }
    }

    let added = 0;

    for (const group of chunk(videoIds, batchSize)) {
      await client.insertPlaylistItems(created.id, group);
      added += group.length;
    }

    const report: WritePlaylistResult['report'] = {
      attempted: videoIds.length,
      added,
      failed: videoIds.length - added,
    };

    if (skipped > 0) {
      report.skipped = skipped;
      report.notes = [`${skipped} track(s) missing YouTube match`];
    }

    return {
      destId: created.id,
      report,
    };
  }
}
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A packages/providers/youtube/src/index.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Reviewing and verifying playlist handling and TypeScript imports**
exec
zsh -lc 'pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts' in /var/home/rick/Development/playlist-manager exited 1 in 2.31s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests | 2 failed) 16ms
   × importer -> PIF basic mapping 11ms
     → No nock matched for GET https://www.googleapis.com/playlists?part=snippet&id=PL123
   × exporter -> create + add videos with cached search 4ms
     → No nock matched for POST https://www.googleapis.com/playlists?part=snippet

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 2 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts > importer -> PIF basic mapping
Error: No nock matched for GET https://www.googleapis.com/playlists?part=snippet&id=PL123
 ❯ mockedFetch codex/support/nock.ts:256:9
    254|   }
    255| 
    256|   throw new Error(`No nock matched for ${method} ${requestUrl.toString…
       |         ^
    257| };
    258| 
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac78958a375a8bb5217059a38cf182664f8e067a
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,224 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const url = new URL(path, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Fixing URL construction in YouTube client**

I spotted that the base URL combined with a leading slash in the path causes URL resolution to drop the base path segment, leading to incorrect endpoint URLs. To fix this, I plan to normalize the path by stripping any leading slash before building the URL so that the base path stays intact when using the URL constructor. This will require updating the `buildUrl` method in `youtube.client.ts` accordingly.
file update
M /var/home/rick/Development/playlist-manager/packages/providers/youtube/src/youtube.client.ts
@@ -88,3 +88,4 @@
   ): string {
-    const url = new URL(path, `${this.baseUrl}/`);
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
     if (query) {
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M packages/providers/youtube/src/youtube.client.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Verifying test interception paths**
exec
zsh -lc 'pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts' in /var/home/rick/Development/playlist-manager succeeded in 2.22s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ✓ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests) 21ms

 Test Files  1 passed (1)
      Tests  2 passed (2)
   Start at  03:20:47
   Duration  480ms (transform 96ms, setup 0ms, collect 155ms, tests 21ms, environment 0ms, prepare 77ms)

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Running full test suite**
exec
zsh -lc 'pnpm vitest run' in /var/home/rick/Development/playlist-manager exited 1 in 4.23s:

 RUN  v3.1.1 /var/home/rick/Development/playlist-manager

 ❯ apps/api/src/routes/__tests__/auth.providers.test.ts (2 tests | 1 failed) 56ms
   ✓ GET /auth/providers > omits providers that are disabled via flags 26ms
   × feature guard middleware > blocks provider-dependent routes when a provider is disabled 28ms
     → Failed to load url nanoid (resolved id: nanoid) in /var/home/rick/Development/playlist-manager/apps/api/src/plugins/errors.ts. Does the file exist?
 ✓ codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts (2 tests) 34ms
 ✓ codex/code/codex/06b_spotify_impl/tests/spotify.impl.test.ts (2 tests) 29ms
 ✓ codex/code/codex/06d_tidal_impl/tests/tidal.impl.test.ts (2 tests) 32ms
 ✓ codex/code/codex/06c_deezer_impl/tests/deezer.impl.test.ts (2 tests) 31ms
 ❯ apps/api/src/dev/__tests__/ensure-api-dev.test.ts (2 tests | 2 failed) 17ms
   × ensureApiDevServer > spawns the API when target port is free 13ms
     → listen EPERM: operation not permitted 127.0.0.1
   × ensureApiDevServer > attaches to an existing API when port is busy 2ms
     → listen EPERM: operation not permitted 127.0.0.1
 ✓ packages/interop/test/importers/file-importers.test.ts (8 tests) 26ms
 ✓ apps/api/src/routes/__tests__/docs.test.ts (3 tests) 11ms
 ❯ packages/db/test/healthcheck.cli.test.ts (2 tests | 2 failed) 24ms
   × runHealthcheck CLI helper > exits with 0 and logs success when healthy 19ms
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Handling test suite failures due to environment**
Plan update
Added acceptance tests, implemented the YouTube provider/client, and ran the new tests plus full suite. Only targeted tests pass; full suite still has pre-existing environment failures (missing prisma/fastify/nanoid deps and privileged port binding).
  ✓ Add YouTube importer/exporter tests and fixtures for TDD coverage
  ✓ Implement YouTube provider client and importer/exporter logic
  ✓ Run targeted and repo tests to ensure green
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Checking for unstaged changes**
exec
zsh -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 127ms:
## main...origin/main [ahead 4]
 M packages/providers/youtube/src/index.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log.done
?? codex/LOGS/tasklog_06e_youtube_impl_1762416891.log
?? codex/TASKS/work_list
?? codex/code/codex/06e_youtube_impl/
?? packages/providers/youtube/src/youtube.client.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Preparing relevant files for commit**
exec
zsh -lc 'git add packages/providers/youtube/src/index.ts packages/providers/youtube/src/youtube.client.ts codex/code/codex/06e_youtube_impl/tests' in /var/home/rick/Development/playlist-manager succeeded in 122ms:

file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Checking staged changes**
exec
zsh -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 63ms:
## main...origin/main [ahead 4]
A  codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
A  codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
M  packages/providers/youtube/src/index.ts
A  packages/providers/youtube/src/youtube.client.ts
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log.done
?? codex/LOGS/tasklog_06e_youtube_impl_1762416891.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Verifying staged changes**
exec
zsh -lc 'git diff --cached' in /var/home/rick/Development/playlist-manager succeeded in 43ms:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000..7a08b25
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Preparing commit with detailed message**
exec
zsh -lc 'git commit -m "feat(youtube): implement importer and exporter"' in /var/home/rick/Development/playlist-manager succeeded in 79ms:
[main 0b80aa2] feat(youtube): implement importer and exporter
 4 files changed, 673 insertions(+), 5 deletions(-)
 create mode 100644 codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
 create mode 100644 codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
 create mode 100644 packages/providers/youtube/src/youtube.client.ts
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Verifying commit changes consistency**
exec
zsh -lc 'git status -sb' in /var/home/rick/Development/playlist-manager succeeded in 47ms:
## main...origin/main [ahead 5]
?? codex/LOGS/codex_run_2025-11-06_02-37-26.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log
?? codex/LOGS/tasklog_06a_provider_interfaces_1762414646.log.done
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log
?? codex/LOGS/tasklog_06b_spotify_impl_1762415175.log.done
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log
?? codex/LOGS/tasklog_06c_deezer_impl_1762415964.log.done
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log
?? codex/LOGS/tasklog_06d_tidal_impl_1762416484.log.done
?? codex/LOGS/tasklog_06e_youtube_impl_1762416891.log
?? codex/TASKS/work_list
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Preparing final summary and references**
exec
zsh -lc "nl -ba packages/providers/youtube/src/index.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 39ms:
     1	import type {
     2	  Exporter,
     3	  Importer,
     4	  PIF,
     5	  PIFTrack,
     6	  ProviderAuth,
     7	  ProviderImpl,
     8	  ProviderName,
     9	  ReadOptions,
    10	  WriteOptions,
    11	  WritePlaylistResult,
    12	} from '@app/contracts';
    13	
    14	import {
    15	  YouTubeClient,
    16	  type YouTubeVideo,
    17	} from './youtube.client.ts';
    18	
    19	interface YouTubeOptions {
    20	  token?: string;
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Continuing to review file for write function**
exec
zsh -lc "nl -ba packages/providers/youtube/src/index.ts | sed -n '200,360p'" in /var/home/rick/Development/playlist-manager succeeded in 38ms:
   200	    }
   201	
   202	    const tracks = playlistItemIds
   203	      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
   204	      .filter((track): track is PIFTrack => Boolean(track));
   205	
   206	    const playlistItem = playlistResponse.items?.[0];
   207	    const snippet = playlistItem?.snippet;
   208	
   209	    return {
   210	      name: snippet?.title ?? `Playlist ${id}`,
   211	      description: snippet?.description ?? null,
   212	      source_service: 'youtube',
   213	      source_playlist_id: id,
   214	      tracks,
   215	    };
   216	  }
   217	
   218	  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
   219	    const directId = track.provider_ids?.youtube_video_id?.trim();
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Noting line numbers for files**
exec
zsh -lc "nl -ba packages/providers/youtube/src/youtube.client.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
     1	import { RateLimitError } from '@app/contracts';
     2	
     3	export interface YouTubeClientOptions {
     4	  token: string;
     5	  baseUrl?: string;
     6	}
     7	
     8	export interface YouTubePlaylistSnippet {
     9	  title?: string | null;
    10	  description?: string | null;
    11	}
    12	
    13	export interface YouTubePlaylistItem {
    14	  id?: string | null;
    15	  snippet?: YouTubePlaylistSnippet | null;
    16	}
    17	
    18	export interface YouTubePlaylistResponse {
    19	  items?: YouTubePlaylistItem[] | null;
    20	}
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

exec
zsh -lc "nl -ba packages/providers/youtube/src/youtube.client.ts | sed -n '200,360p'" in /var/home/rick/Development/playlist-manager succeeded in 41ms:
   200	          description: payload.description ?? null,
   201	        },
   202	        status: {
   203	          privacyStatus: 'private',
   204	        },
   205	      },
   206	    });
   207	  }
   208	
   209	  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
   210	    for (const videoId of videoIds) {
   211	      await this.request('POST', '/playlistItems', {
   212	        query: { part: 'snippet' },
   213	        body: {
   214	          snippet: {
   215	            playlistId,
   216	            resourceId: {
   217	              kind: 'youtube#video',
   218	              videoId,
   219	            },
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Referencing test lines**
exec
zsh -lc "nl -ba codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts | sed -n '1,200p'" in /var/home/rick/Development/playlist-manager succeeded in 37ms:
     1	import { afterEach, beforeEach, expect, test, vi } from 'vitest';
     2	import nock from 'nock';
     3	
     4	import type { PIF } from '../../../../../packages/contracts/src/index.ts';
     5	import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
     6	
     7	import fixture from './fixtures/yt.playlist.json';
     8	
     9	const baseUrl = 'https://www.googleapis.com';
    10	
    11	beforeEach(() => {
    12	  nock.disableNetConnect();
    13	});
    14	
    15	afterEach(() => {
    16	  nock.cleanAll();
    17	  nock.enableNetConnect();
    18	  vi.useRealTimers();
    19	});
    20	
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}


thinking
**Preparing comprehensive final commit summary**

I'm pulling together a clear final message that explains the YouTube provider import/export implementation, references key modified files with line numbers, summarizes test results including passing targeted tests and failing full suite due to dependencies, and includes the full commit message plus a clean-but-untracked Git status report. I'll keep it concise, using bullet lists and plain text formatting per instructions.
codex
Implemented YouTube importer/exporter with a dedicated client, ISO duration handling, and cached search for repeated tracks.

- `packages/providers/youtube/src/index.ts:25` adds duration parsing, artist extraction, playlist pagination, and write-side search caching tied to `YouTubeClient`.
- `packages/providers/youtube/src/index.ts:246` batches playlist inserts while honoring cached videoId lookups and reporting skipped tracks.
- `packages/providers/youtube/src/youtube.client.ts:75` introduces a bearer-auth YouTube REST client covering playlist metadata, item listings, video detail fetches, search, and inserts.
- `codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts:21` drives importer/exporter behaviour with nock-backed fixtures.
- `codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json` supplies deterministic playlist/video payloads.

Tests:
- `pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts`
- `pnpm vitest run` *(fails for existing environment gaps: missing nanoid/fastify/@prisma/client/tweetnacl packages and EPERM on 127.0.0.1; no regressions from this change)*

Next steps:
1. Install the missing runtime deps (nanoid, fastify, @prisma/client, tweetnacl) and provide required scripts to unblock the full suite.
2. Re-run `pnpm vitest run` with elevated localhost permissions once dependencies are available.

Commit: `feat(youtube): implement importer and exporter`
Modified: packages/providers/youtube/src/index.ts; packages/providers/youtube/src/youtube.client.ts; codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts; codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
Git status: clean (only harness-generated codex/LOGS* remain untracked)
file update:
diff --git a/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
new file mode 100644
index 0000000000000000000000000000000000000000..7a08b2532c68d8b58c4f7cdfb6a6e9529646b9dd
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
@@ -0,0 +1,51 @@
+{
+  "playlist": {
+    "items": [
+      {
+        "id": "PL123",
+        "snippet": {
+          "title": "Sample Mix",
+          "description": "demo playlist"
+        }
+      }
+    ]
+  },
+  "playlistItems": {
+    "items": [
+      {
+        "contentDetails": {
+          "videoId": "vid1"
+        }
+      },
+      {
+        "contentDetails": {
+          "videoId": "vid2"
+        }
+      }
+    ]
+  },
+  "videos": {
+    "items": [
+      {
+        "id": "vid1",
+        "snippet": {
+          "title": "Song One (Official Video)",
+          "channelTitle": "Artist One - Topic"
+        },
+        "contentDetails": {
+          "duration": "PT3M5S"
+        }
+      },
+      {
+        "id": "vid2",
+        "snippet": {
+          "title": "Song Two",
+          "channelTitle": "Artist Two"
+        },
+        "contentDetails": {
+          "duration": "PT4M10S"
+        }
+      }
+    ]
+  }
+}
diff --git a/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e7caad4f89759fc701d48d8f86030a72c2a2368
--- /dev/null
+++ b/codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts
@@ -0,0 +1,126 @@
+import { afterEach, beforeEach, expect, test, vi } from 'vitest';
+import nock from 'nock';
+
+import type { PIF } from '../../../../../packages/contracts/src/index.ts';
+import YouTube from '../../../../../packages/providers/youtube/src/index.ts';
+
+import fixture from './fixtures/yt.playlist.json';
+
+const baseUrl = 'https://www.googleapis.com';
+
+beforeEach(() => {
+  nock.disableNetConnect();
+});
+
+afterEach(() => {
+  nock.cleanAll();
+  nock.enableNetConnect();
+  vi.useRealTimers();
+});
+
+test('importer -> PIF basic mapping', async () => {
+  const provider = new YouTube({ token: 'fake-token' });
+
+  nock(baseUrl)
+    .get('/youtube/v3/playlists')
+    .query((query) => query.id === 'PL123')
+    .reply(200, fixture.playlist)
+    .get('/youtube/v3/playlistItems')
+    .query((query) => query.playlistId === 'PL123')
+    .reply(200, fixture.playlistItems)
+    .get('/youtube/v3/videos')
+    .query((query) => query.id === 'vid1,vid2')
+    .reply(200, fixture.videos);
+
+  const pif = await provider.readPlaylist('PL123');
+
+  expect(pif).toMatchObject({
+    name: 'Sample Mix',
+    description: 'demo playlist',
+    source_service: 'youtube',
+    source_playlist_id: 'PL123',
+  });
+  expect(pif.tracks).toHaveLength(2);
+  expect(pif.tracks[0]).toMatchObject({
+    position: 1,
+    title: 'Song One (Official Video)',
+    artists: ['Artist One'],
+    duration_ms: 185000,
+    provider_ids: { youtube_video_id: 'vid1' },
+  });
+  expect(pif.tracks[1]).toMatchObject({
+    position: 2,
+    title: 'Song Two',
+    artists: ['Artist Two'],
+    duration_ms: 250000,
+    provider_ids: { youtube_video_id: 'vid2' },
+  });
+});
+
+test('exporter -> create + add videos with cached search', async () => {
+  vi.useFakeTimers();
+
+  const provider = new YouTube({ token: 'fake-token' });
+
+  const searchScope = nock(baseUrl)
+    .get('/youtube/v3/search')
+    .query((query) => query.q?.includes('Song Two Artist Two'))
+    .reply(200, {
+      items: [
+        { id: { videoId: 'search_vid' } },
+      ],
+    });
+
+  const playlistScope = nock(baseUrl)
+    .post('/youtube/v3/playlists')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { id: 'PLZ' });
+
+  const itemsScope = nock(baseUrl)
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' })
+    .post('/youtube/v3/playlistItems')
+    .query((query) => query.part === 'snippet')
+    .reply(200, { status: 'ok' });
+
+  const pif = {
+    name: 'YT Out',
+    tracks: [
+      {
+        position: 1,
+        title: 'Direct Track',
+        artists: ['Artist One'],
+        provider_ids: { youtube_video_id: 'vid_direct' },
+      },
+      {
+        position: 2,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+      {
+        position: 3,
+        title: 'Song Two',
+        artists: ['Artist Two'],
+      },
+    ],
+  } satisfies PIF;
+
+  const result = await provider.writePlaylist(pif, { batch: { batchSize: 1 } });
+
+  await vi.runOnlyPendingTimersAsync();
+
+  expect(result.destId).toBe('PLZ');
+  expect(result.report).toMatchObject({
+    attempted: 3,
+    added: 3,
+    failed: 0,
+  });
+
+  expect(searchScope.isDone()).toBe(true);
+  expect(playlistScope.isDone()).toBe(true);
+  expect(itemsScope.isDone()).toBe(true);
+});
diff --git a/packages/providers/youtube/src/index.ts b/packages/providers/youtube/src/index.ts
index ba7428671e9cbcd122817b2214e98fa44f8d9ecf..23141b398e89e48f99256cd4382d4cd9c0295def
--- a/packages/providers/youtube/src/index.ts
+++ b/packages/providers/youtube/src/index.ts
@@ -2,6 +2,8 @@
   Exporter,
   Importer,
   PIF,
+  PIFTrack,
+  ProviderAuth,
   ProviderImpl,
   ProviderName,
   ReadOptions,
@@ -9,16 +11,280 @@
   WritePlaylistResult,
 } from '@app/contracts';
 
+import {
+  YouTubeClient,
+  type YouTubeVideo,
+} from './youtube.client.ts';
+
+interface YouTubeOptions {
+  token?: string;
+  auth?: ProviderAuth;
+  baseUrl?: string;
+}
+
+const DEFAULT_PAGE_SIZE = 50;
+const DEFAULT_BATCH_SIZE = 50;
+
+const normalizePageSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_PAGE_SIZE;
+  }
+  return Math.min(Math.trunc(value), 50);
+};
+
+const normalizeBatchSize = (value: number | undefined): number => {
+  if (!value || Number.isNaN(value) || value <= 0) {
+    return DEFAULT_BATCH_SIZE;
+  }
+  return Math.max(1, Math.trunc(value));
+};
+
+const ISO_DURATION_RE =
+  /^P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
+
+const parseDurationMs = (value: string | null | undefined): number | null => {
+  if (!value) return null;
+  const match = ISO_DURATION_RE.exec(value);
+  if (!match) return null;
+
+  const [, d, h, m, s] = match;
+
+  const days = d ? Number(d) : 0;
+  const hours = h ? Number(h) : 0;
+  const minutes = m ? Number(m) : 0;
+  const seconds = s ? Number(s) : 0;
+
+  if ([days, hours, minutes, seconds].every((part) => !Number.isFinite(part))) {
+    return null;
+  }
+
+  const totalSeconds =
+    (days * 24 * 60 * 60) +
+    (hours * 60 * 60) +
+    (minutes * 60) +
+    seconds;
+
+  if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
+    return null;
+  }
+
+  return Math.round(totalSeconds * 1000);
+};
+
+const sanitizeArtist = (channelTitle: string | null | undefined): string | null => {
+  if (!channelTitle) return null;
+  const trimmed = channelTitle.replace(/\s*-\s*topic$/i, '').trim();
+  return trimmed.length > 0 ? trimmed : null;
+};
+
+const extractArtists = (video: YouTubeVideo): string[] => {
+  const fromChannel = sanitizeArtist(video.snippet?.channelTitle);
+  if (fromChannel) {
+    return [fromChannel];
+  }
+  return ['Unknown Artist'];
+};
+
+const chunk = <T,>(input: T[], size: number): T[][] => {
+  if (input.length === 0) return [];
+  const batches: T[][] = [];
+  for (let i = 0; i < input.length; i += size) {
+    batches.push(input.slice(i, i + size));
+  }
+  return batches;
+};
+
+const buildSearchKey = (track: PIFTrack): string | null => {
+  const title = track.title?.trim().toLowerCase();
+  const artists = (track.artists ?? []).map((a) => a.trim().toLowerCase()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title}|${artists.join(',')}`;
+};
+
+const buildSearchQuery = (track: PIFTrack): string | null => {
+  const title = track.title?.trim();
+  const artists = (track.artists ?? []).map((artist) => artist.trim()).filter(Boolean);
+  if (!title || artists.length === 0) {
+    return null;
+  }
+  return `${title} ${artists.join(' ')}`.trim();
+};
+
 export default class YouTube implements ProviderImpl, Importer, Exporter {
   public readonly name: ProviderName = 'youtube';
 
-  constructor(..._args: unknown[]) {}
+  private readonly options: YouTubeOptions;
+  private client?: YouTubeClient;
+  private readonly searchCache = new Map<string, string | null>();
+
+  constructor(options?: YouTubeOptions) {
+    this.options = options ?? {};
+  }
+
+  private ensureClient(): YouTubeClient {
+    if (this.client) return this.client;
+    const token = this.options.token ?? this.options.auth?.token;
+    if (!token) {
+      throw new Error('YouTube auth token is required');
+    }
+    this.client = new YouTubeClient({
+      token,
+      baseUrl: this.options.baseUrl,
+    });
+    return this.client;
+  }
+
+  private mapVideoToTrack(videoId: string, video: YouTubeVideo | undefined, index: number): PIFTrack | undefined {
+    if (!video) return undefined;
+    const title = video.snippet?.title?.trim();
+    if (!title) {
+      return undefined;
+    }
+
+    const track: PIFTrack = {
+      position: index + 1,
+      title,
+      artists: extractArtists(video),
+      album: null,
+      duration_ms: parseDurationMs(video.contentDetails?.duration),
+      explicit: null,
+      release_date: null,
+      isrc: null,
+      provider_ids: { youtube_video_id: videoId },
+    };
+
+    return track;
+  }
+
+  async readPlaylist(id: string, opts?: ReadOptions): Promise<PIF> {
+    const client = this.ensureClient();
+    const pageSize = normalizePageSize(opts?.pageSize);
+
+    const playlistResponse = await client.getPlaylist(id);
+    const playlistItemIds: string[] = [];
+    let pageToken: string | undefined;
+    let iterations = 0;
+
+    while (iterations < 1000) {
+      iterations += 1;
+      const page = await client.getPlaylistItems(id, { maxResults: pageSize, pageToken });
+      const items = page.items ?? [];
+      for (const item of items) {
+        const videoId = item?.contentDetails?.videoId;
+        if (videoId) {
+          playlistItemIds.push(videoId);
+        }
+      }
+      if (!page.nextPageToken) {
+        break;
+      }
+      pageToken = page.nextPageToken ?? undefined;
+      if (!pageToken) {
+        break;
+      }
+    }
+
+    const videoMap = new Map<string, YouTubeVideo>();
+    for (const group of chunk(playlistItemIds, 50)) {
+      if (group.length === 0) continue;
+      const details = await client.getVideos(group);
+      const videos = details.items ?? [];
+      for (const video of videos) {
+        const videoId = video?.id;
+        if (videoId) {
+          videoMap.set(videoId, video);
+        }
+      }
+    }
+
+    const tracks = playlistItemIds
+      .map((videoId, index) => this.mapVideoToTrack(videoId, videoMap.get(videoId), index))
+      .filter((track): track is PIFTrack => Boolean(track));
+
+    const playlistItem = playlistResponse.items?.[0];
+    const snippet = playlistItem?.snippet;
+
+    return {
+      name: snippet?.title ?? `Playlist ${id}`,
+      description: snippet?.description ?? null,
+      source_service: 'youtube',
+      source_playlist_id: id,
+      tracks,
+    };
+  }
+
+  private async resolveVideoId(track: PIFTrack): Promise<string | null> {
+    const directId = track.provider_ids?.youtube_video_id?.trim();
+    if (directId) {
+      return directId;
+    }
+
+    const key = buildSearchKey(track);
+    if (!key) {
+      return null;
+    }
+
+    if (this.searchCache.has(key)) {
+      return this.searchCache.get(key) ?? null;
+    }
 
-  async readPlaylist(_id: string, _opts?: ReadOptions): Promise<PIF> {
-    throw new Error('NIY');
+    const query = buildSearchQuery(track);
+    if (!query) {
+      this.searchCache.set(key, null);
+      return null;
+    }
+
+    const client = this.ensureClient();
+    const response = await client.searchVideos(query, { maxResults: 5 });
+    const first = response.items?.[0]?.id?.videoId?.trim() ?? null;
+    this.searchCache.set(key, first);
+    return first;
   }
 
-  async writePlaylist(_pif: PIF, _opts?: WriteOptions): Promise<WritePlaylistResult> {
-    throw new Error('NIY');
+  async writePlaylist(pif: PIF, opts?: WriteOptions): Promise<WritePlaylistResult> {
+    const client = this.ensureClient();
+    const batchSize = normalizeBatchSize(opts?.batch?.batchSize);
+
+    const created = await client.createPlaylist({
+      title: pif.name,
+      description: pif.description ?? null,
+    });
+
+    const videoIds: string[] = [];
+    let skipped = 0;
+
+    for (const track of pif.tracks) {
+      const videoId = await this.resolveVideoId(track);
+      if (videoId) {
+        videoIds.push(videoId);
+      } else {
+        skipped += 1;
+      }
+    }
+
+    let added = 0;
+
+    for (const group of chunk(videoIds, batchSize)) {
+      await client.insertPlaylistItems(created.id, group);
+      added += group.length;
+    }
+
+    const report: WritePlaylistResult['report'] = {
+      attempted: videoIds.length,
+      added,
+      failed: videoIds.length - added,
+    };
+
+    if (skipped > 0) {
+      report.skipped = skipped;
+      report.notes = [`${skipped} track(s) missing YouTube match`];
+    }
+
+    return {
+      destId: created.id,
+      report,
+    };
   }
 }
diff --git a/packages/providers/youtube/src/youtube.client.ts b/packages/providers/youtube/src/youtube.client.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fce6460db83ad4b14375cd85c3aa2058c033047
--- /dev/null
+++ b/packages/providers/youtube/src/youtube.client.ts
@@ -0,0 +1,225 @@
+import { RateLimitError } from '@app/contracts';
+
+export interface YouTubeClientOptions {
+  token: string;
+  baseUrl?: string;
+}
+
+export interface YouTubePlaylistSnippet {
+  title?: string | null;
+  description?: string | null;
+}
+
+export interface YouTubePlaylistItem {
+  id?: string | null;
+  snippet?: YouTubePlaylistSnippet | null;
+}
+
+export interface YouTubePlaylistResponse {
+  items?: YouTubePlaylistItem[] | null;
+}
+
+export interface YouTubePlaylistItemsResponse {
+  items?: Array<{
+    contentDetails?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+  nextPageToken?: string | null;
+}
+
+export interface YouTubeVideoSnippet {
+  title?: string | null;
+  channelTitle?: string | null;
+}
+
+export interface YouTubeVideoDetails {
+  duration?: string | null;
+}
+
+export interface YouTubeVideo {
+  id?: string | null;
+  snippet?: YouTubeVideoSnippet | null;
+  contentDetails?: YouTubeVideoDetails | null;
+}
+
+export interface YouTubeVideosResponse {
+  items?: YouTubeVideo[] | null;
+}
+
+export interface YouTubeSearchResponse {
+  items?: Array<{
+    id?: {
+      videoId?: string | null;
+    } | null;
+  }> | null;
+}
+
+const defaultBaseUrl = 'https://www.googleapis.com/youtube/v3';
+
+const parseRetryAfter = (value: string | null): number | undefined => {
+  if (!value) return undefined;
+  const numeric = Number(value);
+  if (Number.isFinite(numeric) && numeric >= 0) {
+    return numeric * 1000;
+  }
+  const timestamp = Date.parse(value);
+  if (!Number.isNaN(timestamp)) {
+    return Math.max(0, timestamp - Date.now());
+  }
+  return undefined;
+};
+
+type HttpMethod = 'GET' | 'POST';
+
+export class YouTubeClient {
+  private readonly baseUrl: string;
+
+  constructor(private readonly options: YouTubeClientOptions) {
+    if (!options?.token) {
+      throw new Error('YouTube token is required');
+    }
+    this.baseUrl = (options.baseUrl ?? defaultBaseUrl).replace(/\/$/, '');
+  }
+
+  private buildUrl(
+    path: string,
+    query?: Record<string, string | number | null | undefined>,
+  ): string {
+    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
+    const url = new URL(normalizedPath, `${this.baseUrl}/`);
+    if (query) {
+      for (const [key, value] of Object.entries(query)) {
+        if (value === undefined || value === null) continue;
+        url.searchParams.set(key, String(value));
+      }
+    }
+    return url.toString();
+  }
+
+  private async request<T>(
+    method: HttpMethod,
+    path: string,
+    options?: {
+      query?: Record<string, string | number | null | undefined>;
+      body?: unknown;
+    },
+  ): Promise<T> {
+    const url = this.buildUrl(path, options?.query);
+    const headers: Record<string, string> = {
+      authorization: `Bearer ${this.options.token}`,
+    };
+    const init: RequestInit = {
+      method,
+      headers,
+    };
+
+    if (options?.body !== undefined) {
+      headers['content-type'] = 'application/json';
+      init.body = JSON.stringify(options.body);
+    }
+
+    const response = await fetch(url, init);
+
+    if (response.status === 429) {
+      const retryAfter = parseRetryAfter(response.headers.get('retry-after'));
+      throw new RateLimitError('YouTube rate limit exceeded', retryAfter);
+    }
+
+    if (!response.ok) {
+      const message = await response.text().catch(() => response.statusText);
+      throw new Error(`YouTube API ${response.status}: ${message}`);
+    }
+
+    if (response.status === 204) {
+      return undefined as T;
+    }
+
+    const text = await response.text();
+    if (!text) {
+      return undefined as T;
+    }
+
+    try {
+      return JSON.parse(text) as T;
+    } catch {
+      return undefined as T;
+    }
+  }
+
+  getPlaylist(id: string): Promise<YouTubePlaylistResponse> {
+    return this.request('GET', '/playlists', {
+      query: {
+        part: 'snippet',
+        id,
+      },
+    });
+  }
+
+  getPlaylistItems(
+    playlistId: string,
+    opts: { maxResults: number; pageToken?: string },
+  ): Promise<YouTubePlaylistItemsResponse> {
+    return this.request('GET', '/playlistItems', {
+      query: {
+        part: 'contentDetails',
+        playlistId,
+        maxResults: Math.min(Math.max(opts.maxResults, 1), 50),
+        pageToken: opts.pageToken,
+      },
+    });
+  }
+
+  getVideos(ids: string[]): Promise<YouTubeVideosResponse> {
+    return this.request('GET', '/videos', {
+      query: {
+        part: 'snippet,contentDetails',
+        id: ids.join(','),
+      },
+    });
+  }
+
+  searchVideos(query: string, opts?: { maxResults?: number }): Promise<YouTubeSearchResponse> {
+    const maxResults = opts?.maxResults && opts.maxResults > 0 ? Math.min(opts.maxResults, 10) : 5;
+    return this.request('GET', '/search', {
+      query: {
+        part: 'snippet',
+        type: 'video',
+        maxResults,
+        q: query,
+      },
+    });
+  }
+
+  createPlaylist(payload: { title: string; description?: string | null }): Promise<{ id: string }> {
+    return this.request('POST', '/playlists', {
+      query: { part: 'snippet' },
+      body: {
+        snippet: {
+          title: payload.title,
+          description: payload.description ?? null,
+        },
+        status: {
+          privacyStatus: 'private',
+        },
+      },
+    });
+  }
+
+  async insertPlaylistItems(playlistId: string, videoIds: string[]): Promise<void> {
+    for (const videoId of videoIds) {
+      await this.request('POST', '/playlistItems', {
+        query: { part: 'snippet' },
+        body: {
+          snippet: {
+            playlistId,
+            resourceId: {
+              kind: 'youtube#video',
+              videoId,
+            },
+          },
+        },
+      });
+    }
+  }
+}

tokens used
135,043
Implemented YouTube importer/exporter with a dedicated client, ISO duration handling, and cached search for repeated tracks.

- `packages/providers/youtube/src/index.ts:25` adds duration parsing, artist extraction, playlist pagination, and write-side search caching tied to `YouTubeClient`.
- `packages/providers/youtube/src/index.ts:246` batches playlist inserts while honoring cached videoId lookups and reporting skipped tracks.
- `packages/providers/youtube/src/youtube.client.ts:75` introduces a bearer-auth YouTube REST client covering playlist metadata, item listings, video detail fetches, search, and inserts.
- `codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts:21` drives importer/exporter behaviour with nock-backed fixtures.
- `codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json` supplies deterministic playlist/video payloads.

Tests:
- `pnpm vitest run codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts`
- `pnpm vitest run` *(fails for existing environment gaps: missing nanoid/fastify/@prisma/client/tweetnacl packages and EPERM on 127.0.0.1; no regressions from this change)*

Next steps:
1. Install the missing runtime deps (nanoid, fastify, @prisma/client, tweetnacl) and provide required scripts to unblock the full suite.
2. Re-run `pnpm vitest run` with elevated localhost permissions once dependencies are available.

Commit: `feat(youtube): implement importer and exporter`
Modified: packages/providers/youtube/src/index.ts; packages/providers/youtube/src/youtube.client.ts; codex/code/codex/06e_youtube_impl/tests/youtube.impl.test.ts; codex/code/codex/06e_youtube_impl/tests/fixtures/yt.playlist.json
Git status: clean (only harness-generated codex/LOGS* remain untracked)
